
-- Script for creating a planning factory datamodel in an existing database
-- Gerd Tautenhahn for saxess-software gmbh 05/2017
-- Version PlanningFactory 4.0
-- Coding UTF-8 without BOM 


/*
Script to create the DataFactory Default Schemas
Gerd Tautenhahn for saxess-software gmbh
04/2017 for DataFactory 4.0
*/


IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'sxdf' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA sxdf AUTHORIZATION dbo'   
	END
GO


IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'staging' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA staging AUTHORIZATION dbo'   
	END
GO

IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'load' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA load AUTHORIZATION dbo'   
	END
GO

IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'import' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA import AUTHORIZATION dbo'   
	END
GO

IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'calc' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA calc AUTHORIZATION dbo'   
	END
GO

IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'param' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA param AUTHORIZATION dbo'   
	END
GO


IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'control' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA control AUTHORIZATION dbo'   
	END
GO

IF NOT EXISTS (
	SELECT  schema_name
	FROM    information_schema.schemata
	WHERE   schema_name = 'result' ) 
 
	BEGIN
		EXEC sp_executesql N'CREATE SCHEMA result AUTHORIZATION dbo'   
	END
GO
/*
Table for logging API Procedure Calls
Gerd Tautenhahn for saxess-software gmbh
10/2015 for PlanningFactory 4.0
*/


IF  NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_API_Log]') AND type in (N'U'))

CREATE TABLE sx_pf_API_Log

(
	 LogKey BIGINT NOT NULL IDENTITY (1,1)
	,SQLSystemUser NVARCHAR (255) DEFAULT ('') NOT NULL
	,UserName NVARCHAR (255) DEFAULT ('') NOT NULL
	,TransactUsername NVARCHAR (255) DEFAULT ('') NOT NULL
	,ProcedureName NVARCHAR (255) DEFAULT ('') NOT NULL
	,ParameterString  NVARCHAR (MAX) DEFAULT ('') NOT NULL
	,EffectedRows INT DEFAULT (0) NOT NULL
	,ReturnCode INT DEFAULT (0) NOT NULL
	,TimestampCall DATETIME DEFAULT (0) NOT NULL
	,TimestampReturn DATETIME DEFAULT (0) NOT NULL
	,Comment NVARCHAR (2000) DEFAULT ('') NOT NULL
	,ProcessCode NVARCHAR (255) DEFAULT ('') NOT NULL

	CONSTRAINT PK_sx_pf_API_Log_PK PRIMARY KEY CLUSTERED ([LogKey])
)
GO
-- MigrationScript
-- Create Table dTime and delete Placeholders if API was before 4.0.57
-- Gerd Tautenhahn for saxess-software gmbh
-- 09/2016 PlanningFactory 4.0

DECLARE @APIVersion NVARCHAR(255)

SELECT @APIVersion = Right(ValueText,2) FROM sx_pf_gCluster WHERE PropertyID = 'C04'

IF CAST(@APIVersion AS INT) <= 57
BEGIN
		CREATE TABLE sx_pf_dTime(
	 
			 TimeKey INT NOT NULL IDENTITY (1,1)
			,ProductKey INT DEFAULT (0) NOT NULL
			,ProductLineKey INT DEFAULT (0) NOT NULL
			,FactoryKey INT DEFAULT (0) NOT NULL

			,ProductID NVARCHAR(255) DEFAULT ('') NOT NULL
			,ProductLineID NVARCHAR(255) DEFAULT ('') NOT NULL
			,FactoryID NVARCHAR(255) DEFAULT ('') NOT NULL
			,TimeID BIGINT DEFAULT (0) NOT NULL

		CONSTRAINT PK_sx_pf_dTime_PK PRIMARY KEY (TimeKey)

		)

		-- Fill sx_pf_dTime
		INSERT INTO sx_pf_dTime
	
				-- Existing TimeID per Product
				SELECT 
					 fV.ProductKey
					,fV.ProductLineKey
					,fV.FactoryKey
					,fV.ProductID
					,fV.ProductLineID
					,fV.FactoryID
					,TimeID

				FROM
					sx_pf_fValues fV 

				GROUP BY 
					 fV.ProductKey
					,fV.ProductLineKey
					,fV.FactoryKey
					,fV.ProductID
					,fV.ProductLineID
					,fV.FactoryID
					,TimeID

		-- Delete Placeholder Values
		DELETE FROM sx_pf_fValues
			WHERE (ValueText = '-' AND ValueInt = 0 AND ValueFormula = '') OR
				  (ValueText = '' AND ValueInt = 0 AND ValueFormula = '')
		
		-- Delete numeric Values in text ValueSeries
		UPDATE fV
		  SET fV.ValueInt = 0 
		  FROM sx_pf_fValues fV, sx_pf_dValueSeries dVS
		  WHERE 
			fV.ValueSeriesKey = dVS.ValueSeriesKey AND
			dVS.IsNumeric = 0 AND
			fV.ValueInt != 0

		-- Delete text Values in numeric ValueSeries
		UPDATE fV
		  SET fV.ValueText = '' 
		  FROM sx_pf_fValues fV, sx_pf_dValueSeries dVS
		  WHERE 
			fV.ValueSeriesKey = dVS.ValueSeriesKey AND
			dVS.IsNumeric = 1 AND
			fV.ValueText != ''

		-- Delete formulas in non formula ValueSeries
		UPDATE fV
		  SET fV.ValueFormula = '' 
		  FROM sx_pf_fValues fV, sx_pf_dValueSeries dVS
		  WHERE 
			fV.ValueSeriesKey = dVS.ValueSeriesKey AND
			dVS.ValueSource NOT IN ('XLS','XLS-Strict') AND
			fV.ValueFormula != ''
		
	END

GO


	
-- MigrationScript
-- Delete lists, which are realized from 4.0.60 as internal system list
-- Gerd Tautenhahn for saxess-software gmbh
-- 12/2016 PlanningFactory 4.0

DECLARE @APIVersion NVARCHAR(255)

SELECT @APIVersion = Right(ValueText,2) FROM sx_pf_gCluster WHERE PropertyID = 'C04'

IF CAST(@APIVersion AS INT) <= 59
BEGIN
	DELETE FROM sx_pf_hLists WHERE ListID IN ('sxIsNumeric','sxScales', 'sxValueEffects', 'sxValueLists', 'sxValueFormats', 'sxValueSources', 'sxVisibilityLevel');

	DELETE FROM sx_pf_hListValues WHERE ListID IN ('sxIsNumeric','sxScales', 'sxValueEffects', 'sxValueLists', 'sxValueFormats', 'sxValueSources', 'sxVisibilityLevel');
END

GO


	
--Removes Spaces from all IDs, stronger checks from API 4.0.59 on

UPDATE sx_pf_dFactories 
    SET FactoryID = REPLACE(FactoryID,' ','')

UPDATE sx_pf_dProductLines  
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        GlobalAttributeSource1 = REPLACE(GlobalAttributeSource1,' ',''), --due to ListIDs
        GlobalAttributeSource2 = REPLACE(GlobalAttributeSource2,' ',''), 
        GlobalAttributeSource3 = REPLACE(GlobalAttributeSource3,' ',''), 
        GlobalAttributeSource4 = REPLACE(GlobalAttributeSource4,' ',''), 
        GlobalAttributeSource5 = REPLACE(GlobalAttributeSource5,' ',''), 
        GlobalAttributeSource6 = REPLACE(GlobalAttributeSource6,' ',''), 
        GlobalAttributeSource7 = REPLACE(GlobalAttributeSource7,' ',''), 
        GlobalAttributeSource8 = REPLACE(GlobalAttributeSource8,' ',''), 
        GlobalAttributeSource9 = REPLACE(GlobalAttributeSource9,' ',''), 
        GlobalAttributeSource10 = REPLACE(GlobalAttributeSource10,' ',''), 
        GlobalAttributeSource11 = REPLACE(GlobalAttributeSource11,' ',''), 
        GlobalAttributeSource12 = REPLACE(GlobalAttributeSource12,' ',''), 
        GlobalAttributeSource13 = REPLACE(GlobalAttributeSource13,' ',''), 
        GlobalAttributeSource14 = REPLACE(GlobalAttributeSource14,' ',''), 
        GlobalAttributeSource15 = REPLACE(GlobalAttributeSource15,' ',''), 
        GlobalAttributeSource16 = REPLACE(GlobalAttributeSource16,' ',''), 
        GlobalAttributeSource17 = REPLACE(GlobalAttributeSource17,' ',''), 
        GlobalAttributeSource18 = REPLACE(GlobalAttributeSource18,' ',''), 
        GlobalAttributeSource19 = REPLACE(GlobalAttributeSource19,' ',''), 
        GlobalAttributeSource20 = REPLACE(GlobalAttributeSource20,' ',''), 
        GlobalAttributeSource21 = REPLACE(GlobalAttributeSource21,' ',''), 
        GlobalAttributeSource22 = REPLACE(GlobalAttributeSource22,' ',''), 
        GlobalAttributeSource23 = REPLACE(GlobalAttributeSource23,' ',''), 
        GlobalAttributeSource24 = REPLACE(GlobalAttributeSource24,' ',''), 
        GlobalAttributeSource25 = REPLACE(GlobalAttributeSource25,' ','')

UPDATE sx_pf_dProducts
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        ProductID = REPLACE(ProductID,' ','')

UPDATE sx_pf_dValueSeries
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        ProductID = REPLACE(ProductID,' ',''),
        ValueSeriesID = REPLACE(ValueSeriesID,' ',''),
        Effect = REPLACE(Effect,' ',''), --due to EffectID in gValueEffects
        ValueListID = REPLACE(ValueListID,' ',''),
        ValueFormatID = REPLACE(ValueFormatID,' ','')

UPDATE sx_pf_fValues    
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        ProductID = REPLACE(ProductID,' ',''),
        ValueSeriesID = REPLACE(ValueSeriesID,' ','')

UPDATE sx_pf_fStatements
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        ProductID = REPLACE(ProductID,' ','')

UPDATE sx_pf_gCluster   
    SET PropertyID = REPLACE(PropertyID,' ',''),
        FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_gFactories 
    SET PropertyID = REPLACE(PropertyID,' ',''),
        FactoryID = REPLACE(FactoryID,' ',''),
        FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_gProductLines  
    SET PropertyID = REPLACE(PropertyID,' ',''),
        FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_gProducts
    SET PropertyID = REPLACE(PropertyID,' ',''),
        FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        ProductID = REPLACE(ProductID,' ',''),
        FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_gValueEffects
    SET EffectID = REPLACE(EffectID,' ','')

UPDATE sx_pf_hFormats 
    SET FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_hLists 
    SET ListID = REPLACE(ListID,' ',''),
        FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_hListValues
    SET ListID = REPLACE(ListID,' ',''),
        FormatID = REPLACE(FormatID,' ','')

UPDATE sx_pf_rPreferences
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ','')

UPDATE sx_pf_rRights 
    SET FactoryID = REPLACE(FactoryID,' ',''),
        ProductLineID = REPLACE(ProductLineID,' ',''),
        ProductID = REPLACE(ProductID,' ','')

UPDATE sx_pf_hListValues
    SET ValueText = REPLACE(ValueText,' ','')
    WHERE ListID = 'sxValueFormats'   

	GO

/*
Creates Database Roles for PlanningFactory
PlanningFactory 4.0
07/2016
*/

IF DATABASE_PRINCIPAL_ID('pf_PlanningFactoryUser') IS NULL CREATE ROLE pf_PlanningFactoryUser
GO
IF DATABASE_PRINCIPAL_ID('pf_PlanningFactoryService') IS NULL CREATE ROLE pf_PlanningFactoryService
GO
IF DATABASE_PRINCIPAL_ID('pf_PlanningFactoryAnalyst') IS NULL CREATE ROLE pf_PlanningFactoryAnalyst
GO

-- Function to split a String into a TableVariable

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_PivotStringIntoTable]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[sx_pf_PivotStringIntoTable]
GO

CREATE FUNCTION dbo.sx_pf_PivotStringIntoTable
(@String NVARCHAR(MAX),
@Delimiter NVARCHAR(5))

RETURNS @tblSplitValues TABLE (txtValues NVARCHAR(MAX))

AS
BEGIN

	DECLARE @auxString NVARCHAR(MAX)
	SET @auxString = REPLACE(@String, @Delimiter,'|');

	WITH Split(stpos,endpos)
	AS(
		SELECT 0 AS stpos, CHARINDEX('|',@auxString) AS endpos
		UNION ALL
		SELECT CAST(endpos AS INT)+1, CHARINDEX('|',@auxString,endpos+1)
		FROM Split
		WHERE endpos > 0
	)

	INSERT @tblSplitValues
		SELECT SUBSTRING(@auxString,stpos,COALESCE(NULLIF(endpos,0),LEN(@auxString)+1)-stpos)
		FROM Split OPTION (MAXRECURSION 32766) -- it works ONLY up to 32.766 rows

	RETURN

END

GO

/* 
function to mask strings, which will be part of an SQL Statement @StringValue 
returns a masked string
Gerd Tautenhahn for saxess-software gmbh
12/2016 for DataFactory 4.0

Testcall
DECLARE @String NVARCHAR(255)
SET @String = 'ToDo''s'
Print @String
SELECT dbo.sx_pf_pMaskSQL(@String)
*/



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pMaskSQL]') AND type in (N'FN'))
DROP FUNCTION sx_pf_pMaskSQL
GO


CREATE FUNCTION sx_pf_pMaskSQL (@StringValue AS NVARCHAR(MAX))
RETURNS NVARCHAR (MAX)

AS
BEGIN

	RETURN	REPLACE(@StringValue,'''','''''')
END

GO
-- Funktion gibt zurück einen '0', wenn der übergebene @BooleanValue ist nicht etweder '0' oder '1'
-- @BooleanValue ='<#NV>' wird ignoriert und nicht geändert

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pProtectBoolean]') AND type in (N'FN'))
DROP FUNCTION sx_pf_pProtectBoolean
GO


CREATE FUNCTION sx_pf_pProtectBoolean (@BooleanValue AS NVARCHAR(255))
RETURNS NVARCHAR (255)

AS
BEGIN
	
	IF @BooleanValue <>'<#NV>' 
	
	BEGIN
		IF @BooleanValue <>'0' AND @BooleanValue <>'1'
		SET @BooleanValue= '0'
	END

	RETURN @BooleanValue

END

GO

-- Function to replace all special signs from ID
-- An ID may contain Letters, Numbers,'_' and '-', but nothing else
-- Function returns a clean string

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pProtectID]') AND type in (N'FN'))
DROP FUNCTION sx_pf_pProtectID
GO


CREATE FUNCTION sx_pf_pProtectID (@ElementID AS NVARCHAR(255))
RETURNS NVARCHAR (255)

AS
BEGIN
	SET @ElementID = RTRIM(LTRIM(@ElementID))
	RETURN	REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
			REPLACE(@ElementID,'|',''),
							   ';',''),'''',''),'/',''),'\',''),'"',''),',',''),
							   '>',''),'<',''),'[',''),']',''),'(',''),')',''),'{',''),'}',''),'!',''),'$',''),'&',''),'^',''),'@',''),
							   '%',''),':',''),'`',''),'´',''),'?',''),'§',''),'#',''),'*',''),'~',''),'+',''),'=',''),'.',''),'€',''),' ','')
END

GO

-- Funktion gibt zurück einen '0', wenn in der übergebene IntValue gibt's kein nummerische Zeichen 
-- und gibt zurück einen numerischen Ausdruck, wenn IntValue hat numerische Zeichen.
-- IntValue ='<#NV>' wird ignoriert und nicht geändert

-- Z.B. @IntValue = 'Ohne numerrische Zeichen' oder '' -> '0'
--      @IntValue = 'One 1  oder 6 meh7777ere (i9we) numerische Zeichen' -> '1677779'

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pProtectInt]') AND type in (N'FN'))
DROP FUNCTION sx_pf_pProtectInt
GO


CREATE FUNCTION sx_pf_pProtectInt (@IntValue AS NVARCHAR(255))
RETURNS NVARCHAR (255)

AS
BEGIN
	
	IF @IntValue <>'<#NV>' 
	
	BEGIN
		WHILE PATINDEX('%[^0-9]%',@IntValue)>0
		SET @IntValue=STUFF(@IntValue,PATINDEX('%[^0-9]%',@IntValue),1,'')
	END
	
	IF @IntValue ='' 
	SET @IntValue= '0'

	RETURN @IntValue

END

GO

-- Funktion entfern alle nicht erlaubte Sonderzeichen ( Hochommata,'|','),(', ';' ) aus @StringValue 
-- Die Funktion gibt zurück einen string, ohne nicht erlaubte Sonderzeichen

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pProtectString]') AND type in (N'FN'))
DROP FUNCTION sx_pf_pProtectString
GO


CREATE FUNCTION sx_pf_pProtectString (@StringValue AS NVARCHAR(MAX))
RETURNS NVARCHAR (MAX)

AS
BEGIN

	RETURN	REPLACE(REPLACE(REPLACE(@StringValue,'|',''), '),(',''), '--','')
END

GO

-- Function removes all not allowed Characters from @StringValue 
-- PlanningFactory 4.0
-- 04/2016

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pProtectValueArray]') AND type in (N'FN'))
DROP FUNCTION sx_pf_pProtectValueArray
GO


CREATE FUNCTION sx_pf_pProtectValueArray (@StringValue AS NVARCHAR(MAX))
RETURNS NVARCHAR (MAX)

AS
BEGIN

	RETURN	REPLACE(@StringValue, '--','')
END

GO


-- TextCall

-- PRINT dbo.sx_pf_pProtectValueArray ('Hase ''--')

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[Day_of_Week_DE]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [Day_of_Week_DE]
GO

CREATE FUNCTION dbo.Day_of_Week_DE (@d DATETIME)
RETURNS INT
  BEGIN
      DECLARE @t INT

      SET @t = Datepart(weekday, @d) + @@DATEFIRST - 1

      IF @t > 7
        SET @t = @t - 7

      RETURN @t
  END

GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[Week_of_Year_DE]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [Week_of_Year_DE]
GO

CREATE FUNCTION dbo.Week_of_Year_DE (@d DATETIME)
returns INT
  BEGIN
      DECLARE @k INT
      DECLARE @x DATETIME

      SET @x = Str(Year(@d)) + '-01-01'
      SET @k = Datepart(week, @d)

      IF dbo.Day_of_Week_DE(@x) > 4
        BEGIN
            SET @k = @k - 1

            IF @k = 0
              SET @k = 53
        END

      RETURN @k
  END 
GO
/*
GET Operation for all ListValues a product needs for data entry in ProductDataTable
- contains the GUI defined lists of the products (defined by user c* or solution su*)
- contains the dynamic system lists (sx* - which are editable by the user)
- adds interal system lists (sx* - which are not visible on GUI)

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return values according to HTTP standard

--Test call
DECLARE @RESULT AS NVARCHAR(255)

--Must return Table and Code 200
EXEC @RESULT = sx_pf_GET_AllProductListValues 'SQL', 'ZT','U','1'
PRINT @RESULT

--Must return Code 403
EXEC @RESULT = sx_pf_GET_AllProductListValues 'SQL3', 'ZT','ZT','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_AllProductListValues]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_AllProductListValues];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_AllProductListValues]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'  
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;
		IF @ResultCode <> 200	
		BEGIN
			SET @ResultCode = 401;
			RAISERROR('Invalid rights', 16, 10);
		END;
	
		
		-- Helper Table with all list values
		;WITH list AS (
			SELECT 
				hL.ListID
				,hL.Datentyp 
				,CAST(ISNULL(hLV.ValueInt, 0) AS INT) AS ValueInt -- must return int !
                ,CAST(ISNULL(hLV.Scale, 0) AS INT) AS Scale -- must return int !
				,ISNULL(hLV.ValueText, N'') AS ValueText
				,ISNULL(hLV.ValueComment, N'') AS ValueComment
				,ISNULL(hLV.FormatID, N'') AS FormatID
				,ISNULL(hF.BackgroundColor, N'') AS BackgroundColor
				,ISNULL(hF.FontColor, N'') AS FontColor
				,ISNULL(hF.ValueFormat, N'') AS ValueFormat
			FROM [dbo].[sx_pf_hLists] hL 
				LEFT JOIN [dbo].[sx_pf_hListValues] hLV	ON hL.ListID = hLV.ListID
				-- for the value
				LEFT JOIN [dbo].[sx_pf_hFormats] hF	ON hLV.FormatID = hF.FormatID
				-- filter the lists, which where till 4.0.57 GUI defined and are now internal system lists
			WHERE hL.ListID NOT IN ('sxIsNumeric','sxVisibilityLevel','sxValueLists','sxValueSources','sxValueFormats','sxScales','sxValueEffects')
		)
		-- STEP 3.1 Dynamic System Lists
		SELECT *
		FROM list
		WHERE ListID IN ('sxUnits','sxValueEffectParameters')	
		
		UNION ALL
		-- STEP 3.2 Product specific ListSet based on defined ValueLists
		SELECT *
		FROM list
		WHERE ListID IN (
			SELECT DISTINCT ValueListID
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE ProductKey = @ProductKey)

		-- add internal system lists ----------------------------------------------------------
		UNION ALL 
		--sxIsNumeric - static  TODO: Change Datatyp to Integer with next API
		SELECT * FROM 
				(
				VALUES	
					 ('sxIsNumeric','String',0,1,'0','','','','','')
					,('sxIsNumeric','String',1,1,'1','','','','','')
				) tmp (ListID,Datentyp,ValueInt,Scale,ValueText,ValueComment,FormatID,BackgroundColor,FontColor,ValueFormat)
		
		UNION ALL	
		--sxVisibilityLevel - static TODO: Change Datatyp to Integer with next API
		SELECT * FROM 
				(
				VALUES	
					 ('sxVisibilityLevel','String',0,1,'0','','','','','')
					,('sxVisibilityLevel','String',1,1,'1','','','','','')
				) tmp (ListID,Datentyp,ValueInt,Scale,ValueText,ValueComment,FormatID,BackgroundColor,FontColor,ValueFormat)
		UNION ALL			
		--sxValueLists - dynamic List of GUI Lists
		SELECT 
				 'sxValueLists'
				,'String'
				,0 AS ValueInt 
                ,1 AS Scale 
				,hL.ListID AS ValueText
				,'' AS ValueComment
				,'' AS FormatID
				,'' AS BackgroundColor
				,'' AS FontColor
				,'' AS ValueFormat
			FROM [dbo].[sx_pf_hLists] hL 
			-- Filter the GUI Lists, which are not useful as ValueList
			WHERE hL.ListID NOT IN ('sxValueEffectParameter')

		UNION ALL
		--sxValueSources - static (english strings for all languages
		SELECT * FROM 
				(
				VALUES	
					 ('sxValueSources','String',0,1,'Input','','','','','')
					,('sxValueSources','String',0,1,'XLS','','','','','')
					,('sxValueSources','String',0,1,'XLS-Strict','','','','','')
					,('sxValueSources','String',0,1,'Link','','','','','')
				) tmp (ListID,Datentyp,ValueInt,Scale,ValueText,ValueComment,FormatID,BackgroundColor,FontColor,ValueFormat)
		
		UNION ALL
		--sxValueFormats - dynamic, list of defined formats
		SELECT 
			 'sxValueFormats'
			,'String'
			,0 AS ValueInt 
            ,1 AS Scale 
			,sphf.FormatID AS ValueText
			,'' AS ValueComment
			,sphf.FormatID AS FormatID
			,sphf.BackgroundColor AS BackgroundColor
			,sphf.FontColor AS FontColor
			,sphf.ValueFormat AS ValueFormat
		FROM [dbo].[sx_pf_hFormats] [sphf] 
		
		UNION ALL
		--sxScales - static - this List is also static defined in GET_ListValues
		SELECT * FROM 
				(
				VALUES	
					 ('sxScales','Integer',1,1,'','','','','','')
					,('sxScales','Integer',10,1,'','','','','','')
					,('sxScales','Integer',100,1,'','','','','','')
					,('sxScales','Integer',1000,1,'','','','','','')
					,('sxScales','Integer',10000,1,'','','','','','')
				) tmp (ListID,Datentyp,ValueInt,Scale,ValueText,ValueComment,FormatID,BackgroundColor,FontColor,ValueFormat)
		
		UNION ALL
		--sxValueEffects -dynamic, list of defined ValueEffects in gValueEffects
		SELECT 
			 'sxValueEffects' AS ListID
			,'String'
			,0 AS ValueInt 
            ,1 AS Scale 
			,spgve.EffectID AS ValueText
			,'' AS ValueComment
			,'' AS FormatID
			,'' AS BackgroundColor
			,'' AS FontColor
			,'' AS ValueFormat
		FROM [dbo].[sx_pf_gValueEffects] [spgve]



		ORDER BY ListID, ValueText, ValueInt;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_AllProductListValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_AllProductListValues] TO pf_PlanningFactoryService;
GO

/*
GET operation for User status check on cluster
If User status is 'Active' then return 200

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername:
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return values according to HTTP standard

Test call

DECLARE @RESULT AS NVARCHAR(255)

-- Should Return 200
EXEC @RESULT = sx_pf_GET_ClusterAccessRight 'SQL'
PRINT @RESULT

-- Should Return 401
EXEC @RESULT = sx_pf_GET_ClusterAccessRight 'SQL4'
PRINT @RESULT

-- 1. If you pass 'SQL' -> checks the User which is just logged into SQL Connection
-- 2. If you pass another username than 'SQL' to get the results for this user, you get only the result if yourself are logged in as sql user with clusteradmin rights
-- (1. is the typical way for a sql connected user, 2. is the typical way if the webservice is logged in an ask for any user)
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ClusterAccessRight]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ClusterAccessRight];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ClusterAccessRight] 
	@Username AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @Right AS NVARCHAR (255);
	DECLARE @TransactUsername AS NVARCHAR (255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution
	DECLARE @Logmessage AS NVARCHAR(255) = N'';

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);
	
		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			SET @Logmessage = 'Transaction user don`t exists, check was done for Username: ' + @Username + ' with Orginal_Login(): ' + ORIGINAL_LOGIN();
			RAISERROR(@Logmessage, 16, 10);
		END;
		
		-- STEP 3 - Test whether the user is Active on this cluster
		SELECT @ResultCode = IIF([Status] = N'Active', 200, 401) FROM [dbo].[sx_pf_rUser] WHERE Username = @TransactUsername;

		IF @ResultCode <> 200 
			BEGIN
				SET @Logmessage = 'User is not active, check was done for Username: ' + @Username + ' with Orginal_Login(): ' + ORIGINAL_LOGIN();
				RAISERROR(@Logmessage, 16, 10);
			END

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;		
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterAccessRight] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterAccessRight] TO pf_PlanningFactoryService;
GO
/*
GET Operation for Cluster Properties

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
ReturnValues according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)

--should return 200
EXEC @RESULT = sx_pf_GET_ClusterProperties 'SQL'
PRINT @RESULT

--should return 401
EXEC @RESULT = sx_pf_GET_ClusterProperties 'SQL4'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ClusterProperties]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_GET_ClusterProperties]
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ClusterProperties]
	@Username AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;
	SET ANSI_WARNINGS OFF;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @Right AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

			IF @ResultCode = 200
			BEGIN
				SET @Right = 'Write';
			END ELSE BEGIN 
				SET @Right = 'Read';
				SET @ResultCode = 200;
			END;
		END;
	
		SET NOCOUNT OFF;
		SET ANSI_WARNINGS ON;	
		
		-- STEP 3. Show public values
		SELECT  
			PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gCluster]
		ORDER BY COALESCE(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;
		
		SET @EffectedRows = @@ROWCOUNT;

		SET NOCOUNT ON;
		SET ANSI_WARNINGS OFF;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterProperties] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterProperties] TO pf_PlanningFactoryService;
GO
/*
GET Operation for determining a cluster Property

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
ReturnValues according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ClusterProperty 'SQL','C01'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ClusterProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ClusterProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ClusterProperty]
	@Username AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') +N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);

		IF @PropertyID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gCluster] WHERE PropertyID = @PropertyID;

		IF @PropertyKey = 0 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3. Show public values
		SELECT  
			PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
		FROM [dbo].[sx_pf_gCluster]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterProperty] TO pf_PlanningFactoryService;
GO
/*
Operation to check Cluster
Running tests:
    Lists, which are never used
    ListMembers, which are never used
    Lists which are used but dont exists
    List members which are Used but dont exist
    Formats which are used but dont exist
    Formats which are defined but not used
    count ValueSeries per Product
    count ValuesPer Product
User must be active to run tests

Dependencies:
 - Functions:
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

01/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return values according to HTTP standard

Test call
							   
DECLARE @RESULT AS NVARCHAR(255)

EXEC @RESULT = [dbo].[sx_pf_GET_ClusterValidation] 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ClusterValidation]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ClusterValidation];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ClusterValidation]
	@Username AS NVARCHAR(255) 
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @Right AS NVARCHAR (255);
	DECLARE @TransactUsername AS NVARCHAR (255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
			  
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);
	
		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Test whether the user is Active on this cluster
		SELECT @ResultCode = IIF([Status] = N'Active', 200, 401) FROM [dbo].[sx_pf_rUser] WHERE Username = @TransactUsername;

		IF @ResultCode <> 200 
			RAISERROR('User is not active', 16, 10);
		
		-- STEP 3 - Run tests
		DECLARE @Tests AS TABLE (N INT IDENTITY(1,1), Name NVARCHAR(200), [Status] NVARCHAR(10), Result NVARCHAR(MAX), RowsCount BIGINT);

-- Lists, which are never used			
		;WITH lst AS (
			SELECT l.[ListID]
				, l.[ListKey]
				, l.[NameShort] AS ListName
			FROM [dbo].[sx_pf_hLists] l 
				LEFT JOIN (SELECT * FROM [dbo].[sx_pf_dValueSeries] WHERE [ValueListID] <> N'') vs ON l.[ListID] = vs.[ValueListID]
			WHERE vs.[ValueSeriesKey] IS NULL
		)
		INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		SELECT N'Unused Lists', N'Info', N'List #' + CONVERT(NVARCHAR(MAX), [ListKey]) + N', ' + [ListID] + N' ''' + ListName + N'''', 1
		FROM lst;

		SET @EffectedRows += @@ROWCOUNT;

-- Lists which are used but dont exists	
		;WITH lst AS (
			SELECT vs.[ValueListID]	AS ListID
				, vs.[NameShort] AS VSName
				, vs.[ValueSeriesKey] AS VSKey
				, vs.[ValueSeriesID] AS VSID
			FROM (SELECT * FROM [dbo].[sx_pf_dValueSeries] WHERE [ValueListID] <> N'') vs
				LEFT JOIN [dbo].[sx_pf_hLists]  l ON l.[ListID] = vs.[ValueListID]
			WHERE l.[ListID] IS NULL
		)
		INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		SELECT N'Don`t exists Lists', N'Error', N'ListID ' + ListID + N' (ValueSerie #' + CONVERT(NVARCHAR(MAX), VSKey) + N', ' + VSID + N' ''' + VSName + N''')', 1
		FROM lst;
		
		SET @EffectedRows += @@ROWCOUNT;			  

-- ListMembers, which are never used		
		;WITH mmbr AS (
			SELECT DISTINCT N'Value #' + CONVERT(NVARCHAR(MAX), lv.[ListValueKey]) + N' ''' 
				+ CASE WHEN l.[Datentyp] = N'Integer' THEN CONVERT(NVARCHAR(MAX), lv.[ValueInt]) ELSE lv.[ValueText] END 
				+ N''' (List #' + CONVERT(NVARCHAR(MAX), l.[ListKey]) + N', ' + lv.[ListID] + N' ''' + l.[NameShort] + N''')' AS Result
			FROM [dbo].[sx_pf_hListValues] lv 
				LEFT JOIN [dbo].[sx_pf_hLists] l ON lv.[ListID] = l.[ListID]							
				LEFT JOIN [dbo].[sx_pf_dValueSeries] vs ON l.[ListID] = vs.[ValueListID] AND ((vs.[IsNumeric] = 1 AND l.[Datentyp] = N'Integer') OR (vs.[IsNumeric] = 0 AND l.[Datentyp] = N'String'))
				LEFT JOIN [dbo].[sx_pf_fValues] v ON vs.[ValueSeriesKey] = v.[ValueSeriesKey]
					AND ((vs.[IsNumeric] = 1 AND v.[ValueInt] = lv.[ValueInt])
						OR (vs.[IsNumeric] = 0 AND v.[ValueText] = lv.[ValueText]))
			WHERE v.[ValueKey] IS NULL
		 )
		 INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		 SELECT N'Unused List Values', N'Info', Result, 1
		 FROM mmbr;

		 SET @EffectedRows += @@ROWCOUNT;

--  List members which are Used but dont exist
		;WITH mmbr AS (
			SELECT DISTINCT N'Value #' + CONVERT(NVARCHAR(MAX), v.ValueKey) + N' ''' + CASE WHEN vs.[IsNumeric] = 1 THEN CONVERT(NVARCHAR(MAX), v.[ValueInt]) ELSE v.[ValueText] END
				+ N''' ListID ' + vs.[ValueListID] 
				+ N' (ValueSerie #' + CONVERT(NVARCHAR(MAX), v.[ValueSeriesKey]) + N', ' + vs.[ValueSeriesID]
				+ N' ''' + vs.[NameShort] + N''')' AS Result
			FROM [dbo].[sx_pf_fValues] v
				INNER JOIN [dbo].[sx_pf_dValueSeries] vs ON vs.[ValueListID] <> N'' AND vs.[ValueSeriesKey] = v.[ValueSeriesKey]
				LEFT JOIN [dbo].[sx_pf_hLists] l ON vs.[ValueListID] = l.[ListID] AND ((vs.[IsNumeric] = 1 AND l.[Datentyp] = N'Integer') OR (vs.[IsNumeric] = 0 AND l.[Datentyp] = N'String'))
				LEFT JOIN [dbo].[sx_pf_hListValues] lv ON lv.[ListID] = l.[ListID]
					AND ((vs.[IsNumeric] = 1 AND v.[ValueInt] = lv.[ValueInt])
						OR (vs.[IsNumeric] = 0 AND v.[ValueText] = lv.[ValueText]))
			WHERE lv.[ListValueKey] IS NULL
		)
		INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		SELECT N'Don`t exists List Values', N'Error', Result, 1
		FROM mmbr;

		SET @EffectedRows += @@ROWCOUNT;

		;WITH frm AS (									 
			SELECT ValueFormatID AS FormatID , N'FormatID ' + ValueFormatID + N' (ValueSerie #' + CONVERT(NVARCHAR(MAX), ValueSeriesKey) + N', ' + ValueSeriesID + N' ''' + NameShort + N''')' AS Result			 
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE ValueFormatID <> N''
			UNION ALL												   
			SELECT [FormatID] , N'FormatID ' + [FormatID] + N' (Cluster Property #' + CONVERT(NVARCHAR(MAX), [PropertyKey]) + N', ' + [PropertyID] + N' ''' + [PropertyName] + N''')' AS Result
			FROM [dbo].[sx_pf_gCluster]
			WHERE [FormatID] <> N'' 								  
			UNION ALL
			SELECT [FormatID] , N'FormatID ' + [FormatID] + N' (Factory Property #' + CONVERT(NVARCHAR(MAX), [PropertyKey]) + N', ' + [PropertyID] + N' ''' + [PropertyName] + N''')' AS Result								   
			FROM [dbo].[sx_pf_gFactories]
			WHERE [FormatID] <> N'' 
			UNION ALL
			SELECT [FormatID] , N'FormatID ' + [FormatID] + N' (ProductLine Property #' + CONVERT(NVARCHAR(MAX), [PropertyKey]) + N', ' + [PropertyID] + N' ''' + [PropertyName] + N''')' AS Result							  		
			FROM [dbo].[sx_pf_gProductLines]
			WHERE [FormatID] <> N'' 
			UNION ALL
			SELECT [FormatID] , N'FormatID ' + [FormatID] + N' (Product Property #' + CONVERT(NVARCHAR(MAX), [PropertyKey]) + N', ' + [PropertyID] + N' ''' + [PropertyName] + N''')' AS Result
			FROM [dbo].[sx_pf_gProducts]
			WHERE [FormatID] <> N'' 
			UNION ALL										 
			SELECT [FormatID] , N'FormatID ' + [FormatID] + N' (List #' + CONVERT(NVARCHAR(MAX), ListKey) + N', ' + ListID + N' ''' + NameShort + N''')' AS Result
			FROM [dbo].[sx_pf_hLists]
			WHERE [FormatID] <> N'' 
			UNION ALL
			SELECT [FormatID] , N'FormatID ' + [FormatID] + N' (ListValue #' + CONVERT(NVARCHAR(MAX), [ListValueKey]) + N', ListID ' + [ListID] + N')' AS Result
			FROM [dbo].[sx_pf_hListValues]
			WHERE [FormatID] <> N'' 
		)
	-- Formats which are used but don`t exist
		, unusedFrmts AS (
			SELECT N'Format #' + CONVERT(NVARCHAR(MAX), [FormatKey]) + N', ' + [FormatID] AS Result												
			FROM [dbo].[sx_pf_hFormats]
			WHERE [FormatID] NOT IN (SELECT DISTINCT [FormatID] FROM frm)
		)
	-- Formats which are defined but not used	
		, notExistsFrmts AS (
			SELECT Result 
			FROM frm LEFT JOIN [dbo].[sx_pf_hFormats] f ON frm.FormatID	= f.FormatID
			WHERE f.FormatID IS NULL
		)
		INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		SELECT N'Unused Formats', N'Info', Result, 1
		FROM unusedFrmts
		UNION ALL
		SELECT N'Don`t exists Formats', N'Error', Result, 1
		FROM notExistsFrmts;

		SET @EffectedRows += @@ROWCOUNT;

--    count ValueSeries per Product		
		INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		SELECT N'ValueSeries per Product', N'Info', N'Product #' + CONVERT(NVARCHAR(MAX), p.[ProductKey]) + N', ' + p.[ProductID] + N' ''' + p.[NameShort] + N'''', COUNT(*)
		FROM [dbo].[sx_pf_dValueSeries]	vs INNER JOIN [dbo].[sx_pf_dProducts] p ON vs.ProductKey = p.ProductKey					
		GROUP BY p.[ProductKey], p.[ProductID], p.[NameShort];

		SET @EffectedRows += @@ROWCOUNT;

--    count ValuesPer Product		
		INSERT INTO @Tests(Name, [Status], Result, RowsCount)
		SELECT N'Values per Product', N'Info', N'Product #' + CONVERT(NVARCHAR(MAX), p.[ProductKey]) + N', ' + p.[ProductID] + N' ''' + p.[NameShort] + N'''', COUNT(*)
		FROM [dbo].[sx_pf_fValues] v INNER JOIN [dbo].[sx_pf_dProducts] p ON v.ProductKey = p.ProductKey					
		GROUP BY p.[ProductKey], p.[ProductID], p.[NameShort];								   	   
		
		SET @EffectedRows += @@ROWCOUNT;

		SELECT * 
		FROM @Tests
		ORDER BY N;

		COMMIT TRANSACTION ONE;		
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterValidation] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterValidation] TO pf_PlanningFactoryService;
GO
/*
GET Operation for Write Rights on a Cluster
Returns 200 if User has ClusterWriteRights

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Values according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ClusterWriteRight 'W8\admin'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ClusterWriteRight]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ClusterWriteRight];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ClusterWriteRight] 
	@Username AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
				
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 3 - Test that user has write access to the cluster
		SELECT @ResultCode = IIF([Right] = N'Write', 200, 401) FROM [dbo].[sx_pf_vUserRights] WHERE FactoryID = N'' AND Username = @TransactUsername;

		IF @ResultCode <> 200 
			RAISERROR('User have no write access to the cluster', 16, 10);

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;		
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;

END
GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterWriteRight] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ClusterWriteRight] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all eligible Factories
Returns the list of all the factories, for which the user has rights

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)

--should return Data and 200
EXEC @RESULT = sx_pf_GET_Factories 'SQL'
PRINT @RESULT

--should return NO Data and 401
EXEC @RESULT = sx_pf_GET_Factories 'SQL14'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Factories]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Factories];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Factories]
	@Username AS NVARCHAR(255)
AS 

BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.1 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 3. Show public values	
		;WITH rights AS (
			SELECT 
				FactoryID,  
				[Right],
				ISNULL(TRY_CAST(FactoryID AS INT), 999999999) as orderID 
			FROM [dbo].[sx_pf_vUserRights]
			WHERE ProductLineID = N'' 
			AND Username = @TransactUsername
			AND [Right] IN (N'Read', N'Write')
		)
		SELECT   
			dF.FactoryID
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ResponsiblePerson
			,ImageName
			,vUR.[Right]
		FROM [dbo].[sx_pf_dFactories] dF 
			INNER JOIN rights vUR ON dF.FactoryID = vUR.FactoryID	
		ORDER BY vUR.orderID, dF.FactoryID;

		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = 200;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Factories] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Factories] TO pf_PlanningFactoryService;
GO
/*
GET Operation for one Factory
Delivers all informations about one factory

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

-- test call
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Factory 'SQL','ZT'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Factory]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Factory];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Factory]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
			
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT  
			FactoryID
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ResponsiblePerson
			,ImageName
			,@Right AS [Right]
		FROM [dbo].[sx_pf_dFactories]
		WHERE FactoryKey = @FactoryKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Factory] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Factory] TO pf_PlanningFactoryService;
GO
/*
GET Operation for getting the HTML Pages, useable with this Factory
For each HTML must exist a stored procedure, which delivers its content.

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FactoryHTMLs 'SQL','ZT'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FactoryHTMLs]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FactoryHTMLs];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_FactoryHTMLs]
		@Username AS NVARCHAR(255),
		@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N''		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;

		-- STEP 3. Show values of type HTML_*
		SELECT  
			 FactoryID
			,PropertyID   AS HTMLID
			,PropertyName AS HTMLProcedureName -- this Procedure must return just a HTML formated NVARCHAR(MAX)
			,CommentUser  AS TabName
			--,CommentDev   --
			--,Unit		--
			,'' AS HTMLContent 
			,1 AS ValueInt
			-- ,Scale
			-- ,IsROSystemProperty 
			-- ,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gFactories]
		WHERE FactoryKey = @FactoryKey AND PropertyID like 'HTML_%'
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryHTMLs] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryHTMLs] TO pf_PlanningFactoryService;
/*
GET Operation for determining the Pivot Views, useable with this Factory

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

10/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FactoryPivots 'SQL','ZT'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FactoryPivots]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FactoryPivots];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_FactoryPivots]
		@Username AS NVARCHAR(255),
		@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N''		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show values of type Pivot_*
		SELECT  
			 FactoryID
			,PropertyID   AS PivotID
			,PropertyName AS PivotProcedureName
			,CommentUser  AS PivotName
			--,CommentDev   --
			--,Unit		--
			,ValueText  AS Layout
			,CAST(ValueInt AS NVARCHAR)	AS ChartType -- due to the fact, that POST can bring <#NV> and they should harmonize
			-- ,Scale
			-- ,IsROSystemProperty 
			-- ,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gFactories]
		WHERE FactoryKey = @FactoryKey AND PropertyID like 'Pivot_%'
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryPivots] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryPivots] TO pf_PlanningFactoryService;
/*
GET Operation for determining a Factory Properties

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FactoryProperties 'SQL','D'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FactoryProperties]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FactoryProperties];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_FactoryProperties]
		@Username AS NVARCHAR(255),
		@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N''		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT  
			FactoryID
			,PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gFactories]
		WHERE FactoryKey = @FactoryKey
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryProperties] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryProperties] TO pf_PlanningFactoryService;
GO
/*
GET Operation for determining a Factory Property

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FactoryProperty 'SQL','D','F01'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FactoryProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FactoryProperty];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_FactoryProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL')+ N''',''' + ISNULL(@PropertyID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);	

		IF @FactoryID = N'' OR  @PropertyID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @PropertyID;

		IF @FactoryKey = 0 OR @PropertyKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT  
			FactoryID
			,PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gFactories]
		WHERE PropertyKey = @PropertyKey; 

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryProperty] TO pf_PlanningFactoryService;
GO
/*
GET Operation for determining the URLs, useable with this Factory

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FactoryURLs 'SQL','ZT'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FactoryURLs]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FactoryURLs];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_FactoryURLs]
		@Username AS NVARCHAR(255),
		@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N''		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show values of type Pivot_*
		SELECT  
			 FactoryID
			,PropertyID   AS URLID
			-- ,PropertyName
			,ValueText AS URL
			,CommentUser  AS TabName
			--,CommentDev  
			--,Unit		
			,1 	AS ValueInt
			-- ,Scale
			-- ,IsROSystemProperty 
			-- ,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gFactories]
		WHERE FactoryKey = @FactoryKey AND PropertyID like 'URL_%'
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryURLs] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryURLs] TO pf_PlanningFactoryService;
/*
GET Operation for determining the Websites, useable with this Factory

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry
04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

THIS PROCEDURE IS DEPRECIATED, WILL BE REPLACED BY GET_FACTORY_URL, GET_FACTORY_HTML

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FactoryWebsites 'SQL','ZT'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FactoryWebsites]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FactoryWebsites];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_FactoryWebsites]
		@Username AS NVARCHAR(255),
		@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N''		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		

		-- STEP 3. Show values of type Websites_*
		-- Mock
		SELECT TOP 1
			 FactoryID
			,'Website_1'   AS WebsiteID
			,'https://saxess-software.github.io/SX-DataFactory-Portal/' AS WebsiteURL
			,'DataFactory'  AS WebsiteName
			--,CommentDev   --
			--,Unit		--
			,''  AS Layout
			,0	AS ChartType -- due to the fact, that POST can bring <#NV> and they should harmonize
			-- ,Scale
			-- ,IsROSystemProperty 
			-- ,FormatID
			,'Write' AS [Right]
		FROM dbo.sx_pf_dFactories WHERE FactoryKey = @FactoryKey


		/*
		SELECT  
			 FactoryID
			,PropertyID   AS PivotID
			,PropertyName AS PivotProcedureName
			,CommentUser  AS PivotName
			--,CommentDev   --
			--,Unit		--
			,ValueText  AS Layout
			,CAST(ValueInt AS NVARCHAR)	AS ChartType -- due to the fact, that POST can bring <#NV> and they should harmonize
			-- ,Scale
			-- ,IsROSystemProperty 
			-- ,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gFactories]
		WHERE FactoryKey = @FactoryKey AND PropertyID like 'Website_%'
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;
		*/
		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryWebsites] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FactoryWebsites] TO pf_PlanningFactoryService;
/*
GET Operation for receiving a filterd context sensitiv List with dynamic column count
The first column is sended back with POST_FlexAction as idenitfier for a database action

Procedure must be editend to fit user needs and recreated after each API Update.


Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
--should return Data and 200
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_FlexAction 'SQL','F1','PL1','P1','Projekt','','','ei'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_FlexAction]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_FlexAction];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_FlexAction]
	 @Username AS NVARCHAR(255)
	,@FactoryID AS NVARCHAR(255)
	,@ProductLineID AS NVARCHAR(255)
	,@ProductID AS NVARCHAR(255)
	,@ValueSeriesID AS NVARCHAR(255)
	,@GlobalattributeNumber AS NVARCHAR(255)
	,@PageType AS NVARCHAR(255)    -- PDT (ProductDataTable), PLP (ProductLinePage)
	,@SearchString AS NVARCHAR(255)  --any Substring from searched list values
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL')
		 + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSeriesID, N'NULL') + N''',''' + ISNULL(@GlobalattributeNumber, N'NULL')  
		+ N''',''' + ISNULL(@PageType, N'NULL') + N''',''' +  ISNULL(@SearchString, N'NULL') + N'''';  

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductlineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSeriesID IS NULL SET @ValueSeriesID = N'';
	IF @GlobalattributeNumber IS NULL SET @GlobalattributeNumber = '';
	IF @PageType IS NULL SET @PageType = N'';

	SET @SearchString = '%' + ISNULL(@SearchString, '') + '%';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ValueSeriesID = [dbo].[sx_pf_pProtectID] (@ValueSeriesID);
				
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
	
		-- STEP 3 - this are sample data which are used as output as long there are no user specific implementations
		DECLARE @Projects AS TABLE
			(
				 ProjectID NVARCHAR (255)
				,ProjectName NVARCHAR (255)
				,ProjectManager NVARCHAR (255)
			);

		INSERT INTO @Projects
		        VALUES
				 (N'P1000',N'Testprojekt in Aachen','Pit Brown'),
				 (N'P1001',N'Testprojekt in Augsburg','Pit Brown'),
				 (N'P1002',N'Testprojekt in Bergisch Gladbach','Pit Brown'),
				 (N'P1003',N'Testprojekt in Berlin','Pit Brown'),
				 (N'P1004',N'Testprojekt in Bielefeld','Pit Brown'),
				 (N'P1005',N'Testprojekt in Bochum','Pit Brown'),
				 (N'P1006',N'Testprojekt in Bonn','Pit Brown'),
				 (N'P1007',N'Testprojekt in Bottrop','Pit Brown'),
				 (N'P1008',N'Testprojekt in Braunschweig','Pit Brown'),
				 (N'P1009',N'Testprojekt in Bremen','Pit Brown'),
				 (N'P1010',N'Testprojekt in Bremerhaven','Pit Brown'),
				 (N'P1011',N'Testprojekt in Chemnitz','Pit Brown'),
				 (N'P1012',N'Testprojekt in Darmstadt','Pit Brown'),
				 (N'P1013',N'Testprojekt in Dortmund','Pit Brown'),
				 (N'P1014',N'Testprojekt in Dresden','Pit Brown'),
				 (N'P1015',N'Testprojekt in Duisburg','Pit Brown'),
				 (N'P1016',N'Testprojekt in D�sseldorf','Pit Brown'),
				 (N'P1017',N'Testprojekt in Erfurt','Pit Brown'),
				 (N'P1018',N'Testprojekt in Erlangen','Pit Brown'),
				 (N'P1019',N'Testprojekt in Essen','Pit Brown'),
				 (N'P1020',N'Testprojekt in Frankfurt am Main','Pit Brown'),
				 (N'P1021',N'Testprojekt in Freiburg im Breisgau','Pit Brown'),
				 (N'P1022',N'Testprojekt in F�rth','Pit Brown'),
				 (N'P1023',N'Testprojekt in Gelsenkirchen','Pit Brown'),
				 (N'P1024',N'Testprojekt in G�ttingen','Pit Brown'),
				 (N'P1025',N'Testprojekt in Hagen','Pit Brown'),
				 (N'P1026',N'Testprojekt in Halle (Saale)','Pit Brown'),
				 (N'P1027',N'Testprojekt in Hamburg','Pit Brown'),
				 (N'P1028',N'Testprojekt in Hamm','Pit Brown'),
				 (N'P1029',N'Testprojekt in Hannover','Pit Brown'),
				 (N'P1030',N'Testprojekt in Heidelberg','Cathy Gold'),
				 (N'P1032',N'Testprojekt in Heilbronn','Cathy Gold'),
				 (N'P1032',N'Testprojekt in Herne','Cathy Gold'),
				 (N'P1033',N'Testprojekt in Ingolstadt','Cathy Gold'),
				 (N'P1034',N'Testprojekt in Jena','Cathy Gold'),
				 (N'P1035',N'Testprojekt in Karlsruhe','Cathy Gold'),
				 (N'P1036',N'Testprojekt in Kassel','Cathy Gold'),
				 (N'P1037',N'Testprojekt in Kiel','Cathy Gold'),
				 (N'P1038',N'Testprojekt in Koblenz','Cathy Gold'),
				 (N'P1039',N'Testprojekt in K�ln','Cathy Gold'),
				 (N'P1040',N'Testprojekt in Krefeld','Cathy Gold'),
				 (N'P1041',N'Testprojekt in Leipzig','Cathy Gold'),
				 (N'P1042',N'Testprojekt in Leverkusen','Cathy Gold'),
				 (N'P1043',N'Testprojekt in L�beck','Cathy Gold'),
				 (N'P1044',N'Testprojekt in Ludwigshafen am Rhein','Cathy Gold'),
				 (N'P1045',N'Testprojekt in Magdeburg','Cathy Gold'),
				 (N'P1046',N'Testprojekt in Mainz','Cathy Gold'),
				 (N'P1047',N'Testprojekt in Mannheim','Cathy Gold'),
				 (N'P1048',N'Testprojekt in Moers','Cathy Gold'),
				 (N'P1048',N'Testprojekt in M�nchengladbach','Cathy Gold'),
				 (N'P1049',N'Testprojekt in M�lheim an der Ruhr','Cathy Gold'),
				 (N'P1050',N'Testprojekt in M�nchen','Cathy Gold'),
				 (N'P1051',N'Testprojekt in M�nster','Cathy Gold'),
				 (N'P1052',N'Testprojekt in Neuss','Cathy Gold'),
				 (N'P1053',N'Testprojekt in N�rnberg','Cathy Gold'),
				 (N'P1054',N'Testprojekt in Oberhausen','Cathy Gold'),
				 (N'P1055',N'Testprojekt in Offenbach am Main','Cathy Gold'),
				 (N'P1056',N'Testprojekt in Oldenburg','Cathy Gold'),
				 (N'P1057',N'Testprojekt in Osnabr�ck','Cathy Gold'),
				 (N'P1058',N'Testprojekt in Paderborn','Cathy Gold'),
				 (N'P1059',N'Testprojekt in Pforzheim','Cathy Gold'),
				 (N'P1060',N'Testprojekt in Potsdam','Cathy Gold'),
				 (N'P1061',N'Testprojekt in Recklinghausen','Cathy Gold'),
				 (N'P1062',N'Testprojekt in Regensburg','Cathy Gold'),
				 (N'P1063',N'Testprojekt in Remscheid','Cathy Gold'),
				 (N'P1064',N'Testprojekt in Reutlingen','Cathy Gold'),
				 (N'P1065',N'Testprojekt in Rostock','Cathy Gold'),
				 (N'P1066',N'Testprojekt in Saarbr�cken','Cathy Gold'),
				 (N'P1067',N'Testprojekt in Siegen','Cathy Gold'),
				 (N'P1068',N'Testprojekt in Solingen','Cathy Gold'),
				 (N'P1069',N'Testprojekt in Stuttgart','Cathy Gold'),
				 (N'P1070',N'Testprojekt in Trier','Cathy Gold'),
				 (N'P1071',N'Testprojekt in Ulm','Cathy Gold'),
				 (N'P1072',N'Testprojekt in Wiesbaden','Cathy Gold'),
				 (N'P1073',N'Testprojekt in Wolfsburg','Cathy Gold'),
				 (N'P1074',N'Testprojekt in Wuppertal','Cathy Gold'),
				 (N'P1075',N'Testprojekt in W�rzburg','Cathy Gold');
		
		-- First Column must be "Hint" an commits the display hint to the frontend
		-- Second Column must have identifier character, its send back with the POST_FlexAction Command
		-- Column Names must have an Alias (AS Displayname) with one "_", after which 
			-- Orientation (L=Left, R= Right, C = Center)
			-- DataType (M=Money, S=String, I=Int) 
			-- ColumnWidth 
			-- is coded as Frontend Parameter

		-- React on content parameters when creating the return list.
		-- You could add a "*" Member to the List and react on it in POST to create a new list member

		IF @ValueSeriesID = 'Projekt'
			BEGIN
				SELECT 'Projekt wird bei Auswahl angelegt.' AS Hint
					   ,p.ProjectID AS ProjectID_RS10
					   ,p.ProjectName AS Projektname_LS60
					   ,p.ProjectManager AS Projektmanager_CS30
					   FROM @Projects p
					   WHERE p.ProjectName LIKE @SearchString
					   ORDER BY ProjectID;
			END

		IF @ValueSeriesID = 'Mitarbeiter' 
			BEGIN
				SELECT 'Mitarbeiter wird bei Auswahl angelegt.' AS Hint
					   ,p.ProjectID AS MitarbeiterID_RS10
					   ,p.ProjectManager AS Projektmanager_LS30
					   FROM @Projects p
					   WHERE p.ProjectManager LIKE @SearchString
					   ORDER BY ProjectID;
			END

		IF @ValueSeriesID NOT IN ('Projekt','Mitarbeiter')
			BEGIN
				SELECT 'FlexActions sind nur f�r die Wertreihen "Projekt" und "Mitarbeiter" definiert' AS Hint;
			END


			   
		SET @EffectedRows += @@ROWCOUNT;

		SET @ResultCode = 200;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO

-- SET Rights
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FlexAction] TO pf_PlanningFactoryUser
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_FlexAction] TO pf_PlanningFactoryService
GO
/*
GET Operation for a Format

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard


DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Format 'SQL', 'sxHintergrund Rot'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Format]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Format];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Format]
	@Username AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FormatKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FormatID = [dbo].[sx_pf_pProtectID] (@FormatID);

		IF @FormatID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine Keys
		SELECT  @FormatKey = FormatKey FROM [dbo].[sx_pf_hFormats] WHERE FormatID = @FormatID;
		
		IF @FormatKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			FormatID,
			BackgroundColor,
			FontColor,
			ValueFormat,
			@Right AS [Right]
		FROM [dbo].[sx_pf_hFormats]
		WHERE FormatKey = @FormatKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Format] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Format] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all Formats in Cluster

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Formats 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Formats]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Formats];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Formats]
	@Username AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FormatKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
	
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values		
		SELECT 
			FormatID,
			BackgroundColor,
			FontColor,
			ValueFormat,
			@Right AS [Right]
		FROM [dbo].[sx_pf_hFormats]
		ORDER BY ISNULL(TRY_CAST(FormatID AS INT), 999999999), FormatID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Formats] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Formats] TO pf_PlanningFactoryService;
GO
/*
GET Operation for cross query of ALL attributes usage

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Info_AllGlobalAttributeUsage 'SQL'
PRINT @RESULT
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Info_AllGlobalAttributeUsage]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Info_AllGlobalAttributeUsage];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Info_AllGlobalAttributeUsage]
	@Username AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;
	SET ANSI_WARNINGS OFF;

	DECLARE @TransactUsername AS NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		SET NOCOUNT OFF;
		SET ANSI_WARNINGS ON;

		-- STEP 3. Show public values	
		;WITH data AS (
			SELECT GlobalattributeAlias1, GlobalattributeAlias2, GlobalAttributeAlias3, GlobalAttributeAlias4, GlobalattributeAlias5, 
				GlobalAttributeAlias6, GlobalattributeAlias7, GlobalattributeAlias8, GlobalattributeAlias9, GlobalattributeAlias10, 
				GlobalattributeAlias11, GlobalattributeAlias12, GlobalAttributeAlias13, GlobalAttributeAlias14, GlobalattributeAlias15, 
				GlobalAttributeAlias16, GlobalattributeAlias17, GlobalattributeAlias18, GlobalattributeAlias19, GlobalattributeAlias20,
				GlobalattributeAlias21, GlobalattributeAlias22, GlobalAttributeAlias23, GlobalAttributeAlias24, GlobalattributeAlias25
			FROM [dbo].[sx_pf_dProductLines] dPL LEFT JOIN [dbo].[sx_pf_vUserRights] vUR 
			ON dPL.FactoryID = vUR.FactoryID AND
				dPL.ProductLineID = vUR.ProductLineID AND
				vUR.[Right] IN (N'Read', N'Write') AND
				vUR.UserName = @TransactUsername
		)
		, attrs AS (
			SELECT DISTINCT Attribute, Value 
			FROM 
				(SELECT * FROM data) pvt
				UNPIVOT
				(Value FOR Attribute IN (
					GlobalattributeAlias1, GlobalattributeAlias2, GlobalAttributeAlias3, GlobalAttributeAlias4, GlobalattributeAlias5, 
					GlobalAttributeAlias6, GlobalattributeAlias7, GlobalattributeAlias8, GlobalattributeAlias9, GlobalattributeAlias10, 
					GlobalattributeAlias11, GlobalattributeAlias12, GlobalAttributeAlias13, GlobalAttributeAlias14, GlobalattributeAlias15, 
					GlobalAttributeAlias16, GlobalattributeAlias17, GlobalattributeAlias18, GlobalattributeAlias19, GlobalattributeAlias20,
					GlobalattributeAlias21, GlobalattributeAlias22, GlobalAttributeAlias23, GlobalAttributeAlias24, GlobalattributeAlias25
					)
				) AS unpvt
		)
		SELECT CAST(SUBSTRING(Attribute, 21, 2) AS INT) AS N, Value AS GlobalAttribute
		FROM attrs
		ORDER BY N, GlobalAttribute;

		SET @EffectedRows = @@ROWCOUNT;		
		SET @Resultcode = 200;

		COMMIT TRANSACTION ONE;
		SET NOCOUNT ON;
		SET ANSI_WARNINGS OFF;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_AllGlobalAttributeUsage] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_AllGlobalAttributeUsage] TO pf_PlanningFactoryService;
GO
/*
GET Operation for cross query of attribute usage

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Info_GlobalAttributeUsage 'SQL','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Info_GlobalAttributeUsage]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Info_GlobalAttributeUsage];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Info_GlobalAttributeUsage]
	@Username AS NVARCHAR(255),
	@GlobalattributeNumber AS INT
AS 
BEGIN
	SET NOCOUNT ON;
	SET ANSI_WARNINGS OFF;

	DECLARE @TransactUsername AS NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',' + CAST(ISNULL(@GlobalattributeNumber, N'NULL') AS nvarchar(255));
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		SET NOCOUNT OFF;
		SET ANSI_WARNINGS ON;

		-- STEP 3. Show public values	
		SELECT DISTINCT
		CASE @GlobalattributeNumber
			WHEN 1 THEN GlobalattributeAlias1
			WHEN 2 THEN GlobalattributeAlias2
			WHEN 3 THEN GlobalAttributeAlias3
			WHEN 4 THEN GlobalAttributeAlias4
			WHEN 5 THEN GlobalattributeAlias5
			WHEN 6 THEN GlobalAttributeAlias6
			WHEN 7 THEN GlobalattributeAlias7
			WHEN 8 THEN GlobalattributeAlias8
			WHEN 9 THEN GlobalattributeAlias9
			WHEN 10 THEN GlobalattributeAlias10
			WHEN 11 THEN GlobalattributeAlias11
			WHEN 12 THEN GlobalattributeAlias12
			WHEN 13 THEN GlobalAttributeAlias13
			WHEN 14 THEN GlobalAttributeAlias14
			WHEN 15 THEN GlobalattributeAlias15
			WHEN 16 THEN GlobalAttributeAlias16
			WHEN 17 THEN GlobalattributeAlias17
			WHEN 18 THEN GlobalattributeAlias18
			WHEN 19 THEN GlobalattributeAlias19
			WHEN 20 THEN GlobalattributeAlias20		
			WHEN 21 THEN GlobalattributeAlias21
			WHEN 22 THEN GlobalattributeAlias22
			WHEN 23 THEN GlobalAttributeAlias23
			WHEN 24 THEN GlobalAttributeAlias24
			WHEN 25 THEN GlobalattributeAlias25
			ELSE N'not existing'
		END AS GlobalAttribute	
		FROM [dbo].[sx_pf_dProductLines] dPL LEFT JOIN [dbo].[sx_pf_vUserRights] vUR 
			ON dPL.FactoryID = vUR.FactoryID AND
				dPL.ProductLineID = vUR.ProductLineID AND
				vUR.[Right] IN (N'Read',N'Write') AND
				vUR.UserName = @TransactUsername
		ORDER BY GlobalAttribute;

		SET @EffectedRows = @@ROWCOUNT;		
		SET @Resultcode = 200;

		COMMIT TRANSACTION ONE;
		SET NOCOUNT ON;
		SET ANSI_WARNINGS OFF;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_GlobalAttributeUsage] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_GlobalAttributeUsage] TO pf_PlanningFactoryService;
GO

/*
GET Operation for monitoring Properties

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
ReturnValues according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Info_Monitoring 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Info_Monitoring]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Info_Monitoring];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Info_Monitoring]
	@Username AS NVARCHAR(255)

AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL')
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3 - Select Values

		IF OBJECT_ID('tempdb..#temp') IS NOT NULL
		DROP TABLE #temp

		CREATE TABLE #temp (
				 Property NVARCHAR (255)
				,Value NVARCHAR (255)
					)

		INSERT INTO #temp
			-- Language
			SELECT 'Cluster_C03' AS Property, ValueText FROM sx_pf_gCluster WHERE PropertyID = 'C03'
			UNION ALL
			-- Clustername
			SELECT 'Cluster_C01' AS Property, ValueText FROM sx_pf_gCluster WHERE PropertyID = 'C01'	
			UNION ALL
			-- API Version
			SELECT 'Cluster_C04' AS Property, ValueText FROM sx_pf_gCluster WHERE PropertyID = 'C04'	
			UNION ALL
			-- FactoryCount
			SELECT 'FactoryCount' AS Property, CAST(COUNT(*) AS NVARCHAR) FROM sx_pf_dFactories
			UNION ALL
			-- ProductLineCount
			SELECT 'ProductlineCount' AS Property, CAST(COUNT(*) AS NVARCHAR) FROM sx_pf_dProductLines
			UNION ALL
			-- ProductCount
			SELECT 'ProductCount' AS Property, CAST(COUNT(*) AS NVARCHAR) FROM sx_pf_dProducts
			UNION ALL
			-- API Error 500 Count
			SELECT 'API_Error500' AS Property, CAST(COUNT(*) AS NVARCHAR) FROM sx_pf_API_Log WHERE ReturnCode = 500 AND ProcessCode = ''
			UNION ALL
			-- API Error 404 Count
			SELECT 'API_Error404' AS Property, CAST(COUNT(*) AS NVARCHAR) FROM sx_pf_API_Log WHERE ReturnCode = 404 AND ProcessCode = ''


		SELECT * FROM #temp
		
		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_Monitoring] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_Monitoring] TO pf_PlanningFactoryService;
GO
/*
GET Operation for the next free ProductID
Gibt bei numerischen IDs die nächste freie, bei nichtnumerischen ID '' zurück

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Info_NextFreeProductID 'SQL','1','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Info_NextFreeProductID]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Info_NextFreeProductID];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Info_NextFreeProductID]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @FreeProductID  AS NVARCHAR(255) = '';
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	

		IF @FactoryID = N'' OR  @ProductLineID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		
		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;
		
		IF @ResultCode <> 200	
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;
		
		-- STEP 3.1 - Get last determined Numeric ID	
		;WITH ids AS (
			SELECT TRY_CAST(ProductID as bigint) id 
			FROM [dbo].[sx_pf_dProducts] 
			WHERE ProductLineKey = @ProductLineKey 
		)
		SELECT @FreeProductID = MAX(id) 
		FROM ids
		WHERE id IS NOT NULL;

		-- STEP 3.2 - Increment ID
		IF @FreeProductID IS NOT NULL
		BEGIN
			SET @FreeProductID = @FreeProductID + 1;
		END
		ELSE
		BEGIN
			SET @FreeProductID = N'';
		END;

		-- STEP 3.3 - Safety check whether determined ID already exists
		IF EXISTS(SELECT ProductID FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @FreeProductID)
		BEGIN
			SET @FreeProductID = N'';
		END
		ELSE
		BEGIN
			SELECT @FreeProductID AS NextFreeProductID;
		END

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END 
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_NextFreeProductID] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_NextFreeProductID] TO pf_PlanningFactoryService;
GO
/*
GET Operation for validation of the integrity between defined and used Formats, Lists

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test Call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Info_StructureIntegrity 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_GET_Info_StructureIntegrity]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Info_StructureIntegrity];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Info_StructureIntegrity] 
	@Username AS NVARCHAR(255) 
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;			-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;			-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';		-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
		BEGIN 
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3 - Do checks
		;WITH frmt AS (
			SELECT DISTINCT FormatID
			FROM [dbo].[sx_pf_hFormats]
		),
		dVS AS (
			SELECT DISTINCT ValueFormatID
			FROM [dbo].[sx_pf_dValueSeries]
		),
		hL AS (
			SELECT DISTINCT ListID
			FROM [dbo].[sx_pf_hLists]
		),
		hLV AS (
			SELECT DISTINCT FormatID
			FROM [dbo].[sx_pf_hListValues]
			WHERE FormatID <> ''
		),
		lsts AS (
			SELECT DISTINCT ListID
			FROM [dbo].[sx_pf_hLists] 
		)
		-- STEP 3.1 - ERROR Check for Formats, which are used, but not defined in ValueSeries
		SELECT
			N'Format Test' AS TestGroup,
			N'Used in ValueSeries, but not defined' AS Test, 
			N'Error' AS Result, 
			dVS.ValueFormatID
		FROM dVS LEFT JOIN frmt f ON dVS.ValueFormatID = f.FormatID
		WHERE f.FormatID IS NULL AND f.FormatID !=''

		-- STEP 3.2 - ERROR as Format for ListValues (Info: Checks not if this ListValue is used anywhere, but as it can be used its as error classified)
		UNION ALL
		SELECT
			N'Format Test', N'Used as FormatID for ListValue(s), but not defined as Format', N'Error', hLV.FormatID
		FROM hLV LEFT JOIN frmt f ON hLV.FormatID = f.FormatID
		WHERE f.FormatID IS NULL

		-- STEP 3.3 - INFO Check for Formats, which are defined, but not used in ValueSeries
		UNION ALL
		SELECT
			N'Format Test', N'Defined in Formats, but not used in ValueSeries', N'INFO', f.FormatID
		FROM frmt f LEFT JOIN dVS ON f.FormatID = dVS.ValueFormatID
		WHERE dVS.ValueFormatID IS NULL
	
		-- STEP 3.4 - INFO Check for Formats, which are defined, but not used in Lists
		UNION ALL
		SELECT
			N'Format Test', N'Defined in Formats, but not used in ListValues', N'INFO', f.FormatID
		FROM frmt f LEFT JOIN hLV ON f.FormatID = hLV.FormatID
		WHERE hlv.FormatID IS NULL

		-- STEP 3.5 - ERROR Lists used in dProductlines as GlobalattributeSource, but not definied in hLists
		UNION ALL
		SELECT N'List Test' , N'Lists used in dProductlines as GlobalattributeSource' + Num + N', but not definied in hLists', N'ERROR', GlobalAttributeSource
		FROM (
			SELECT '1' AS Num, GlobalAttributeSource1 GlobalAttributeSource
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource1 <> N'' UNION ALL
			SELECT N'2', GlobalAttributeSource2
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource2 <> N'' UNION ALL
			SELECT N'3', GlobalAttributeSource3
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource3 <> N'' UNION ALL
			SELECT N'4', GlobalAttributeSource4
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource4 <> N'' UNION ALL
			SELECT N'5', GlobalAttributeSource5
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource5 <> N'' UNION ALL
			SELECT N'6', GlobalAttributeSource6
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource6 <> N'' UNION ALL
			SELECT N'7', GlobalAttributeSource7
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource7 <> N'' UNION ALL
			SELECT N'8', GlobalAttributeSource8
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource8 <> N'' UNION ALL
			SELECT N'9', GlobalAttributeSource9
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource9 <> N'' UNION ALL
			SELECT N'10', GlobalAttributeSource10
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource10 <> N'' UNION ALL
			SELECT N'11', GlobalAttributeSource11
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource11 <> N'' UNION ALL
			SELECT N'12', GlobalAttributeSource12
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource12 <> N'' UNION ALL
			SELECT N'13', GlobalAttributeSource13
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource13 <> N'' UNION ALL
			SELECT N'14', GlobalAttributeSource14
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource14 <> N'' UNION ALL
			SELECT N'15', GlobalAttributeSource15
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource15 <> N'' UNION ALL
			SELECT N'16', GlobalAttributeSource16
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource16 <> N'' UNION ALL
			SELECT N'17', GlobalAttributeSource17
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource17 <> N'' UNION ALL
			SELECT N'18', GlobalAttributeSource18
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource18 <> N'' UNION ALL
			SELECT N'19', GlobalAttributeSource19
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource19 <> N'' UNION ALL
			SELECT N'20', GlobalAttributeSource20
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource20 <> N'' UNION ALL
			SELECT N'21', GlobalAttributeSource21
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource21 <> N'' UNION ALL
			SELECT N'22', GlobalAttributeSource22
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource22 <> N'' UNION ALL
			SELECT N'23', GlobalAttributeSource23
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource23 <> N'' UNION ALL
			SELECT N'24', GlobalAttributeSource24
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource24 <> N'' UNION ALL
			SELECT N'25', GlobalAttributeSource25
			FROM [dbo].[sx_pf_dProductlines] WHERE GlobalAttributeSource25 <> N'') pars LEFT JOIN lsts ON pars.GlobalAttributeSource = lsts.ListID 
		WHERE lsts.ListID IS NULL
		GROUP BY pars.Num, pars.GlobalAttributeSource
		
		-- STEP 3.6 - ERROR Lists used in dValueSeries as ValueSource, but not definied in hLists
		UNION ALL
		SELECT N'List Test', N'Lists used in dValueSeries as ValueSource, but not definied in hLists', N'ERROR', ValueListID
		FROM [dbo].[sx_pf_dValueSeries] ss LEFT JOIN lsts ON  ss.ValueListID = lsts.ListID
		WHERE lsts.ListID IS NULL AND ss.ValueListID <> N''
		GROUP BY ss.ValueListID

		-- STEP 3.7 - ERROR Check existence of system Lists
		UNION ALL
		SELECT N'List Test', N'Test for necessary system lists - missing list', N'ERROR', syslsts.ListID
		FROM (
			SELECT N'sxIsNumeric' as ListID UNION ALL
			SELECT N'sxResponsiblePersons' UNION ALL
			SELECT N'sxScales' UNION ALL
			SELECT N'sxStatus' UNION ALL
			SELECT N'sxUnits' UNION ALL
			SELECT N'sxValueEffectParameters' UNION ALL
			SELECT N'sxValueEffects' UNION ALL
			SELECT N'sxValueFormats' UNION ALL
			SELECT N'sxValueLists' UNION ALL
			SELECT N'sxValueSources' UNION ALL
			SELECT N'sxVisibilityLevel'
		) syslsts LEFT JOIN lsts ON syslsts.ListID = lsts.ListID
		WHERE lsts.ListID IS NULL;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_StructureIntegrity] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Info_StructureIntegrity] TO pf_PlanningFactoryService;
GO




/*
GET Operation for a List 
Shows the properties of one List
This procedure don't shows internal system lists

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_List 'SQL', 'sxStatus'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_List]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_List];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_List]
	@Username AS NVARCHAR(255),
	@ListID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @ListKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ListID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ListID IS NULL SET @ListID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @ListID = [dbo].[sx_pf_pProtectID] (@ListID);

		IF @ListID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine Keys
		SELECT @ListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE ListID = @ListID;

		IF @ListKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			 ListID
			,NameShort
			,NameLong
			,CommentDev
			,CommentUser
			,Datentyp
			,[Source]
			,SourceFormula
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_hLists]
		WHERE ListKey = @ListKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_List] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_List] TO pf_PlanningFactoryService;
GO
/*
GET Operation for receiving a context sensitiv List
API deliviers List Values fitting to the sended context Parameters
Procedure must be editend to fit user needs and recreated after each API Update
When updating this procedure, you must reset the rights for it

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
--should return Data and 200
EXEC @RESULT = sx_pf_GET_ListDynamic 'SQL','1','1','1','1','','','ei'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ListDynamic]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ListDynamic];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ListDynamic]
	@Username AS NVARCHAR(255)
	,@FactoryID AS NVARCHAR(255)
	,@ProductLineID AS NVARCHAR(255)
	,@ProductID AS NVARCHAR(255)
	,@ValueSeriesID AS NVARCHAR(255)
	,@GlobalattributeNumber AS NVARCHAR(255)
	,@PageType AS NVARCHAR(255)    -- PDT (ProductDataTable), PLP (ProductLinePage)
	,@SearchString AS NVARCHAR(255)  --any Substring from searched list values
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL')
		 + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSeriesID, N'NULL') + N''',''' + ISNULL(@GlobalattributeNumber, N'NULL')  
		+ N''',''' + ISNULL(@PageType, N'NULL') + N''',''' +  ISNULL(@SearchString, N'NULL') + N'''';  

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductlineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSeriesID IS NULL SET @ValueSeriesID = N'';
	IF @GlobalattributeNumber IS NULL SET @GlobalattributeNumber = '';
	IF @PageType IS NULL SET @PageType = N'';

	SET @SearchString = '%' + ISNULL(@SearchString, '') + '%';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ValueSeriesID = [dbo].[sx_pf_pProtectID] (@ValueSeriesID);
				
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
	
		-- STEP 3.1 - Sample for creating a List for a specific ValueSeries in all Products from specific template
		IF @ValueSeriesID = N'that' 
		AND EXISTS(
				SELECT Template FROM [dbo].[sx_pf_dProducts] 
				WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID AND Template = N'Invest_VM'
		)
		BEGIN
			SELECT 'ValueSeriesSpecificList' AS Dummy;
			SET @EffectedRows = 1;
		END;

		-- STEP 3.2 - Sample for creating a List for a Globalattribute in one Productline
		IF @FactoryID = N'this' AND @ProductlineID = N'that' AND @GlobalattributeNumber = 5
		BEGIN
			SELECT 'ProductlineSpecificList for ValueSeries'; 
			SET @EffectedRows += 1;
		END;
		
		-- STEP 3.3 - this are sample data which are used as output as long there are no user specific implementations
		DECLARE @Cities AS TABLE(Name NVARCHAR (255));

		INSERT INTO @Cities VALUES
				 (N'Aachen'),
				 (N'Augsburg'),
				 (N'Bergisch Gladbach'),
				 (N'Berlin'),
				 (N'Bielefeld'),
				 (N'Bochum'),
				 (N'Bonn'),
				 (N'Bottrop'),
				 (N'Braunschweig'),
				 (N'Bremen'),
				 (N'Bremerhaven'),
				 (N'Chemnitz'),
				 (N'Darmstadt'),
				 (N'Dortmund'),
				 (N'Dresden'),
				 (N'Duisburg'),
				 (N'Düsseldorf'),
				 (N'Erfurt'),
				 (N'Erlangen'),
				 (N'Essen'),
				 (N'Frankfurt am Main'),
				 (N'Freiburg im Breisgau'),
				 (N'Fürth'),
				 (N'Gelsenkirchen'),
				 (N'Göttingen'),
				 (N'Hagen'),
				 (N'Halle (Saale)'),
				 (N'Hamburg'),
				 (N'Hamm'),
				 (N'Hannover'),
				 (N'Heidelberg'),
				 (N'Heilbronn'),
				 (N'Herne'),
				 (N'Ingolstadt'),
				 (N'Jena'),
				 (N'Karlsruhe'),
				 (N'Kassel'),
				 (N'Kiel'),
				 (N'Koblenz'),
				 (N'Köln'),
				 (N'Krefeld'),
				 (N'Leipzig'),
				 (N'Leverkusen'),
				 (N'Lübeck'),
				 (N'Ludwigshafen am Rhein'),
				 (N'Magdeburg'),
				 (N'Mainz'),
				 (N'Mannheim'),
				 (N'Moers'),
				 (N'Mönchengladbach'),
				 (N'Mülheim an der Ruhr'),
				 (N'München'),
				 (N'Münster'),
				 (N'Neuss'),
				 (N'Nürnberg'),
				 (N'Oberhausen'),
				 (N'Offenbach am Main'),
				 (N'Oldenburg'),
				 (N'Osnabrück'),
				 (N'Paderborn'),
				 (N'Pforzheim'),
				 (N'Potsdam'),
				 (N'Recklinghausen'),
				 (N'Regensburg'),
				 (N'Remscheid'),
				 (N'Reutlingen'),
				 (N'Rostock'),
				 (N'Saarbrücken'),
				 (N'Siegen'),
				 (N'Solingen'),
				 (N'Stuttgart'),
				 (N'Trier'),
				 (N'Ulm'),
				 (N'Wiesbaden'),
				 (N'Wolfsburg'),
				 (N'Wuppertal'),
				 (N'Würzburg');
		
		SELECT * FROM @Cities WHERE Name LIKE @SearchString ORDER BY Name;

		SET @EffectedRows += @@ROWCOUNT;

		SET @ResultCode = 200;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO

-- SET Rights
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ListDynamic] TO pf_PlanningFactoryUser
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ListDynamic] TO pf_PlanningFactoryService
GO
/*
GET Operation for all GUI Lists in Cluster
Internal system lists are not shown

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call 

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Lists 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Lists]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Lists]
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Lists]
	@Username AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values
		SELECT 
			ListID
			,NameShort
			,NameLong
			,CommentDev
			,CommentUser
			,Datentyp
			,[Source]
			,SourceFormula
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_hLists]
		ORDER BY ISNULL(TRY_CAST(ListID AS INT), 999999999), ListID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Lists] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Lists] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all List Values
- shows values of all GUI Lists
- shows values of the internal list "sxScales", as this list is need for the other lists

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterPropertiesReadRight
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Values according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ListValues 'SQL', 'sxEvents'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ListValues]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ListValues]
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ListValues]
	@Username AS NVARCHAR(255),
	@ListID AS NVARCHAR(255)
AS 
BEGIN
	DECLARE @ListKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ListID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ListID IS NULL SET @ListID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @ListID = [dbo].[sx_pf_pProtectID] (@ListID);

		IF @ListID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;


		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterPropertiesReadRight] @TransactUsername;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		IF @ListID != 'sxScales'
			BEGIN
				-- STEP 1.2 - Determine Keys
				SELECT @ListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE ListID = @ListID;

				IF @ListKey = 0	
				BEGIN
					SET @ResultCode = 404;
					RAISERROR('Keys don`t exists', 16, 10);
				END;

				-- STEP 3. Show public values, always one dummy line, if list exists	
				SELECT 
					ISNULL(hLV.ListValueKey, 0) AS ListValueKey  --returns the Key as the Listvalue has no ID
					,hL.ListID
					,hL.Datentyp
					,ISNULL(hLV.ValueInt, 0) AS ValueInt
					,ISNULL(hLV.Scale, 0) AS Scale
					,ISNULL(hLV.ValueText, N'') AS ValueText
					,ISNULL(hLV.ValueComment, N'') AS ValueComment
					,ISNULL(hLV.FormatID, N'') AS FormatID
					,@Right AS [Right]
				FROM [dbo].[sx_pf_hLists] hL
					LEFT JOIN [dbo].[sx_pf_hListValues] hLV	ON hL.ListID = hLV.ListID
				WHERE hL.ListID = @ListID 
				ORDER BY ISNULL(TRY_CAST(hLV.ValueText AS INT), 999999999), hLV.ValueText, hLV.ValueInt;
				SET @EffectedRows = @@ROWCOUNT;
			END

		-- static definition of sxScales to be loaded for list defintion
		IF @ListID = 'sxScales'
			BEGIN
				SELECT * FROM 
				(
				VALUES	
					 (1,'sxScales','Integer',1,1,'','','','Read')
					,(2,'sxScales','Integer',10,1,'','','','Read')
					,(3,'sxScales','Integer',100,1,'','','','Read')
					,(4,'sxScales','Integer',1000,1,'','','','Read')
					,(5,'sxScales','Integer',10000,1,'','','','Read')
				) tmp (ListValueKey,ListID,Datentyp,ValueInt,Scale,ValueText,ValueComment,FormatID,[Right])

				SET @EffectedRows = @@ROWCOUNT;
			END

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ListValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ListValues] TO pf_PlanningFactoryService;
GO
/*
GET Operation for Prefences

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

03/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

1. Empty FactoryID or empty ProductLineID => 404 Not Found
2. Username non Cluster Admin => 403 Forbidden
3. User does not have rights to read ProductLine => 401 Unauthorized
5. No exists Factory / Productline > 404 Not Found

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @PreferenceUserName AS NVARCHAR(255) = 'W8\admin'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'U'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @SettingName AS NVARCHAR(255) = 'Demopref'


EXECUTE @RC = [sx_pf_GET_Preference] 
		@Username,
		@PreferenceUsername,
		@ProductLineID,
		@FactoryID,
		@SettingName

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Preference]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Preference];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Preference]
	@Username AS NVARCHAR(255),
	@PreferenceUsername AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@SettingName AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @UserExistsFlag AS INT = 0;
	DECLARE @PreferenceIsUserDependendFlag AS INT = 0;
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PreferenceUsername, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''','''+ ISNULL(@SettingName, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @PreferenceUsername IS NULL SET @PreferenceUsername = N'';
	IF @SettingName IS NULL SET @SettingName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @PreferenceUsername = [dbo].[sx_pf_pProtectString] (@PreferenceUsername);
		SET @SettingName = [dbo].[sx_pf_pProtectString] (@SettingName);

		IF @PreferenceUsername = N'' OR @SettingName = N''  OR @SettingName = N'<#NV>'	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 0.3 - Determine, if Preferences are saved per user

		IF @FactoryID = N'' AND @ProductLineID = N''
		BEGIN 
			SELECT @PreferenceIsUserDependendFlag = ValueInt FROM [dbo].[sx_pf_gCluster] WHERE PropertyID = N'C06';
		END 
		ELSE IF @FactoryID <> N'' AND @ProductLineID = N''
		BEGIN 
			SELECT @PreferenceIsUserDependendFlag = ValueInt FROM [dbo].[sx_pf_gFactories] WHERE PropertyID = N'F06';
		END
		ELSE IF @FactoryID <> N'' AND @ProductLineID <> N''
		BEGIN 
			SELECT @PreferenceIsUserDependendFlag = ValueInt FROM [dbo].[sx_pf_gFactories] WHERE PropertyID = N'P06';
		END;
		
		-- STEP 1.1 - Determine Keys
		SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;

		IF (@FactoryKey = 0 AND @FactoryID <> N'')
			OR (@ProductlineKey = 0 AND @ProductLineID <> N'')	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Test existence of Preferences Users
			-- no longer, due to clusters with public user

		-- STEP 1.3 - Change PreferenceUser if Preferences User-independend
		IF @PreferenceIsUserDependendFlag <> 1
		BEGIN 
			SET @PreferenceUsername = N'All';
		END;

		--- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3. Show public values
		SELECT 
			UserName
			,FactoryID
			,ProductlineID
			,SettingName
			,ValueInt
			,ValueText
		FROM [dbo].[sx_pf_rPreferences] 
		WHERE FactoryID = @FactoryID 
			AND ProductLineID = @ProductLineID 
			AND Username = @PreferenceUsername 
			AND SettingName = @SettingName;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Preference] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Preference] TO pf_PlanningFactoryService;
GO

/*
GET Operation for Product

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Product 'SQL','ZT','U','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Product]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Product]
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Product]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			dP.ProductID
			,dP.ProductLineID
			,dP.FactoryID
			,TimeType
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ResponsiblePerson
			,ImageName
			,[Status]
			,Template
			,TemplateVersion
			,GlobalAttribute1
			,GlobalAttribute2
			,GlobalAttribute3
			,GlobalAttribute4
			,GlobalAttribute5
			,GlobalAttribute6
			,GlobalAttribute7
			,GlobalAttribute8
			,GlobalAttribute9
			,GlobalAttribute10
			,GlobalAttribute11
			,GlobalAttribute12
			,GlobalAttribute13
			,GlobalAttribute14
			,GlobalAttribute15
			,GlobalAttribute16
			,GlobalAttribute17
			,GlobalAttribute18
			,GlobalAttribute19
			,GlobalAttribute20
			,GlobalAttribute21
			,GlobalAttribute22
			,GlobalAttribute23
			,GlobalAttribute24
			,GlobalAttribute25
			,@Right AS [Right]
			,vUR.ReadCommentMandatory
			,vUR.WriteCommentMandatory
		FROM [dbo].[sx_pf_dProducts] dP LEFT JOIN [dbo].[sx_pf_vUserRights] vUR 
			ON  dP.FactoryID = vUR.FactoryID AND
				dP.ProductLineID = vUR.ProductLineID AND
				vUR.UserName = @TransactUsername
		WHERE dP.ProductKey = @ProductKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Product] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Product] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all Values of ProductDataTable

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Values according HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductDataTableValues 'SQL','ZT','U','1'
PRINT @RESULT

--should return 404
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductDataTableValues 'SQL','ZT2','U','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductDataTableValues]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductDataTableValues];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductDataTableValues]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution
	
	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values
		SELECT  
			 fV.ProductID
			,fV.ProductLineID
			,fV.FactoryID
			,fV.ValueSeriesID
			,TimeID
			,ValueFormula
			,ValueInt
			,ValueText
			,ValueComment
			,@Right AS [Right]
		FROM [dbo].[sx_pf_fValues] fV LEFT JOIN [dbo].[sx_pf_dValueSeries] dVS 
			ON fV.ValueSeriesKey = dVS.ValueSeriesKey
		WHERE  fV.ProductKey = @ProductKey
		ORDER BY ValueSeriesNo, TimeID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductDataTableValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductDataTableValues] TO pf_PlanningFactoryService;
GO
/*
GET Operation for ProductLine
Provides complete information about a Product Line

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductLine 'SQL','ZT','U'
PRINT @RESULT
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductLine]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductLine];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductLine]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		
		IF @FactoryID = N'' OR  @ProductLineID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;

		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN

			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT  
			ProductLineID 
			,FactoryID
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ResponsiblePerson
			,ImageName
			,DefaultTemplate
			,GlobalAttributeSource1
			,GlobalAttributeAlias1
			,GlobalAttributeSource2
			,GlobalAttributeAlias2
			,GlobalAttributeSource3
			,GlobalAttributeAlias3
			,GlobalAttributeSource4
			,GlobalAttributeAlias4
			,GlobalAttributeSource5
			,GlobalAttributeAlias5
			,GlobalAttributeSource6
			,GlobalAttributeAlias6
			,GlobalAttributeSource7
			,GlobalAttributeAlias7
			,GlobalAttributeSource8
			,GlobalAttributeAlias8
			,GlobalAttributeSource9
			,GlobalAttributeAlias9
			,GlobalAttributeSource10
			,GlobalAttributeAlias10

			,GlobalAttributeSource11
			,GlobalAttributeAlias11
			,GlobalAttributeSource12
			,GlobalAttributeAlias12
			,GlobalAttributeSource13
			,GlobalAttributeAlias13
			,GlobalAttributeSource14
			,GlobalAttributeAlias14
			,GlobalAttributeSource15
			,GlobalAttributeAlias15
			,GlobalAttributeSource16
			,GlobalAttributeAlias16
			,GlobalAttributeSource17
			,GlobalAttributeAlias17
			,GlobalAttributeSource18
			,GlobalAttributeAlias18
			,GlobalAttributeSource19
			,GlobalAttributeAlias19
			,GlobalAttributeSource20
			,GlobalAttributeAlias20

			,GlobalAttributeSource21
			,GlobalAttributeAlias21
			,GlobalAttributeSource22
			,GlobalAttributeAlias22
			,GlobalAttributeSource23
			,GlobalAttributeAlias23
			,GlobalAttributeSource24
			,GlobalAttributeAlias24
			,GlobalAttributeSource25
			,GlobalAttributeAlias25

			,@Right AS [Right]
		FROM [dbo].[sx_pf_dProductLines]
		WHERE ProductLineKey = @ProductLineKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLine] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLine] TO pf_PlanningFactoryService;
GO
/*
GET Operation for determination of all properties of ProductLine

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductLineProperties 'SQL','ZT','BK'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductLineProperties]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductLineProperties];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductLineProperties]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		
		IF @FactoryID = N'' OR  @ProductLineID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;

		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values		
		SELECT  
			FactoryID
			,ProductLineID
			,PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gProductLines]
		WHERE 
			FactoryKey = @FactoryKey 
			AND ProductLineKey = @ProductLineKey
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLineProperties] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLineProperties] TO pf_PlanningFactoryService;
GO
/*
GET Operation for determining a ProductLine Property

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductLineProperty 'SQL','ZT','BK','PL01'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductLineProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductLineProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductLineProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @PropertyID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @PropertyKey = PropertyKey FROM sx_pf_gProductLines WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND PropertyID = @PropertyID

		IF @PropertyKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
				
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values		
		SELECT  
			FactoryID
			,ProductLineID
			,PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gProductLines]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLineProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLineProperty] TO pf_PlanningFactoryService;
GO
/*
GET Operation for ProductLines

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductLines 'SQL','ZT'
PRINT @RESULT
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductLines]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductLines];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductLines]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);

		IF @FactoryID = N''		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 3. Show public values	
		;WITH vUR AS (
			SELECT 
				FactoryID, 
				ProductLineID, 
				[Right] 
			FROM [dbo].[sx_pf_vUserRights] 
			WHERE ProductLineID <> N'' 
				AND Username = @TransactUsername 
				AND	[Right] IN (N'Read', N'Write')
		)
		SELECT  
			dPL.ProductLineID 
			,dPL.FactoryID
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ResponsiblePerson
			,ImageName
			,DefaultTemplate
			,GlobalAttributeSource1
			,GlobalAttributeAlias1
			,GlobalAttributeSource2
			,GlobalAttributeAlias2
			,GlobalAttributeSource3
			,GlobalAttributeAlias3
			,GlobalAttributeSource4
			,GlobalAttributeAlias4
			,GlobalAttributeSource5
			,GlobalAttributeAlias5
			,GlobalAttributeSource6
			,GlobalAttributeAlias6
			,GlobalAttributeSource7
			,GlobalAttributeAlias7
			,GlobalAttributeSource8
			,GlobalAttributeAlias8
			,GlobalAttributeSource9
			,GlobalAttributeAlias9
			,GlobalAttributeSource10
			,GlobalAttributeAlias10

			,GlobalAttributeSource11
			,GlobalAttributeAlias11
			,GlobalAttributeSource12
			,GlobalAttributeAlias12
			,GlobalAttributeSource13
			,GlobalAttributeAlias13
			,GlobalAttributeSource14
			,GlobalAttributeAlias14
			,GlobalAttributeSource15
			,GlobalAttributeAlias15
			,GlobalAttributeSource16
			,GlobalAttributeAlias16
			,GlobalAttributeSource17
			,GlobalAttributeAlias17
			,GlobalAttributeSource18
			,GlobalAttributeAlias18
			,GlobalAttributeSource19
			,GlobalAttributeAlias19
			,GlobalAttributeSource20
			,GlobalAttributeAlias20

			,GlobalAttributeSource21
			,GlobalAttributeAlias21
			,GlobalAttributeSource22
			,GlobalAttributeAlias22
			,GlobalAttributeSource23
			,GlobalAttributeAlias23
			,GlobalAttributeSource24
			,GlobalAttributeAlias24
			,GlobalAttributeSource25
			,GlobalAttributeAlias25

			,vUR.[Right]
		FROM [dbo].[sx_pf_dProductLines] dPL INNER JOIN vUR
			ON dPL.FactoryID = vUR.FactoryID AND
			   dPL.ProductLineID = vUR.ProductLineID
		WHERE FactoryKey = @FactoryKey
		ORDER BY ISNULL(TRY_CAST(dPL.ProductLineID AS BIGINT), 999999999), dPL.ProductLineID;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = 200;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLines] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductLines] TO pf_PlanningFactoryService;
GO

/*
GET Operation for identifying all Properties of Products

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductProperties 'SQL','ZT','U','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductProperties]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductProperties];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductProperties]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @ProductKey= 0 OR @ProductLineKey= 0 OR @FactoryKey= 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values
		SELECT  
			FactoryID
			,ProductLineID
			,PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gProducts]
		WHERE ProductKey = @ProductKey
		ORDER BY ISNULL(TRY_CAST(PropertyID AS INT), 999999999), PropertyID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductProperties] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductProperties] TO pf_PlanningFactoryService;
GO
/*
GET Operation for determining a ProductProperty

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ProductProperty 'SQL','ZT','U','1','P1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ProductProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ProductProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ProductProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	 SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N''  OR @PropertyID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gProducts] WHERE ProductKey = @ProductKey AND PropertyID = @PropertyID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0 OR @PropertyKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
			
		-- STEP 2.1 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values
		SELECT  
			FactoryID
			,ProductLineID
			,PropertyID
			,PropertyName
			,CommentUser
			,CommentDev
			,Unit
			,ValueText
			,ValueInt
			,Scale
			,IsROSystemProperty
			,FormatID
			,@Right AS [Right]
		FROM [dbo].[sx_pf_gProducts]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ProductProperty] TO pf_PlanningFactoryService;
GO

/*
GET Operation for all Product of ProductLine

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

-- should return 200
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Products 'SQL','ZT','U'
PRINT @RESULT

-- should return 404
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Products 'SQL','ZT','U1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Products]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Products];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Products]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	

		IF @FactoryID = N'' OR  @ProductLineID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16 ,10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;

		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			ProductID
			,dP.ProductLineID
			,dP.FactoryID
			,TimeType
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ResponsiblePerson
			,ImageName
			,[Status]
			,Template
			,TemplateVersion
			,GlobalAttribute1
			,GlobalAttribute2
			,GlobalAttribute3
			,GlobalAttribute4
			,GlobalAttribute5
			,GlobalAttribute6
			,GlobalAttribute7
			,GlobalAttribute8
			,GlobalAttribute9
			,GlobalAttribute10
			,GlobalAttribute11
			,GlobalAttribute12
			,GlobalAttribute13
			,GlobalAttribute14
			,GlobalAttribute15
			,GlobalAttribute16
			,GlobalAttribute17
			,GlobalAttribute18
			,GlobalAttribute19
			,GlobalAttribute20
			,GlobalAttribute21
			,GlobalAttribute22
			,GlobalAttribute23
			,GlobalAttribute24
			,GlobalAttribute25
			,@Right AS [Right]
			,vUR.ReadCommentMandatory
			,vUR.WriteCommentMandatory
		FROM [dbo].[sx_pf_dProducts] dP LEFT JOIN [dbo].[sx_pf_vUserRights] vUR 
			ON	dP.FactoryID = vUR.FactoryID AND
			dP.ProductLineID = vUR.ProductLineID AND
			vUR.UserName = @TransactUsername
		WHERE ProductLineKey = @ProductLineKey 
		ORDER BY ISNULL(TRY_CAST(ProductID AS INT), 999999999), ProductID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Products] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Products] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all Statements of Products

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Statements 'SQL','ZT','U','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Statements]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Statements];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Statements]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		
		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values		
		SELECT 
			ProductID
			,ProductLineID
			,FactoryID
			,ActionType
			,[Statement]
			,UserName
			,PCName
			,ProcessorCode
			,IPAddresses
			,[Timestamp]
			,IsDeleted
			,IsResolved
			,@Right AS [Right]
		FROM [dbo].[sx_pf_fStatements]
		WHERE ProductKey = @ProductKey 
		ORDER BY [Timestamp] DESC;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Statements] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Statements] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all TimeIDs of ValueSeries

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.5
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_TimeIDs 'SQL','ZT','U','1'
PRINT @RESULT
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_TimeIDs]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_TimeIDs];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_TimeIDs]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		
		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;		
		
		-- STEP 3. Show public values	
		SELECT  
			 ProductID
			,ProductLineID
			,FactoryID
			,TimeID
		FROM [dbo].[sx_pf_dTime]
		WHERE ProductKey = @ProductKey 
		ORDER BY TimeID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_TimeIDs] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_TimeIDs] TO pf_PlanningFactoryService;
GO
/*
GET Operation for a User

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_User 'SQL', 'W8\admin'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_User]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_User];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_User]
	@Username AS NVARCHAR(255),
	@RequestedUserName AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @UserKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@RequestedUserName, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @RequestedUserName IS NULL SET @RequestedUserName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @RequestedUserName = [dbo].[sx_pf_pProtectString] (@RequestedUserName);

		IF @RequestedUserName = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - don't deliver the member of PlannigFactoryService
		IF ISNULL(IS_ROLEMEMBER('pf_PlanningFactoryService', @RequestedUsername), 2) = 1
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Member of PlannigFactoryService', 16, 10);
		END

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @UserKey = UserKey FROM [dbo].[sx_pf_rUser] WHERE UserName = @RequestedUserName
		
		IF @UserKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights 
		IF @TransactUsername = @RequestedUserName 
		BEGIN --user Must see themselves
			SET @Right = N'Read';
			SET @ResultCode = 200;
		END 
		ELSE
		BEGIN	
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;
		
			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Write';
			END
			ELSE 
			BEGIN		
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			UserKey
			,UserName
			,PersonSurname
			,PersonFirstName
			,Email
			,LDAPIP
			,[Status]
			,@Right AS [Right]
		FROM [dbo].[sx_pf_rUser]
		WHERE UserKey = @UserKey; 

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_User] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_User] TO pf_PlanningFactoryService;
GO
/*
GET Operation for User rights

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_UserRight 'SQL', 'W10\admin'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_UserRight]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_UserRight];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_UserRight]
	@Username AS NVARCHAR(255),
	@RequstedUserName AS NVARCHAR(255) -- at the Moment written wrong, due to API compatibility !!!
AS 
BEGIN
	SET NOCOUNT ON;

	--- TEMP ---------------------------
	DECLARE @RequestedUsername NVARCHAR(255) = ''
	SET @RequestedUsername =  @RequstedUserName 
	--- / TEMP -------------------------

	DECLARE @UserKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@RequestedUserName, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @RequestedUserName IS NULL SET @RequestedUserName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @RequestedUserName = [dbo].[sx_pf_pProtectString] (@RequestedUserName);

		-- Check on empty name or SystemUser
		IF @RequestedUserName = N'' OR @RequestedUserName = N'PlanningFactoryService'
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @UserKey = UserKey FROM [dbo].[sx_pf_rUser] WHERE UserName = @RequestedUserName
		
		IF @UserKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights 
		IF @TransactUsername = @RequestedUserName 
		BEGIN --user Must see themselves
			SET @Right = N'Read';
			SET @ResultCode = 200;
		END 
		ELSE
		BEGIN	
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;
		
			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Write';
			END
			ELSE 
			BEGIN		
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		IF @Right = N'Read' --User is allowed to see of himself only positive rights
		BEGIN
			SELECT 
				Username
				,FactoryID
				,ProductLineID
				,[Right]
				,ReadCommentMandatory
				,WriteCommentMandatory
			FROM [dbo].[sx_pf_vUserRights]
			WHERE UserKey = @UserKey 
				AND [Right] IN ('Read', 'Write')
				ORDER BY ISNULL(TRY_CAST(FactoryID AS INT), 999999999), FactoryID, ISNULL(TRY_CAST(ProductLineID AS INT), 999999999), ProductLineID;;
		END
		ELSE
		BEGIN
			IF  @Right = N'Write' -- Cluster admin can see also negative rights (really don`t exist)
			BEGIN
				SELECT 
					Username
					,FactoryID
					,ProductLineID
					,[Right]
					,ReadCommentMandatory
					,WriteCommentMandatory
				FROM [dbo].[sx_pf_vUserRights]
				WHERE UserKey = @UserKey
				ORDER BY ISNULL(TRY_CAST(FactoryID AS INT), 999999999), FactoryID, ISNULL(TRY_CAST(ProductLineID AS INT), 999999999), ProductLineID;
			END;
		END;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_UserRight] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_UserRight] TO pf_PlanningFactoryService;
GO

/*
GET Operation for all Users rights

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_UserRights 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_UserRights]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_UserRights];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_UserRights]
	@Username AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;
		
		-- STEP 3. Show public values		
		SELECT 
			Username
			,FactoryID
			,ProductLineID
			,[Right]
			,ReadCommentMandatory
			,WriteCommentMandatory
		FROM [dbo].[sx_pf_vUserRights]
		WHERE Username <> N'PlanningFactoryService'
		ORDER BY Username, FactoryID, ProductLineID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_UserRights] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_UserRights] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all Users

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Users 'SQL'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Users]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Users];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Users]
	@Username AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
		BEGIN
			RAISERROR('Invalid rights', 16, 10);
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			UserKey
			,UserName
			,PersonSurname
			,PersonFirstName
			,Email
			,LDAPIP
			,Status
			,N'Write' AS [Right]
		FROM [dbo].[sx_pf_rUser]
		WHERE Username NOT IN (
			SELECT m.name 
			FROM sys.database_role_members rm 
				INNER JOIN sys.database_principals r ON rm.role_principal_id = r.principal_id
				INNER JOIN sys.database_principals m ON rm.member_principal_id = m.principal_id
			WHERE r.name = N'pf_PlanningFactoryService')
		ORDER BY ISNULL(TRY_CAST(UserName AS INT), 999999999), UserName
		
		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Users] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Users] TO pf_PlanningFactoryService;
GO
/*
GET Operation for a Value

Dependencies:
	 - Functions:
		- sx_pf_pProtectID 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Value 'SQL','ZT','U','1','K1', 20160115
PRINT @RESULT
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Value]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Value];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Value]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ValueSerieID AS NVARCHAR(255),
	@TimeID AS INT
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSerieKey AS INT = 0;
	DECLARE @ValueKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSerieID, N'NULL')
		 + N''',''' + ISNULL(CAST(@TimeID AS NVARCHAR(10)), N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSerieID IS NULL SET @ValueSerieID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
	
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ValueSerieID = [dbo].[sx_pf_pProtectID] (@ValueSerieID);
		
		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' OR @ValueSerieID = N'' OR ISNULL(@TimeID, 0) <= 0		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		SELECT @ValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey AND ValueSeriesID = @ValueSerieID;
		SELECT @ValueKey = ValueKey FROM [dbo].[sx_pf_fValues] WHERE ValueSeriesKey = @ValueSerieKey AND TimeID = @TimeID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0 OR @ValueSerieKey = 0 OR @ValueKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2.1 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values
		SELECT  
			 ProductID
			,ProductLineID
			,FactoryID
			,ValueSeriesID
			,TimeID
			,ValueFormula
			,ValueInt
			,ValueText
			,ValueComment
			,@Right AS [Right]
		FROM [dbo].[sx_pf_fValues]
		WHERE ValueKey = @ValueKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Value] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Value] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all Values of ValueSeries

Dependencies:
	 - Functions:
		- sx_pf_pProtectID 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard


Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Values 'SQL','ZT','U','1','K1'
PRINT @RESULT

--should return 401
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Values 'SQL2','ZT','U','1','K1'
PRINT @RESULT


--should return 404
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_Values 'SQL','ZT','U','1','K1test'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_Values]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_Values];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_Values]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ValueSerieID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSerieKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSerieID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSerieID IS NULL SET @ValueSerieID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
	
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ValueSerieID = [dbo].[sx_pf_pProtectID] (@ValueSerieID);
		
		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' OR @ValueSerieID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		SELECT @ValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey AND ValueSeriesID = @ValueSerieID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0 OR @ValueSerieKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT  
			 ProductID
			,ProductLineID
			,FactoryID
			,ValueSeriesID
			,TimeID
			,ValueFormula
			,ValueInt
			,ValueText
			,ValueComment
			,@Right AS [Right]
		FROM [dbo].[sx_pf_fValues]
		WHERE ValueSeriesKey = @ValueSerieKey
		ORDER BY TimeID;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Values] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_Values] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all ValueSerie

Dependencies:
	 - Functions:
		- sx_pf_pProtectID 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ValueSerie 'SQL','ZT','U','1','K1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ValueSerie]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ValueSerie];
GO

CREATE PROCEDURE [dbo].[sx_pf_GET_ValueSerie]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ValueSerieID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSerieKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSerieID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSerieID IS NULL SET @ValueSerieID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
	
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ValueSerieID = [dbo].[sx_pf_pProtectID] (@ValueSerieID);
		
		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N'' OR @ValueSerieID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		SELECT @ValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey AND ValueSeriesID = @ValueSerieID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0 OR @ValueSerieKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values	
		SELECT 
			ProductID
			,ProductLineID
			,FactoryID
			,ValueSeriesID
			,ValueSeriesNo
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ImageName
			,[IsNumeric]
			,VisibilityLevel
			,ValueSource
			,ValueListID
			,ValueFormatID
			,Unit
			,Scale
			,Effect
			,EffectParameter
			,@Right AS [Right]
		FROM [dbo].[sx_pf_dValueSeries]
		WHERE ValueSeriesKey = @ValueSerieKey;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
 
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ValueSerie] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ValueSerie] TO pf_PlanningFactoryService;
GO
/*
GET Operation for all ValueSeries of Product

Dependencies:
	 - Functions:
		- sx_pf_pProtectID 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call

DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_GET_ValueSeries 'SQL','ZT','U','1'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_GET_ValueSeries]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_GET_ValueSeries];
GO

CREATE  PROCEDURE [dbo].[sx_pf_GET_ValueSeries]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @Right AS NVARCHAR(10);
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
	
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		
		IF @FactoryID = N'' OR  @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode = 200
		BEGIN
			SET @Right = N'Write';
		END ELSE BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode = 200
			BEGIN
				SET @Right = N'Read';
			END ELSE BEGIN 
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;
		
		-- STEP 3. Show public values		
		SELECT 
			ProductID
			,ProductLineID
			,FactoryID
			,ValueSeriesID
			,ValueSeriesNo
			,NameShort
			,NameLong
			,CommentUser
			,CommentDev
			,ImageName
			,[IsNumeric]
			,VisibilityLevel
			,ValueSource
			,ValueListID
			,ValueFormatID
			,Unit
			,Scale
			,Effect
			,EffectParameter
			,@Right AS [Right]
		FROM [dbo].[sx_pf_dValueSeries]
		WHERE ProductKey = @ProductKey 
		ORDER BY ValueSeriesNo;

		SET @EffectedRows = @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO

GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ValueSeries] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_GET_ValueSeries] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a ClusterProperty
A not existing Property will be created, an existing Property will be updated
If the value <#NV> is passed as parameter, it means keep the existing value 

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectBoolean
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to the cluster at Create => 401 Unauthorized
4. Property created => 201 Created
5. Property updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @PropertyID AS NVARCHAR(255) = 'rre'
		DECLARE @PropertyName AS NVARCHAR(255) = ''
		DECLARE @CommentUser AS NVARCHAR(255) = ''
		DECLARE @CommentDev AS NVARCHAR(255) = ''
		DECLARE @Unit AS NVARCHAR(255) = ''
		DECLARE @ValueText AS NVARCHAR(255) = ''
		DECLARE @ValueInt AS NVARCHAR(255) = '678'
		DECLARE @Scale AS NVARCHAR(255) = '<#NV>'
		DECLARE @IsROSystemProperty AS NVARCHAR(255) = '0'
		DECLARE @FormatID AS NVARCHAR(255) = '<#NV>'

EXECUTE @RC = [sx_pf_POST_ClusterProperty] 
		@Username,
		@PropertyID,
		@PropertyName,
		@CommentUser,
		@CommentDev,
		@Unit,
		@ValueText,
		@ValueInt,
		@Scale,
		@IsROSystemProperty,
		@FormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ClusterProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ClusterProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ClusterProperty]
	@Username AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255),
	@PropertyName AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@Unit AS NVARCHAR(255),
	@ValueText AS NVARCHAR(255),
	@ValueInt AS NVARCHAR(255),
	@Scale AS NVARCHAR(255),
	@IsROSystemProperty AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @PropertyKey AS INT = 0;
	DECLARE @SytemROBlocker INT = 0;
	DECLARE @TransactUsername NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + N''','''+ ISNULL(@PropertyName, N'NULL') + N''',''' + ISNULL(@CommentUser, N'NULL') 
		+ N''','''+ ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@Unit, N'NULL') + N''','''+ ISNULL(@ValueText, N'NULL') + N''','''+ ISNULL(@ValueInt, N'NULL') 
		+ N''','''+ ISNULL(@Scale, N'NULL') + N''',''' + ISNULL(@IsROSystemProperty, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR(2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';
	IF @PropertyName IS NULL SET @PropertyName = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @Unit IS NULL SET @Unit = N'';
	IF @ValueText IS NULL SET @ValueText = N'';
	IF @ValueInt IS NULL SET @ValueInt = N'';
	IF @Scale IS NULL SET @Scale = N'';
	IF @IsROSystemProperty IS NULL SET @IsROSystemProperty = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE
		
		-- STEP 0.2 - Protect input parameters
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);
		SET @PropertyName = [dbo].[sx_pf_pProtectString] (@PropertyName);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @Unit = [dbo].[sx_pf_pProtectString] (@Unit);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);
		SET @ValueInt = [dbo].[sx_pf_pProtectInt] (@ValueInt);
		SET @Scale = [dbo].[sx_pf_pProtectInt] (@Scale);
		SET @FormatID = [dbo].[sx_pf_pProtectString] (@FormatID);

		IF @PropertyID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gCluster] WHERE PropertyID = @PropertyID; 
				
		-- STEP 1.3 - Don`t allow changing of system RO Properties
		SELECT @SytemROBlocker = IsROSystemProperty FROM [dbo].[sx_pf_gCluster] WHERE PropertyID = @PropertyID;
		IF @SytemROBlocker = 1 BEGIN
			SET @ResultCode = 403;
			RAISERROR('Don`t allow changing of system RO Properties', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3.1 - If Key does not yet exist, it will be created in minimal configuration		
		IF @PropertyKey = 0
		BEGIN
			
			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_gCluster] (PropertyID) 
			OUTPUT INSERTED.PropertyKey INTO @Keys([Key])
			VALUES (@PropertyID);

			SELECT TOP 1 @PropertyKey = [Key] FROM @Keys;
			
			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;		

		-- STEP 3.2 - Update Cluster attributes
		UPDATE [dbo].[sx_pf_gCluster]
		SET  					 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	
			PropertyName = IIF(@PropertyName = N'<#NV>', PropertyName, @PropertyName)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, Unit = IIF(@Unit = N'<#NV>', Unit, @Unit)
			, ValueText = IIF(@ValueText = N'<#NV>', ValueText, @ValueText)
			, ValueInt = IIF(@ValueInt = N'<#NV>', ValueInt, @ValueInt)
			, Scale = IIF(@Scale = N'<#NV>', Scale, @Scale)
			, IsROSystemProperty = IIF(@IsROSystemProperty = N'<#NV>', IsROSystemProperty, @IsROSystemProperty)
			, FormatID = IIF(@FormatID = N'<#NV>', FormatID, @FormatID)
		FROM [dbo].[sx_pf_gCluster]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ClusterProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ClusterProperty] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a Factory
Not existing Factories are created, existing updated
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight (for create)
		- sx_pf_pGET_FactoryWriteRight (for update)
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. FactoryID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to Factory => 401 Unauthorized
4. Username does not have write access to the cluster at Create => 401 Unauthorized
5. Factory created => 201 Created
6. Factory updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @NameShort AS NVARCHAR(255) = ''
		DECLARE @NameLong AS NVARCHAR(255) = ''
		DECLARE @CommentUser AS NVARCHAR(255) = ''
		DECLARE @CommentDev AS NVARCHAR(255) = ''
		DECLARE @ResponsiblePerson AS NVARCHAR(255) = ''
		DECLARE @ImageName AS NVARCHAR(255) = ''

EXECUTE @RC = [sx_pf_POST_Factory] 
		@Username,
		@FactoryID,
		@NameShort,
		@NameLong,
		@CommentUser,
		@CommentDev,
		@ResponsiblePerson,
		@ImageName

PRINT @RC
*/

IF  EXISTS(SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Factory]') AND [type] in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Factory];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Factory]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@NameShort AS NVARCHAR(255),
	@NameLong AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@ResponsiblePerson AS NVARCHAR(255),
	@ImageName AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''','''+ ISNULL(@NameShort, N'NULL')
		+ N''','''+ ISNULL(@NameLong, N'NULL') + N''','''+ ISNULL(@CommentUser, N'NULL') + N''','''+ ISNULL(@CommentDev, N'NULL')
		+ N''','''+ ISNULL(@ResponsiblePerson, N'NULL') + N''',''' + ISNULL(@ImageName, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR(2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @NameShort IS NULL SET @NameShort = N'';
	IF @NameLong IS NULL SET @NameLong = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @ResponsiblePerson IS NULL SET @ResponsiblePerson = N'';
	IF @ImageName IS NULL SET @ImageName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @NameShort = [dbo].[sx_pf_pProtectString] (@NameShort);
		SET @NameLong = [dbo].[sx_pf_pProtectString] (@NameLong);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @ResponsiblePerson = [dbo].[sx_pf_pProtectString] (@ResponsiblePerson);
		SET @ImageName = [dbo].[sx_pf_pProtectString] (@ImageName);
		
		IF @FactoryID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		-- STEP 2 - Check rights
		IF @FactoryKey = 0
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;
		ELSE
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3.1 - If Factory does not yet exist, it will be created in minimal configuration
		IF @FactoryKey = 0
		BEGIN
			
			DECLARE @Keys AS TABLE ([Key] INT);
			
			INSERT INTO [dbo].[sx_pf_dFactories] (FactoryID, NameShort) 
			OUTPUT INSERTED.FactoryKey INTO @Keys([Key])
			VALUES (@FactoryID, @NameShort);

			SELECT TOP 1 @FactoryKey = [Key] FROM @Keys;

			SET @EffectedRows = 1;

			INSERT INTO [dbo].[sx_pf_gFactories] (
				FactoryKey
				, FactoryID
				, PropertyID
				, PropertyName
				, CommentUser
				, CommentDev
				, Unit
				, ValueText
				, ValueInt
				, Scale
				, IsROSystemproperty
				, FormatID)
			VALUES 
				(@FactoryKey, @FactoryID, N'F01', N'IsInImportMode', N'Import into Factory is running', N'', N'Integer', N'', 0, 0, 1, N'')
				, (@FactoryKey, @FactoryID, N'F02', N'FinancialYearStartMonth', N'In this Month, Financial Year starts', N'', N'Integer', N'', 1, 1, 0, N'');
			
			SET @EffectedRows += @@ROWCOUNT;		
			SET @Resultcode = 201;
		END;

		-- STEP 3.2 - Update Factory attributes
		UPDATE [dbo].[sx_pf_dFactories] 
		SET  					 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	
			NameShort = IIF(@NameShort = N'<#NV>', NameShort, @NameShort)
			, NameLong = IIF(@NameLong = N'<#NV>', NameLong, @NameLong)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, ResponsiblePerson = IIF(@ResponsiblePerson = N'<#NV>', ResponsiblePerson, @ResponsiblePerson)
			, ImageName = IIF(@ImageName = N'<#NV>', ImageName, @ImageName)
		FROM [dbo].[sx_pf_dFactories]
		WHERE FactoryKey = @FactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		-- STEP 3.3 - Rights materialize (no insert needed because only ClusterAdmin can create Factory)
		EXEC [dbo].[sx_pf_materialize_vUserRights];	

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Factory] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Factory] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a FactoryPivot
Not existing Property will be created, existing updated.
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryWriteRight 
		- sx_pf_pPOST_API_LogEntry

10/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to Factory => 401 Unauthorized
5. Property created => 201 Created
6. Property updated => 200 OK


DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @PivotID AS NVARCHAR(255) = 'Pivot_1'
		DECLARE @PivotProcedureName AS NVARCHAR(255) = 'sx_pf_DATAOUTPUT_FactorySummary'
		DECLARE @PivotName AS NVARCHAR(255) = 'My Pivot 1'
		DECLARE @Layout AS NVARCHAR(255) = ''
		DECLARE @ChartType AS NVARCHAR(255) = ''

EXECUTE @RC = [sx_pf_POST_FactoryPivot] 
		@Username,
		@FactoryID,
		@PivotID,
		@PivotProcedureName,
		@PivotName,
		@Layout,
		@ChartType

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_FactoryPivot]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_FactoryPivot];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_FactoryPivot]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@PivotID AS NVARCHAR(255),
	@PivotProcedureName AS NVARCHAR(255),
	@PivotName AS NVARCHAR(255),
	@Layout AS NVARCHAR(MAX),
	@ChartType AS NVARCHAR(255)

AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @PropertyOwner AS INT = 0;
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@PivotID, N'NULL')
		+ N''',''' + ISNULL(@PivotProcedureName, N'NULL')	+ N''',''' + ISNULL(@Layout, N'NULL') + N''',''' + ISNULL(@ChartType, N'NULL') + N'''';		
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @PivotID IS NULL SET @PivotID = N'';
	IF @PivotProcedureName IS NULL SET @PivotProcedureName = N'';
	IF @PivotName IS NULL SET @PivotName = N'';
	IF @Layout IS NULL SET @Layout = N'';
	IF @ChartType IS NULL SET @ChartType = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @PivotID = [dbo].[sx_pf_pProtectID] (@PivotID);
		SET @PivotProcedureName = [dbo].[sx_pf_pProtectString] (@PivotProcedureName);
		SET @PivotName = [dbo].[sx_pf_pProtectString] (@PivotName);
		SET @ChartType = [dbo].[sx_pf_pProtectInt] (@ChartType);

				
		IF @PivotID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @PivotID;
		
		IF @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Don`t allow changing of system RO Properties
		SELECT @PropertyOwner = IsROSystemProperty FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @PivotID;

		IF @PropertyOwner = 1
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Don`t allow changing of system RO Properties', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 3.1 - If property not exist, it will created minimalistic	
		IF @PropertyKey = 0
		BEGIN
			
			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_gFactories] (PropertyID, FactoryKey, FactoryID) 
			OUTPUT INSERTED.PropertyKey INTO @Keys([Key]) 
			VALUES (@PivotID, @FactoryKey, @FactoryID);

			SELECT TOP 1 @PropertyKey = [Key] FROM @Keys;

			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;
		
		-- STEP 3.2 - Update Factory property
		UPDATE [dbo].[sx_pf_gFactories]
		SET		
			 PropertyName = IIF(@PivotProcedureName = N'<#NV>',  PropertyName, @PivotProcedureName)
			,CommentUser = IIF(@PivotName = N'<#NV>',  CommentUser, @PivotName)
			,ValueText = IIF(@Layout = N'<#NV>', ValueText, @Layout)
			,ValueInt = IIF(@ChartType = N'<#NV>', ValueInt, @ChartType)
		FROM [dbo].[sx_pf_gFactories]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FactoryPivot] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FactoryPivot] TO pf_PlanningFactoryService;
GO

/*
POST Operation for a FactoryProperty
Not existing Property will be created, existing updated.
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryWriteRight 
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to Factory => 401 Unauthorized
5. Property created => 201 Created
6. Property updated => 200 OK


DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @PropertyID AS NVARCHAR(255) = 'rr3e'
		DECLARE @PropertyName AS NVARCHAR(255) = ''
		DECLARE @CommentUser AS NVARCHAR(255) = ''
		DECLARE @CommentDev AS NVARCHAR(255) = ''
		DECLARE @Unit AS NVARCHAR(255) = ''
		DECLARE @ValueText AS NVARCHAR(255) = ''
		DECLARE @ValueInt AS NVARCHAR(255) = '678'
		DECLARE @Scale AS NVARCHAR(255) = '<#NV>'
		DECLARE @IsROSystemProperty AS NVARCHAR(255) = '2'
		DECLARE @FormatID AS NVARCHAR(255) = '<#NV>'

EXECUTE @RC = [sx_pf_POST_FactoryProperty] 
		@Username,
		@FactoryID,
		@PropertyID,
		@PropertyName,
		@CommentUser,
		@CommentDev,
		@Unit,
		@ValueText,
		@ValueInt,
		@Scale,
		@IsROSystemProperty,
		@FormatID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_FactoryProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_FactoryProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_FactoryProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255),
	@PropertyName AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@Unit AS NVARCHAR(255),
	@ValueText AS NVARCHAR(255),
	@ValueInt AS NVARCHAR(255),
	@Scale AS NVARCHAR(255),
	@IsROSystemProperty AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @PropertyOwner AS INT = 0;
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL')
		+ N''',''' + ISNULL(@PropertyName, N'NULL')	+ N''',''' + ISNULL(@CommentUser, N'NULL') + N''',''' + ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@Unit, N'NULL')
		+ N''',''' + ISNULL(@ValueText, N'NULL') + N''',''' + ISNULL(@ValueInt, N'NULL') + N''',''' + ISNULL(@Scale, N'NULL') + N''',''' + ISNULL(@IsROSystemProperty, N'NULL')
		+ N''',''' + ISNULL(@FormatID, N'NULL') + N'''';		
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';
	IF @PropertyName IS NULL SET @PropertyName = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @Unit IS NULL SET @Unit = N'';
	IF @ValueText IS NULL SET @ValueText = N'';
	IF @ValueInt IS NULL SET @ValueInt = N'';
	IF @Scale IS NULL SET @Scale = N'';
	IF @IsROSystemProperty IS NULL SET @IsROSystemProperty = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);
		SET @PropertyName = [dbo].[sx_pf_pProtectString] (@PropertyName);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @Unit = [dbo].[sx_pf_pProtectString] (@Unit);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);
		SET @ValueInt = [dbo].[sx_pf_pProtectInt] (@ValueInt);
		SET @Scale = [dbo].[sx_pf_pProtectInt] (@Scale);
		SET @FormatID = [dbo].[sx_pf_pProtectString] (@FormatID); --has String Protection, as also #<NV> can be used as parameter
				
		IF @PropertyID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @PropertyID;
		
		IF @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Don`t allow changing of system RO Properties - disabled from Version 4.0.63 on to enable export/import
		--SELECT @PropertyOwner = IsROSystemProperty FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @PropertyID;

		--IF @PropertyOwner = 1
		--BEGIN
		--	SET @ResultCode = 403;
		--	RAISERROR('Don`t allow changing of system RO Properties', 16, 10);
		--END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		DECLARE @Keys AS TABLE ([Key] INT);

		-- STEP 3.1 - If property not exist, it will created minimalistic	
		IF @PropertyKey = 0
		BEGIN
			INSERT INTO [dbo].[sx_pf_gFactories] (PropertyID, FactoryKey, FactoryID) 
			OUTPUT INSERTED.PropertyKey INTO @Keys
			VALUES (@PropertyID, @FactoryKey, @FactoryID);

			SELECT TOP 1 @PropertyKey = [Key] FROM @Keys;
		   
			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;
		
		-- STEP 3.2 - Update Factory property
		UPDATE [dbo].[sx_pf_gFactories]
		SET PropertyName = IIF(@PropertyName = N'<#NV>',  PropertyName, @PropertyName)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, Unit = IIF(@Unit = N'<#NV>', Unit, @Unit)
			, ValueText = IIF(@ValueText = N'<#NV>', ValueText, @ValueText)
			, ValueInt = IIF(@ValueInt = N'<#NV>', ValueInt, @ValueInt)
			, Scale = IIF(@Scale = N'<#NV>', Scale, @Scale)
			, IsROSystemProperty = IIF(@IsROSystemProperty = N'<#NV>', IsROSystemProperty, @IsROSystemProperty)
			, FormatID = IIF(@FormatID = N'<#NV>', FormatID, @FormatID)
		FROM [dbo].[sx_pf_gFactories]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FactoryProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FactoryProperty] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a FactoryURL
Not existing Property will be created, existing updated.
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryWriteRight 
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to Factory => 401 Unauthorized
5. Property created => 201 Created
6. Property updated => 200 OK


DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @URLID AS NVARCHAR(255) = 'URL_1'
		DECLARE @URL AS NVARCHAR(MAX) = 'http://www.datafactory.co'
		DECLARE @TabName AS NVARCHAR(255) = 'DataFactory'


EXECUTE @RC = [sx_pf_POST_FactoryURL] 
		@Username,
		@FactoryID,
		@URLID,
		@URL,
		@TabName


PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_FactoryURL]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_FactoryURL];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_FactoryURL]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@URLID AS NVARCHAR(255),
	@URL AS NVARCHAR(MAX),
	@TabName AS NVARCHAR(255)

AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @PropertyOwner AS INT = 0;
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@URLID, N'NULL')
		+ N''',''' + ISNULL(@URL, N'NULL')	+ N''',''' + ISNULL(@TabName, N'NULL') + N'''';		
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @URLID IS NULL SET @URLID = N'';
	IF @URL IS NULL SET @URL = N'';
	IF @TabName IS NULL SET @TabName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @URLID = [dbo].[sx_pf_pProtectID] (@URLID);
		SET @URL = [dbo].[sx_pf_pProtectString] (@URL);
		SET @TabName = [dbo].[sx_pf_pProtectString] (@TabName);

				
		IF @URLID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @URLID;
		
		IF @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Don`t allow changing of system RO Properties
		SELECT @PropertyOwner = IsROSystemProperty FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @URLID;

		IF @PropertyOwner = 1
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Don`t allow changing of system RO Properties', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 3.1 - If property not exist, it will created minimalistic	
		IF @PropertyKey = 0
		BEGIN
			
			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_gFactories] (PropertyID, FactoryKey, FactoryID) 
			OUTPUT INSERTED.PropertyKey INTO @Keys([Key]) 
			VALUES (@URLID, @FactoryKey, @FactoryID);

			SELECT TOP 1 @PropertyKey = [Key] FROM @Keys;

			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;
		
		-- STEP 3.2 - Update Factory property
		UPDATE [dbo].[sx_pf_gFactories]
		SET		
			 CommentUser = IIF(@TabName = N'<#NV>',  CommentUser, @TabName)
			,PropertyName = 'URL'
			,ValueText = IIF(@URL = N'<#NV>', ValueText, @URL)
		FROM [dbo].[sx_pf_gFactories]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FactoryURL] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FactoryURL] TO pf_PlanningFactoryService;
GO

/*
POST Operation for sending FlexAction Parameter
Procedure must be editend to fit user needs and recreated after each API Update.

Dependencies:
	 - Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
--should return Data and 200
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_POST_FlexAction 'SQL','F1','PL1','P1','Mitarbeiter','','','P1000'
PRINT @RESULT
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_FlexAction]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_FlexAction];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_FlexAction]
	 @Username AS NVARCHAR(255)
	,@FactoryID AS NVARCHAR(255)
	,@ProductLineID AS NVARCHAR(255)
	,@ProductID AS NVARCHAR(255)
	,@ValueSeriesID AS NVARCHAR(255)
	,@GlobalattributeNumber AS NVARCHAR(255)
	,@PageType AS NVARCHAR(255)    -- PDT (ProductDataTable), PLP (ProductLinePage)
	,@FlexParameter AS NVARCHAR(255)  -- The Identifier (Second column of GET_FlexAction, first Display column) from the choosen list element
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL')
		 + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSeriesID, N'NULL') + N''',''' + ISNULL(@GlobalattributeNumber, N'NULL')  
		+ N''',''' + ISNULL(@PageType, N'NULL') + N''',''' +  ISNULL(@FlexParameter, N'NULL') + N'''';  

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductlineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSeriesID IS NULL SET @ValueSeriesID = N'';
	IF @GlobalattributeNumber IS NULL SET @GlobalattributeNumber = '';
	IF @PageType IS NULL SET @PageType = N'';
	IF @FlexParameter IS NULL SET @FlexParameter = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ValueSeriesID = [dbo].[sx_pf_pProtectID] (@ValueSeriesID);
		SET @Username = [dbo].[sx_pf_pProtectString] (@FlexParameter);
				
		-- STEP 1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- Sample Actions
		-- React on content parameters and FlexParameter for action

		IF @ValueSeriesID = 'Projekt'
			BEGIN
				-- POST_ValueSeries of Type Projekt, ValueSeriesID = FlexParameter
				PRINT 'Did Projekt'
				SET @ResultCode = 200;
			END

		IF @ValueSeriesID = 'Mitarbeiter' 
			BEGIN
				-- POST ValuesSeries of Type Mitarbeiter, ValueSeriesID = FlexParameter
				PRINT 'Did Mitarbeiter'
				SET @ResultCode = 200;
			END
		
		IF @ValueSeriesID NOT IN ('Projekt','Mitarbeiter' )
			BEGIN
				PRINT 'No fitting action found.'
				SET @ResultCode = 404
			END
			   
		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO

-- SET Rights
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FlexAction] TO pf_PlanningFactoryUser
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_FlexAction] TO pf_PlanningFactoryService
GO
/*
POST Operation for Format
Not existing Format will be created, existing updated.
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty
 
Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight 
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. FormatID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to the cluster at Create => 401 Unauthorized
4. Property created => 201 Created
5. Property updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FormatID AS NVARCHAR(255) = 'sxScales'
		DECLARE @BackgroundColor AS NVARCHAR(255) ='200'
		DECLARE @FontColor AS NVARCHAR(255) = '200'
		DECLARE @ValueFormat AS NVARCHAR(255) = '10'
		

EXECUTE @RC = [sx_pf_POST_Format] 
		@Username,
		@FormatID,
		@BackgroundColor,
		@FontColor,
		@ValueFormat

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Format]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Format];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Format]
	@Username AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255),
	@BackgroundColor AS NVARCHAR(255),
	@FontColor AS NVARCHAR(255),
	@ValueFormat AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @FormatKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) =N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N''',''' + ISNULL(@BackgroundColor, N'NULL')
		+ N''',''' + ISNULL(@FontColor, N'NULL') + N''',''' + ISNULL(@ValueFormat, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FormatID IS NULL SET @FormatID = N'';
	IF @BackgroundColor IS NULL SET @BackgroundColor = N'';
	IF @FontColor IS NULL SET @FontColor = N'';
	IF @ValueFormat IS NULL SET @ValueFormat = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FormatID = [dbo].[sx_pf_pProtectID] (@FormatID);
		SET @BackgroundColor = [dbo].[sx_pf_pProtectString] (@BackgroundColor);
		SET @FontColor = [dbo].[sx_pf_pProtectString] (@FontColor);
		SET @ValueFormat = [dbo].[sx_pf_pProtectString] (@ValueFormat);
		
		IF @FormatID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FormatKey = FormatKey FROM [dbo].[sx_pf_hFormats] WHERE FormatID = @FormatID;
			
		-- STEP 3.1 - If format does not yet exist, it will be created
		IF @FormatKey = 0
		BEGIN

			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_hFormats] (FormatID) 
			OUTPUT INSERTED.FormatKey INTO @Keys([Key]) 
			VALUES (@FormatID);

			SELECT TOP 1 @FormatKey = [Key] FROM @Keys;

			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;
		
		-- STEP 3.2 - Update format attributes
		UPDATE [dbo].[sx_pf_hFormats] 
		SET BackgroundColor = IIF(@BackgroundColor = N'<#NV>', BackgroundColor, @BackgroundColor)
			, FontColor = IIF(@FontColor = N'<#NV>', FontColor, @FontColor)
			, ValueFormat = IIF(@ValueFormat = N'<#NV>', ValueFormat, @ValueFormat)
		FROM [dbo].[sx_pf_hFormats]
		WHERE FormatKey = @FormatKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Format] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Format] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a List
Not existing Format will be created, existing updated.
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty
 
Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight 
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ListID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to the cluster at Create => 401 Unauthorized
4. List created => 201 Created
5. List updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ListID AS NVARCHAR(255) = 'sxScales'
		DECLARE @NameShort AS NVARCHAR(255) = '<#NV>'
		DECLARE @NameLong AS NVARCHAR(255) = '<#NV>'
		DECLARE @CommentDev AS NVARCHAR(255) = '<#NV>'
		DECLARE @CommentUser AS NVARCHAR(255) = '<#NV>'
		DECLARE @Datentyp AS NVARCHAR(255) = '<#NV>'
		DECLARE @Source AS NVARCHAR(255) = '<#NV>'
		DECLARE @SourceFormula AS NVARCHAR(255) = 'Testen'
		DECLARE @FormatID AS NVARCHAR(255) = '<#NV>'
		

EXECUTE @RC = [sx_pf_POST_List] 
		@Username,
		@ListID,
		@NameShort,
		@NameLong,
		@CommentDev,
		@CommentUser,
		@Datentyp,
		@Source,
		@SourceFormula,
		@FormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_List]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_List];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_List]
	@Username AS NVARCHAR(255),
	@ListID AS NVARCHAR(255),
	@NameShort AS NVARCHAR(255),
	@NameLong AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@Datentyp AS NVARCHAR(255),
	@Source AS NVARCHAR(255),
	@SourceFormula AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ListKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) =N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ListID, N'NULL') + N''',''' + ISNULL(@NameShort, N'NULL') 
		+ N''',''' + ISNULL(@NameLong, N'NULL') + N''',''' + ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@CommentUser, N'NULL') 
		+ N''',''' + ISNULL(@Datentyp, N'NULL') + N''',''' + ISNULL(@Source, N'NULL') + N''',''' + ISNULL(@SourceFormula, N'NULL') 
		+ N''',''' + ISNULL(@FormatID, N'NULL') + N'''';	
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ListID IS NULL SET @ListID = N'';
	IF @NameShort IS NULL SET @NameShort = N'';
	IF @NameLong IS NULL SET @NameLong = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @Datentyp IS NULL SET @Datentyp = N'';
	IF @Source IS NULL SET @Source = N'';
	IF @SourceFormula IS NULL SET @SourceFormula = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @ListID = [dbo].[sx_pf_pProtectID] (@ListID);
		SET @NameShort = [dbo].[sx_pf_pProtectString] (@NameShort);
		SET @NameLong = [dbo].[sx_pf_pProtectString] (@NameLong);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @Datentyp = [dbo].[sx_pf_pProtectString] (@Datentyp);
		SET @Source = [dbo].[sx_pf_pProtectString] (@Source);
		SET @SourceFormula = [dbo].[sx_pf_pProtectString] (@SourceFormula);
		SET @FormatID = [dbo].[sx_pf_pProtectString] (@FormatID); -- as it can be #<NV>

		IF @ListID =  N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END 
		ELSE IF @ListID IN ('sxIsNumeric', 'sxScales', 'sxValueEffects', 'sxValueLists', 'sxValueFormats', 'sxValueSources', 'sxVisibilityLevel') 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Invalid input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
				
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @ListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE ListID = @ListID;

		-- STEP 3.1 - If List is does not exist, it will be created
		IF @ListKey = 0
		BEGIN

			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_hLists] (ListID) 
			OUTPUT INSERTED.ListKey INTO @Keys([Key])
			VALUES (@ListID);

			SELECT TOP 1 @ListKey = [Key] FROM @Keys;

			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;

		-- STEP 3.2 - Update List attributes
		UPDATE [dbo].[sx_pf_hLists] 
		SET NameShort = IIF(@NameShort = N'<#NV>', NameShort, @NameShort)
			, NameLong  = IIF(@NameLong = N'<#NV>', NameLong, @NameLong)
			, CommentDev  = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, CommentUser  = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, Datentyp  = IIF(@Datentyp = N'<#NV>', Datentyp, @Datentyp)
			, [Source]  = IIF(@Source = N'<#NV>', [Source], @Source)
			, SourceFormula  = IIF(@SourceFormula = N'<#NV>', SourceFormula, @SourceFormula)
			, FormatID  = IIF(@FormatID = N'<#NV>', FormatID, @FormatID)
		FROM [dbo].[sx_pf_hLists]
		WHERE ListKey = @ListKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_List] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_List] TO pf_PlanningFactoryService;
GO
/*
POST Operation for ListValue
Not existing ListValue will be created, existing updated.
This procedure allows to pass a Key value, as there is no ID for a ListValue

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight 
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ListID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to the cluster at Create => 401 Unauthorized
4. List don`t exist  => 404 Not Found
5. ListValue created => 201 Created
6. ListValue updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ListValueKey AS INT = 0
		DECLARE @ListID AS NVARCHAR(255) = 'sxStatus'
		DECLARE @ValueInt AS INT = 5
		DECLARE @Scale AS INT = 1
		DECLARE @ValueText AS NVARCHAR(255) = 'Testeno'
		DECLARE @ValueComment AS NVARCHAR(255) = ''
		DECLARE @FormatID AS NVARCHAR(255) = ''
		

EXECUTE @RC = [sx_pf_POST_ListValue] 
		@Username,
		@ListValueKey,
		@ListID,
		@ValueInt,
		@Scale,
		@ValueText,
		@ValueComment,
		@FormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ListValue]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ListValue]
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ListValue]
	@Username AS NVARCHAR(255),
	@ListValueKey AS INT,
	@ListID AS NVARCHAR(255),
	@ValueInt AS INT,
	@Scale AS INT,
	@ValueText AS NVARCHAR(255),
	@ValueComment AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ListKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) =N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',' + ISNULL(CAST(@ListValueKey as NVARCHAR(255)), N'NULL') + N',''' + ISNULL(@ListID, N'NULL') 
		+ N''',' + ISNULL(CAST(@ValueInt AS NVARCHAR(255)), N'NULL') + N',' + ISNULL(CAST(@Scale AS NVARCHAR(255)), N'NULL') + N',''' + ISNULL(@ValueText, N'NULL') 
		+ N''',''' + ISNULL(@ValueComment, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N'''';	
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ListValueKey IS NULL SET @ListValueKey = 0;
	IF @ListID IS NULL SET @ListID = N'';
	IF @ValueInt IS NULL SET @ValueInt = 0;
	IF @Scale IS NULL SET @Scale = 0;
	IF @ValueText IS NULL SET @ValueText = N'';
	IF @ValueComment IS NULL SET @ValueComment = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @ListValueKey = [dbo].[sx_pf_pProtectInt] (@ListValueKey);
		SET @ListID = [dbo].[sx_pf_pProtectID] (@ListID);
		SET @ValueInt = [dbo].[sx_pf_pProtectInt] (@ValueInt);
		SET @Scale = [dbo].[sx_pf_pProtectInt] (@Scale);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);
		SET @ValueComment = [dbo].[sx_pf_pProtectString] (@ValueComment);
		SET @FormatID = [dbo].[sx_pf_pProtectID] (@FormatID);

		IF @ListID =  N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys and break if not existing
		SELECT @ListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE ListID = @ListID;
		
		IF @ListKey = 0	BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- Check if Listvalue exists, when ListValueKey 0 is submitted
		IF @ListValueKey = 0
			DECLARE @tmpKey BIGINT = 0
			DECLARE @tmpListType NVARCHAR(255) = ''
			BEGIN
				SELECT @tmpListType = hL.Datentyp FROM dbo.sx_pf_hLists hL WHERE hL.ListID = @ListID;

				IF @tmpListType = 'String'
					BEGIN
						SELECT @tmpKey = ListValueKey FROM dbo.sx_pf_hListValues hLV WHERE ListID = @ListID AND hLV.ValueText = @ValueText;
					END
					ELSE
					BEGIN
						SELECT @tmpKey = ListValueKey FROM dbo.sx_pf_hListValues hLV WHERE ListID = @ListID AND hLV.ValueInt = @ValueInt;
					END
			END

		IF (@tmpKey IS NOT NULL AND @tmpKey != 0) SET @ListValueKey = @tmpKey

		-- STEP 3.1 - If ListValueKey  = 0 is submitted, create new value
		IF @ListValueKey = 0
		BEGIN
			INSERT INTO [dbo].[sx_pf_hListValues] (ListID, ValueInt, Scale, ValueText, ValueComment, FormatID)
			VALUES (@ListID, @ValueInt, @Scale, @ValueText, @ValueComment, @FormatID);

			SET @Resultcode = 201;
			SET @EffectedRows = 1;
		END
		ELSE
		BEGIN
		-- STEP 3.2 - If existing key is committed, update the Key

			UPDATE [dbo].[sx_pf_hListValues] 
			SET ValueInt = @ValueInt
				, Scale = @Scale
				, ValueText = @ValueText
				, ValueComment = @ValueComment
				, FormatID = @FormatID
			WHERE ListValueKey = @ListValueKey;

			SET @EffectedRows += @@ROWCOUNT;
		END;	

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ListValue] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ListValue] TO pf_PlanningFactoryService;
GO
/*
POST Operation for Preference
Not existing Preference will be created, existing updated.
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty
 
Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pGET_ProductLineWriteRight 
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

03/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Preferences are not Userdepended and User is not ClusterAdmin
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to the ProductLine at Create => 401 Unauthorized
4. Username does not have write access to the Factory at Create => 401 Unauthorized
5. Non exists Factory / Productline keys => 404 Not Found
6. If all OK => 201 Created

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @PreferenceUserName AS NVARCHAR(255) = 'W8\admin'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'ZT'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @SettingName AS NVARCHAR(255) = 'Demopref'
		DECLARE @ValueInt AS NVARCHAR(255) = '8'
		DECLARE @ValueText AS NVARCHAR(255) = 'uztr'

EXECUTE @RC = [sx_pf_POST_Preference] 
		@Username,
		@PreferenceUsername,
		@ProductLineID,
		@FactoryID,
		@SettingName,
		@ValueInt,
		@ValueText

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Preference]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Preference];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Preference]
	@Username AS NVARCHAR(255),
	@PreferenceUsername AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@SettingName AS NVARCHAR(255),
	@ValueInt AS INT,
	@ValueText AS NVARCHAR(MAX)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @PreferenceIsUserDependendFlag AS INT = 0;
	DECLARE @WriteRight AS INT = 0;	
		
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PreferenceUsername, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@SettingName, N'NULL') 
		+ N''',' + ISNULL(CAST(@ValueInt AS NVARCHAR(255)), N'NULL') + N',''' + ISNULL(@ValueText, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;							-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @PreferenceUsername IS NULL SET @PreferenceUsername = N'';
	IF @SettingName IS NULL SET @SettingName = N'';
	IF @ValueInt IS NULL SET @ValueInt = 0;
	IF @ValueText IS NULL SET @ValueText = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @SettingName = [dbo].[sx_pf_pProtectString] (@SettingName);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);

		IF @SettingName = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine, if Preferences are saved per User
		-- for global Preferences
		IF @FactoryID = N'' AND @ProductLineID = N''
			SELECT @PreferenceIsUserDependendFlag = ValueInt FROM [dbo].[sx_pf_gCluster] WHERE PropertyID = 'C06';

		IF @FactoryID <> N'' 
		BEGIN 
			-- for Preferences per Factory
			IF @ProductLineID = N''
				SELECT @PreferenceIsUserDependendFlag = ValueInt FROM [dbo].[sx_pf_gFactories] WHERE PropertyID = 'F06';
			ELSE
				-- for Preferences per Productline
				SELECT @PreferenceIsUserDependendFlag = ValueInt FROM [dbo].[sx_pf_gFactories] WHERE PropertyID = 'P06';
		END;

		-- STEP 1.2 - if Preferences are not Userdependend, only a clusteradmin can save them
		IF @PreferenceIsUserDependendFlag <> 1 
		BEGIN
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;
			
			IF @ResultCode <> 200
			BEGIN
				SET @ResultCode = 403;
				RAISERROR('Invalid rights', 16, 10);
			END;
		END;

		-- STEP 1.3 - Determine Key, they may be null if no ID was give
		SELECT @FactoryKey = ISNULL(FactoryKey, 0) FROM sx_pf_dFactories WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ISNULL(ProductLineKey, 0) FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;

		-- Cancel if Factory or Product Line does not exist
		IF (@FactoryKey = 0 AND @FactoryID <> N'')
			OR (@ProductlineKey = 0	AND @ProductLineID <> N'')
			OR @SettingName = N'<#NV>'
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.4 - Set Preference User to "All" if Preferences are not Userdependend
		IF @PreferenceIsUserDependendFlag <> 1 
			SET @PreferenceUsername = N'All';
		ELSE
		-- STEP 1.5 - Test existence of Preferences Users
		IF NOT EXISTS(SELECT * FROM [dbo].[sx_pf_rUser] WHERE Username = @PreferenceUsername)
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('User don`t exists', 16, 10);
		END;		

		-- STEP 2. Rights check
		IF @ProductLineID <> N''
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;
		ELSE IF @FactoryID <> N''
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;
		ELSE IF @FactoryID = N'' AND @ProductLineID = N''
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3. Clear Preference and edit
		DELETE FROM [dbo].[sx_pf_rPreferences]
		WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND Username = @PreferenceUsername AND SettingName = @SettingName;

		SET @EffectedRows = @@ROWCOUNT;
		SET @ValueText = IIF(@ValueText = N'<#NV>', N'', @ValueText);

		INSERT INTO [dbo].[sx_pf_rPreferences] (UserName, FactoryID, ProductlineID, SettingName, ValueInt, ValueText)
		VALUES (@PreferenceUsername, @FactoryID, @ProductLineID, @SettingName, @ValueInt, @ValueText);

		SET @EffectedRows += @@ROWCOUNT;
		SET @Resultcode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Preference] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Preference] TO pf_PlanningFactoryService;
GO
/*
POST Operation for one Product
Not existing Product will be created if it exists in ZT Factory. Existing Product updated
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight 
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / ProductLine key => 404 Not Found
5. Don`t exist Template for new ProductID => 404 Not Found
6. Product created => 201 Created
7. Product updated => 200 OK

	DECLARE @RC int
	DECLARE  @Username AS NVARCHAR(255) = 'SQL'
	DECLARE  @ProductID AS NVARCHAR(255)='52'
	DECLARE  @ProductLineID AS NVARCHAR(255)='U'
	DECLARE  @FactoryID  AS NVARCHAR(255)='ZT'
	DECLARE  @TimeType AS NVARCHAR(255)='<#NV>'--'VM'
	DECLARE  @NameShort AS NVARCHAR(255)='Testproduct'
	DECLARE  @NameLong AS NVARCHAR(255)='3 test'
	DECLARE  @CommentUser AS NVARCHAR(255)='komment'
	DECLARE  @CommentDev AS NVARCHAR(255)='DEVKOmm'
	DECLARE  @ResponsiblePerson AS NVARCHAR(255)= 'RR'
	DECLARE  @ImageName AS NVARCHAR(255)='ImgName test'
	DECLARE  @Status AS NVARCHAR(255)='Aktiv'
	DECLARE  @Template AS NVARCHAR(255)='Unikum_VM'
	DECLARE  @TemplateVersion AS NVARCHAR(255)='VT'
	DECLARE  @GA1 AS NVARCHAR(255) ='Wert für GA1'--'<#NV>'
	DECLARE  @GA2 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA3 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA4 AS NVARCHAR(255) ='rer'
	DECLARE  @GA5 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA6 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA7 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA8 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA9 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA10 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA11 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA12 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA13 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA14 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA15 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA16 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA17 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA18 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA19 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA20 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA21 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA22 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA23 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA24 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA25 AS NVARCHAR(255) ='<#NV>'

-- TODO: Set parameter values here.

EXECUTE @RC = [sx_pf_POST_Product] 
   @Username,@ProductID,@ProductLineID,@FactoryID,@TimeType,@NameShort,@NameLong,@CommentUser,@CommentDev,@ResponsiblePerson,@ImageName,@Status,@Template
  ,@TemplateVersion,@GA1,@GA2,@GA3,@GA4,@GA5,@GA6,@GA7,@GA8,@GA9,@GA10,@GA11,@GA12,@GA13,@GA14,@GA15,@GA16,@GA17,@GA18,@GA19,@GA20,@GA21,@GA22,@GA23,@GA24,@GA25

PRINT @RC
*/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Product]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Product]
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Product]
	@Username  AS NVARCHAR(255),
	@ProductID  AS NVARCHAR(255),
	@ProductLineID  AS NVARCHAR(255),
	@FactoryID  AS NVARCHAR(255),
	@TimeType  AS NVARCHAR(255),
	@NameShort  AS NVARCHAR(255),
	@NameLong  AS NVARCHAR(255),
	@CommentUser  AS NVARCHAR(255),
	@CommentDev  AS NVARCHAR(255),
	@ResponsiblePerson  AS NVARCHAR(255),
	@ImageName  AS NVARCHAR(255),
	@Status  AS NVARCHAR(255),
	@Template  AS NVARCHAR(255),
	@TemplateVersion  AS NVARCHAR(255),
	@GA1  AS NVARCHAR(255),
	@GA2  AS NVARCHAR(255),
	@GA3  AS NVARCHAR(255),
	@GA4  AS NVARCHAR(255),
	@GA5  AS NVARCHAR(255),
	@GA6  AS NVARCHAR(255),
	@GA7  AS NVARCHAR(255),
	@GA8  AS NVARCHAR(255),
	@GA9  AS NVARCHAR(255),
	@GA10  AS NVARCHAR(255),
	@GA11  AS NVARCHAR(255),
	@GA12  AS NVARCHAR(255),
	@GA13  AS NVARCHAR(255),
	@GA14  AS NVARCHAR(255),
	@GA15  AS NVARCHAR(255),
	@GA16  AS NVARCHAR(255),
	@GA17  AS NVARCHAR(255),
	@GA18  AS NVARCHAR(255),
	@GA19  AS NVARCHAR(255),
	@GA20  AS NVARCHAR(255),
	@GA21  AS NVARCHAR(255),
	@GA22  AS NVARCHAR(255),
	@GA23  AS NVARCHAR(255),
	@GA24  AS NVARCHAR(255),
	@GA25 AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
		
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@TimeType, N'NULL') + N''',''' + ISNULL(@NameShort, N'NULL') + N''',''' + ISNULL(@NameLong, N'NULL') +
							   N''',''' + ISNULL(@CommentUser, N'NULL') + N''',''' + ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@ResponsiblePerson, N'NULL') + N''',''' + ISNULL(@ImageName, N'NULL') + N''',''' + ISNULL(@Status, N'NULL') + N''',''' + ISNULL(@Template, N'NULL') + N''',''' + ISNULL(@TemplateVersion, N'NULL') +
							   N''',''' + ISNULL(@GA1, N'NULL') + N''',''' + ISNULL(@GA2, N'NULL') + N''',''' + ISNULL(@GA3, N'NULL') + N''',''' + ISNULL(@GA4, N'NULL') + N''',''' + ISNULL(@GA5, N'NULL') + N''',''' + ISNULL(@GA6, N'NULL') + N''',''' + ISNULL(@GA7, N'NULL') + N''',''' + ISNULL(@GA8, N'NULL') + N''',''' + ISNULL(@GA9, N'NULL') + N''',''' + ISNULL(@GA10, N'NULL') +
							   N''',''' + ISNULL(@GA11, N'NULL') + N''',''' + ISNULL(@GA12, N'NULL') + N''',''' + ISNULL(@GA13, N'NULL') + N''',''' + ISNULL(@GA14, N'NULL') + N''',''' + ISNULL(@GA15, N'NULL') + N''',''' + ISNULL(@GA16, N'NULL') + N''',''' + ISNULL(@GA17, N'NULL') + N''',''' + ISNULL(@GA18, N'NULL') + N''',''' + ISNULL(@GA19, N'NULL') + N''',''' + ISNULL(@GA20, N'NULL') +
							   N''',''' + ISNULL(@GA21, N'NULL') + N''',''' + ISNULL(@GA22, N'NULL') + N''',''' + ISNULL(@GA23, N'NULL') + N''',''' + ISNULL(@GA24, N'NULL') + N''',''' + ISNULL(@GA25, N'NULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @TimeType IS NULL SET @TimeType = N'';
	IF @NameShort IS NULL SET @NameShort = N'';
	IF @NameLong IS NULL SET @NameLong = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @ResponsiblePerson IS NULL SET @ResponsiblePerson = N'';
	IF @ImageName IS NULL SET @ImageName = N'';
	IF @Status IS NULL SET @Status = N'';
	IF @Template IS NULL SET @Template = N'';
	IF @TemplateVersion IS NULL SET @TemplateVersion = N'';
	IF @GA1 IS NULL SET @GA1 = N'';
	IF @GA2 IS NULL SET @GA2 = N'';
	IF @GA3 IS NULL SET @GA3 = N'';
	IF @GA4 IS NULL SET @GA4 = N'';
	IF @GA5 IS NULL SET @GA5 = N'';
	IF @GA6 IS NULL SET @GA6 = N'';
	IF @GA7 IS NULL SET @GA7 = N'';
	IF @GA8 IS NULL SET @GA8 = N'';
	IF @GA9 IS NULL SET @GA9 = N'';
	IF @GA10 IS NULL SET @GA10 = N'';
	IF @GA11 IS NULL SET @GA11 = N'';
	IF @GA12 IS NULL SET @GA12 = N'';
	IF @GA13 IS NULL SET @GA13 = N'';
	IF @GA14 IS NULL SET @GA14 = N'';
	IF @GA15 IS NULL SET @GA15 = N'';
	IF @GA16 IS NULL SET @GA16 = N'';
	IF @GA17 IS NULL SET @GA17 = N'';
	IF @GA18 IS NULL SET @GA18 = N'';
	IF @GA19 IS NULL SET @GA19 = N'';
	IF @GA20 IS NULL SET @GA20 = N'';
	IF @GA21 IS NULL SET @GA21 = N'';
	IF @GA22 IS NULL SET @GA22 = N'';
	IF @GA23 IS NULL SET @GA23 = N'';
	IF @GA24 IS NULL SET @GA24 = N'';
	IF @GA25 IS NULL SET @GA25 = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @TimeType = [dbo].[sx_pf_pProtectString] (@TimeType);
		SET @NameShort = [dbo].[sx_pf_pProtectString] (@NameShort);
		SET @NameLong = [dbo].[sx_pf_pProtectString] (@NameLong);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @ResponsiblePerson = [dbo].[sx_pf_pProtectString] (@ResponsiblePerson);
		SET @ImageName = [dbo].[sx_pf_pProtectString] (@ImageName);
		SET @Status = [dbo].[sx_pf_pProtectString] (@Status);
		SET @Template = [dbo].[sx_pf_pProtectString] (@Template);
		SET @TemplateVersion = [dbo].[sx_pf_pProtectString] (@TemplateVersion);
		SET @GA1 = [dbo].[sx_pf_pProtectString] (@GA1);
		SET @GA2 = [dbo].[sx_pf_pProtectString] (@GA2);
		SET @GA3 = [dbo].[sx_pf_pProtectString] (@GA3);
		SET @GA4 = [dbo].[sx_pf_pProtectString] (@GA4);
		SET @GA5 = [dbo].[sx_pf_pProtectString] (@GA5);
		SET @GA6 = [dbo].[sx_pf_pProtectString] (@GA6);
		SET @GA7 = [dbo].[sx_pf_pProtectString] (@GA7);
		SET @GA8 = [dbo].[sx_pf_pProtectString] (@GA8);
		SET @GA9 = [dbo].[sx_pf_pProtectString] (@GA9);
		SET @GA10 = [dbo].[sx_pf_pProtectString] (@GA10);
		SET @GA11 = [dbo].[sx_pf_pProtectString] (@GA11);
		SET @GA12 = [dbo].[sx_pf_pProtectString] (@GA12);
		SET @GA13 = [dbo].[sx_pf_pProtectString] (@GA13);
		SET @GA14 = [dbo].[sx_pf_pProtectString] (@GA14);
		SET @GA15 = [dbo].[sx_pf_pProtectString] (@GA15);
		SET @GA16 = [dbo].[sx_pf_pProtectString] (@GA16);
		SET @GA17 = [dbo].[sx_pf_pProtectString] (@GA17);
		SET @GA18 = [dbo].[sx_pf_pProtectString] (@GA18);
		SET @GA19 = [dbo].[sx_pf_pProtectString] (@GA19);
		SET @GA20 = [dbo].[sx_pf_pProtectString] (@GA20);
		SET @GA21 = [dbo].[sx_pf_pProtectString] (@GA21);
		SET @GA22 = [dbo].[sx_pf_pProtectString] (@GA22);
		SET @GA23 = [dbo].[sx_pf_pProtectString] (@GA23);
		SET @GA24 = [dbo].[sx_pf_pProtectString] (@GA24);
		SET @GA25 = [dbo].[sx_pf_pProtectString] (@GA25);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID =  N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryID = @FactoryID AND ProductlineID = @ProductlineID AND ProductID = @ProductID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3.1 - If Product dont exists, create it from the Template			
		IF @ProductKey = 0
		BEGIN
			DECLARE @TemplateFactoryID AS NVARCHAR(255) = N'ZT';
			DECLARE @TemplateProductLineID AS NVARCHAR(255) = N'';
			DECLARE @TemplateProductID AS NVARCHAR (255) = N'';
			DECLARE @TemplateFactoryKey AS INT = 0;
			DECLARE @TemplateProductlineKey AS INT = 0;
			DECLARE @TemplateProductKey AS INT = 0;
			DECLARE @TemplateFactoryNameShort AS NVARCHAR(255) = N'';
			DECLARE @TemplateProductlineNameShort AS NVARCHAR(255) = N'';
			DECLARE @TemplateProductNameShort AS NVARCHAR(255) = N'';

			-- Determine Templateproduct - it will be searched only in Factory ZT
			SELECT TOP 1 
				@TemplateProductID = ProductID, 
				@TemplateProductLineID = ProductLineID 
			FROM [dbo].[sx_pf_dProducts]
			WHERE FactoryID = @TemplateFactoryID AND Template = @Template;
			
			IF @TemplateProductID = N''	
			BEGIN
				SET @ResultCode = 404;
				RAISERROR('Template ProductID not found', 16, 10);
			END;

			-- Determine Template Keys
			SELECT @TemplateFactoryKey = FactoryKey, @TemplateFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TemplateFactoryID;
			SELECT TOP 1 @TemplateProductLineKey = ProductLineKey, @TemplateProductlineNameShort = NameShort FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TemplateFactoryKey AND ProductlineID = @TemplateProductlineID;
			SELECT TOP 1 @TemplateProductKey = ProductKey, @TemplateProductNameShort = NameShort FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @TemplateFactoryKey AND ProductlineKey = @TemplateProductlineKey AND ProductID = @TemplateProductID;
			
			IF @TemplateFactoryKey = 0 OR @TemplateProductLineKey = 0 OR @TemplateProductKey = 0	
			BEGIN
				SET @ResultCode = 404;
				RAISERROR('Template keys not found', 16, 10);
			END;

			-- Copy Template Product		
			--dProducts

			DECLARE @ProductKeyTable AS TABLE (KeyNumber BIGINT);

			INSERT INTO [dbo].[sx_pf_dProducts] 
			OUTPUT INSERTED.ProductKey INTO @ProductKeyTable
			SELECT @ProductLineKey, @FactoryKey, @ProductID, @ProductlineID, @FactoryID,
				TimeType, @NameShort, NameLong, CommentUser,CommentDev, ResponsiblePerson, ImageName, [Status], Template, TemplateVersion,
				GlobalAttribute1, GlobalAttribute2, GlobalAttribute3, GlobalAttribute4, GlobalAttribute5, GlobalAttribute6, GlobalAttribute7,  
				GlobalAttribute8, GlobalAttribute9, GlobalAttribute10, GlobalAttribute11, GlobalAttribute12, GlobalAttribute13, GlobalAttribute14,  
				GlobalAttribute15, GlobalAttribute16, GlobalAttribute17, GlobalAttribute18, GlobalAttribute19, GlobalAttribute20, GlobalAttribute21,  
				GlobalAttribute22, GlobalAttribute23, GlobalAttribute24, GlobalAttribute25 
			FROM [dbo].[sx_pf_dProducts] 
			WHERE ProductKey = @TemplateProductKey;

			SET @EffectedRows += @@ROWCOUNT;
			SELECT TOP 1 @ProductKey = KeyNumber FROM @ProductKeyTable;

			--gProducts
			INSERT INTO [dbo].[sx_pf_gProducts] 
			SELECT @ProductKey, @ProductLineKey, @FactoryKey, @ProductID, @ProductlineID,
					@FactoryID, PropertyID, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
			FROM [dbo].[sx_pf_gProducts] 
			WHERE ProductKey = @TemplateProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dValueSeries
			INSERT INTO [dbo].[sx_pf_dValueSeries] 
			SELECT @ProductKey, @ProductLineKey, @FactoryKey, @ProductID, @ProductlineID,
				@FactoryID, ValueSeriesID, ValueSeriesNo, NameShort,NameLong,CommentUser,CommentDev,ImageName,[IsNumeric], VisibilityLevel, ValueSource, ValueListID, 
				ValueFormatID, Unit, Scale, Effect, EffectParameter
			FROM [dbo].[sx_pf_dValueSeries] 
			WHERE ProductKey = @TemplateProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dTime
			INSERT INTO [dbo].[sx_pf_dTime] 
			SELECT @ProductKey, @ProductLineKey, @FactoryKey, @ProductID, @ProductlineID,
				@FactoryID, TimeID
			FROM [dbo].[sx_pf_dTime] 
			WHERE ProductKey = @TemplateProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--fValues
			;WITH VS AS (SELECT ValueSeriesKey, ProductKey, ValueSeriesID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey)
			INSERT INTO [dbo].[sx_pf_fValues] 
			SELECT VS.ValueSeriesKey, @ProductKey, @ProductLineKey, @FactoryKey, @ProductID, 
				@ProductlineID, @FactoryID, fV.ValueSeriesID, TimeID, ValueFormula, ValueInt, ValueText, ValueComment
			FROM [dbo].[sx_pf_fValues] fV LEFT JOIN VS ON VS.ValueSeriesID= fV.ValueSeriesID 
			WHERE fV.ProductKey = @TemplateProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--fStatements - create copy informations
			INSERT INTO [dbo].[sx_pf_fStatements] 
			SELECT @ProductKey, @ProductLineKey, @FactoryKey, @ProductID, @ProductlineID, @FactoryID, 
				N'COPY' AS ActionType,
				N'Product produced as a copy of Factory <' + @TemplateFactoryID + N'>"' + @TemplateFactoryNameShort +
					N'"/ ProductLine <' + @TemplateProductlineID + N'>"' + @TemplateProductLineNameShort +
					N'"/ Product <' + @TemplateProductID + N'>"' + @TemplateProductNameShort + N'"' AS [Statement],
				@TransactUsername AS UserName,
				N'' AS PCName, 
				N'' AS ProcessorCode, 
				N'' AS IPAddresses,
				CAST(CONVERT(NVARCHAR(10),GETDATE(),112) as BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5),':',N'') AS BIGINT) AS [Timestamp],
				0 AS IsDeleted, 
				0 AS IsResolved;

			SET @EffectedRows += @@ROWCOUNT;	
			SET @ResultCode = 201
		END;
			
		-- STEP 3.2 - Update the Product with the commited attributes
		UPDATE [dbo].[sx_pf_dProducts] 
		SET TimeType = IIF(@Template = N'<#NV>', TimeType, RIGHT(@Template, 2))					 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	
			, NameShort = IIF(@NameShort = N'<#NV>', NameShort, @NameShort)
			, NameLong = IIF(@NameLong = N'<#NV>', NameLong, @NameLong)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, ResponsiblePerson = IIF(@ResponsiblePerson = N'<#NV>', ResponsiblePerson, @ResponsiblePerson)
			, ImageName = IIF(@ImageName = N'<#NV>', ImageName, @ImageName)
			, [Status] = IIF(@Status = N'<#NV>', [Status], @Status)
			, Template = IIF(@Template = N'<#NV>', Template, @Template)
			, TemplateVersion = IIF(@TemplateVersion = N'<#NV>', TemplateVersion, @TemplateVersion)
			, GlobalAttribute1 = IIF(@GA1 = N'<#NV>', GlobalAttribute1, @GA1), GlobalAttribute2 = IIF(@GA2 = N'<#NV>', GlobalAttribute2, @GA2)	
			, GlobalAttribute3 = IIF(@GA3 = N'<#NV>', GlobalAttribute3, @GA3), GlobalAttribute4 = IIF(@GA4 = N'<#NV>', GlobalAttribute4, @GA4)	
			, GlobalAttribute5 = IIF(@GA5 = N'<#NV>', GlobalAttribute5, @GA5), GlobalAttribute6 = IIF(@GA6 = N'<#NV>', GlobalAttribute6, @GA6)	
			, GlobalAttribute7 = IIF(@GA7 = N'<#NV>', GlobalAttribute7, @GA7), GlobalAttribute8 = IIF(@GA8 = N'<#NV>', GlobalAttribute8, @GA8)	
			, GlobalAttribute9 = IIF(@GA9 = N'<#NV>', GlobalAttribute9, @GA9), GlobalAttribute10 = IIF(@GA10 = N'<#NV>', GlobalAttribute10, @GA10)
			, GlobalAttribute11 = IIF(@GA11 = N'<#NV>', GlobalAttribute11, @GA11), GlobalAttribute12 = IIF(@GA12 = N'<#NV>', GlobalAttribute12, @GA12)
			, GlobalAttribute13 = IIF(@GA13 = N'<#NV>', GlobalAttribute13, @GA13), GlobalAttribute14 = IIF(@GA14 = N'<#NV>', GlobalAttribute14, @GA14)
			, GlobalAttribute15 = IIF(@GA15 = N'<#NV>', GlobalAttribute15, @GA15), GlobalAttribute16 = IIF(@GA16 = N'<#NV>', GlobalAttribute16, @GA16)
			, GlobalAttribute17 = IIF(@GA17 = N'<#NV>', GlobalAttribute17, @GA17), GlobalAttribute18 = IIF(@GA18 = N'<#NV>', GlobalAttribute18, @GA18)
			, GlobalAttribute19 = IIF(@GA19 = N'<#NV>', GlobalAttribute19, @GA19), GlobalAttribute20 = IIF(@GA20 = N'<#NV>', GlobalAttribute20, @GA20)
			, GlobalAttribute21 = IIF(@GA21 = N'<#NV>', GlobalAttribute21, @GA21), GlobalAttribute22 = IIF(@GA22 = N'<#NV>', GlobalAttribute22, @GA22)
			, GlobalAttribute23 = IIF(@GA23 = N'<#NV>', GlobalAttribute23, @GA23), GlobalAttribute24 = IIF(@GA24 = N'<#NV>', GlobalAttribute24, @GA24)
			, GlobalAttribute25 = IIF(@GA25 = N'<#NV>', GlobalAttribute25, @GA25)	
		FROM [dbo].[sx_pf_dProducts]
		WHERE ProductKey = @ProductKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Product] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Product] TO pf_PlanningFactoryService;
GO
/*
POST Operation for all values of the ProductDataTable
The method can be switched between incremental POST and full POST

Dependencies:
	- Functions: 
		- sx_pf_pProtectValueArray
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight 
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID / ValueSeriesID / TimeID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / Productline / Product keys => 404 Not Found
5. If ValueSeriesID not exists in [sx_pf_dValueSeries] for this ProductKey => 403 Forbidden
6. Product updated => 200 OK

Test case 1 - Incremental Sended
1. One Value for an existing Value must replace them
2. One Value for an not exiting Value must create it
3. If all Parameter are posted empty, the value is deleted
4. If one or more of the parameter are sended with <#NV> there Value is replaced with the existing value (or nothing if it exists not)

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = 'U2'
DECLARE @FactoryID nvarchar(255) = 'ZT'
DECLARE @IsIncrementalValuesFlag INT = 1

-- 3 Values with comments
   DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '[(''K2'',20160115,''=IF(H25=4,3,2.1)'',''6'',''HaseTextValue'',''HaseComment'')],[(''K2'',20160215,''=IF(H25=4,3,2)'',''555'',''HaseTextValue'',''HaseComment2'')],[(''E1'',20160515,'''','''',''Text'',''Comment'')]'

-- Delete the three values
-- DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '[(''K2'',20160115,'''','''','''',''HaseComment'')],[(''K2'',20160215,'''','''','''',''HaseComment2'')],[(''E1'',20160515,'''','''','''','''')]'

-- Write one Value of the three to Series No 1
-- DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '[(''K1'',20160115,''=IF(H25=4,3,2.1)'',''6'',''HaseTextValue'',''HaseComment'')],[(''K2'',20160215,''=IF(H25=4,3,2)'',''555'',''HaseTextValue'',''HaseComment2'')],[(''E1'',20160515,'''','''',''Text'',''Comment'')]'

-- Delete the three values again
-- DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '[(''K1'',20160115,'''','''','''',''HaseComment'')],[(''K2'',20160215,'''','''','''',''HaseComment2'')],[(''E1'',20160515,'''','''','''','''')]'

-- Write one Value of the three to Series No 1
-- DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '[(''K1'',20160115,''=IF(H25=4,3,2.1)'',''6'',''HaseTextValue'',''HaseComment'')],[(''K2'',20160215,''=IF(H25=4,3,2)'',''555'',''HaseTextValue'',''HaseComment2'')],[(''E1'',20160515,'''','''',''Text'',''Comment'')]'

-- Send an <#NV> Value for an existing numeric and an Text Value and delete one
-- DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '[(''K1'',20160115,'''',''<#NV>'','''',''HaseComment'')],[(''K2'',20160215,'''','''','''',''HaseComment2'')],[(''E1'',20160515,'''','''',''<#NV>'','''')]'

EXECUTE @RC = [sx_pf_POST_ProductDataTableValues] @Username,@ProductID,@ProductLineID,@FactoryID,@IsIncrementalValuesFlag,@ValuesInBracketsCommaSeparated
PRINT @RC
 
Test case 2 - all values in a Value Series of Products:

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'
DECLARE @FactoryID nvarchar(255) = 'U'
DECLARE @IsIncrementalValuesFlag INT = 0
DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = ''
DECLARE @start_time DATETIME

-- Generate fictive values for all TimeIDs of Products
SELECT @ValuesInBracketsCommaSeparated = @ValuesInBracketsCommaSeparated + '[(''' + dVS2.ValueSeriesID + ''',' + CAST(TimeID AS nvarchar(255)) +',''=A2'',1000,''Hase'',''Kommentar'')],' 
FROM 
	sx_pf_fValues fV LEFT JOIN 
	sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey LEFT JOIN
		(SELECT ValueSeriesID FROM sx_pf_dValueSeries WHERE FactoryID =  @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID GROUP BY ValueSeriesID) dVS2
		ON 1=1 
WHERE fV.FactoryID =  @FactoryID AND fV.ProductLineID = @ProductLineID AND fV.ProductID = @ProductID AND dVS.ValueSeriesNo = 1

SET @ValuesInBracketsCommaSeparated = Left(@ValuesInBracketsCommaSeparated,Len(@ValuesInBracketsCommaSeparated) -1)
PRINT @ValuesInBracketsCommaSeparated
SET @start_time = GETDATE()

EXECUTE @RC = [sx_pf_POST_ProductDataTableValues] @Username,@ProductID,@ProductLineID,@FactoryID,@IsIncrementalValuesFlag,@ValuesInBracketsCommaSeparated
PRINT @RC
SELECT RTRIM(CAST(DATEDIFF(MS, @start_time, GETDATE()) AS CHAR(10))) AS 'TimeTaken'
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ProductDataTableValues]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ProductDataTableValues]
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ProductDataTableValues]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@IsIncrementalValuesFlag AS INT,
	@ValuesInBracketsCommaSeparated AS NVARCHAR(MAX) 
/*
@ValuesInBracketsCommaSeparated format is: (ValueSeriesID,TimeID,Formula,Value,ValueText,ValueComment),(ValueSeriesIDTimeID,Formula,Value,ValueText,ValueComment)

if you check this in SQL Server Profiler, every String must have two inverted commas, the whole Parameter must have Single inverted comma
this must show profiler: '[(''ValueSeriesID'',TimeID,''Formula'',''ValueInt'',''ValueText'',''ValueComment'')],[(''ValueSeriesID'',TimeID,''Formula'',''ValueInt'',''ValueText'',''ValueComment'')]'

if you check this in table sx_pf_API_Log, every String must have two inverted comma, whole Parameter String has one inverted comma
this must show Log: '[(''ValueSeriesID'',TimeID,''Formula'',''ValueInt'',''ValueText'',''ValueComment'')],[(''ValueSeriesID'',TimeID,''Formula'',''ValueInt'',''ValueText'',''ValueComment'')]'
*/
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSeriesKey AS INT = 0;
	DECLARE @RightCode AS INT = 501;
	DECLARE @Right as NVARCHAR (255) = N'';
	DECLARE @ValueSeriesNo1ID NVARCHAR (255) = N'';
	DECLARE @ValueSeriesNo1Key AS BIGINT = 0;

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''','+ ISNULL(CAST(@IsIncrementalValuesFlag AS NVARCHAR(255)), N'NULL')
		+ N','''+ ISNULL(REPLACE(@ValuesInBracketsCommaSeparated, N'''', N''''''), N'NULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution
	-- SET Debug Flag for debugging
	DECLARE @DebugFlag AS INT = 0			
	/*
		--Use for debugging
		SELECT * FROM ##Debug_ValuesInBracketsReceived 
		SELECT * FROM ##Debug_ValueMergeTableFilled ORDER BY ValueSeriesNo,TimeID
		SELECT * FROM ##Debug_ValueMergeTableBeforeTransmissions ORDER BY ValueSeriesNo,TimeID
	*/

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @IsIncrementalValuesFlag IS NULL SET @IsIncrementalValuesFlag = 0;
	IF @ValuesInBracketsCommaSeparated IS NULL SET @ValuesInBracketsCommaSeparated = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ValuesInBracketsCommaSeparated = [dbo].[sx_pf_pProtectValueArray] (@ValuesInBracketsCommaSeparated);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey =  @ProductLineKey AND ProductID = @ProductID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3.1 - Load the current values of the product into the ValueMergeTable
		CREATE TABLE #ValueMergeTable ( 
			ValueSeriesKey BIGINT, ValueSeriesID NVARCHAR(255)  COLLATE DATABASE_DEFAULT, ValueSeriesNo INT, ValueKey BIGINT, TimeID NVARCHAR(10)  COLLATE DATABASE_DEFAULT,
			ValueFormula NVARCHAR(MAX) COLLATE DATABASE_DEFAULT, ValueInt NVARCHAR(255) COLLATE DATABASE_DEFAULT, ValueText NVARCHAR(MAX) COLLATE DATABASE_DEFAULT,
			ValueComment NVARCHAR(MAX) COLLATE DATABASE_DEFAULT, [IsNumeric] INT, IsFormula INT, ProcessCode NVARCHAR(20) COLLATE DATABASE_DEFAULT, DocuCode NVARCHAR(20) COLLATE DATABASE_DEFAULT
			, ID INT NOT NULL IDENTITY(1,1), UNIQUE CLUSTERED (ValueSeriesID, ID));

		INSERT INTO #ValueMergeTable
			SELECT 0, ValueSeriesID, 0, ValueKey, TimeID, ValueFormula, ValueInt, ValueText, ValueComment, 0, 0, N'OLD VALUES',N'NONE' 
			FROM sx_pf_fValues 
			WHERE ProductKey = @ProductKey;																					

		CREATE TABLE #Header (ValueSeriesKey BIGINT, ValueSeriesID NVARCHAR(255) COLLATE DATABASE_DEFAULT, ValueSeriesNo INT, [IsNumeric] INT, IsFormula INT
			, UNIQUE CLUSTERED (ValueSeriesID, ValueSeriesKey, ValueSeriesNo, [IsNumeric], IsFormula));
			
		INSERT INTO #Header
		SELECT ValueSeriesKey, ValueSeriesID, ValueSeriesNo, [IsNumeric], IIF(ValueSource IN (N'XLS',N'XLS-Strict'), 1, 0) AS IsFormula 
		FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey;

		-- STEP 3.2 - Store Timeline
		CREATE TABLE #Timeline (TimeID BIGINT UNIQUE CLUSTERED);

		INSERT INTO #Timeline
		SELECT TimeID
		FROM [dbo].[sx_pf_dTime] WHERE ProductKey = @ProductKey;

		SELECT @ValueSeriesNo1Key = ValueSeriesKey, @ValueSeriesNo1ID = ValueSeriesID FROM #Header WHERE ValueSeriesNo = 1;

		-- STEP 3.3 - Check for count of delimiter in Array
		DECLARE @OpenDelimetersCount INT = 0;
		DECLARE @DelimetersIndex INT = CHARINDEX(N'[(', @ValuesInBracketsCommaSeparated);

		WHILE (@DelimetersIndex > 0) BEGIN
			SET @OpenDelimetersCount += 1;
			SET @DelimetersIndex = CHARINDEX(N'[(', @ValuesInBracketsCommaSeparated, @DelimetersIndex + 1);
		END;
				
		IF @OpenDelimetersCount = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('No delimiters found in @ValuesInBracketsCommaSeparated', 16, 10);
		END;

		SET @DelimetersIndex = CHARINDEX(N')]', @ValuesInBracketsCommaSeparated);

		WHILE (@DelimetersIndex > 0) BEGIN
			SET @OpenDelimetersCount -= 1;
			SET @DelimetersIndex = CHARINDEX(N')]', @ValuesInBracketsCommaSeparated, @DelimetersIndex + 1);
		END;

		IF @OpenDelimetersCount <> 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Invalid count of delimiter in @ValuesInBracketsCommaSeparated', 16, 10);
		END;

		-- STEP 3.4 - Splitt the Array with the new values for the Product to a temporary table #######################################################################################################################
		-- cut leading/following brackets and ' from ValueSeriesID
		SET @ValuesInBracketsCommaSeparated = LEFT(@ValuesInBracketsCommaSeparated,LEN(@ValuesInBracketsCommaSeparated)-2);
		SET @ValuesInBracketsCommaSeparated = Right(@ValuesInBracketsCommaSeparated,LEN(@ValuesInBracketsCommaSeparated)-2);

		CREATE TABLE #Values1  (txtValuesPipe NVARCHAR(MAX) COLLATE DATABASE_DEFAULT)
		CREATE TABLE #Values2  (ValueSeriesID NVARCHAR(255) COLLATE DATABASE_DEFAULT, txtValuesPipe NVARCHAR(MAX) COLLATE DATABASE_DEFAULT)
		CREATE TABLE #Values3  (ValueSeriesID NVARCHAR(255) COLLATE DATABASE_DEFAULT, TimeID NVARCHAR(10) COLLATE DATABASE_DEFAULT, txtValuesPipe NVARCHAR(MAX) COLLATE DATABASE_DEFAULT)
		CREATE TABLE #Values4  (ValueSeriesID NVARCHAR(255) COLLATE DATABASE_DEFAULT, TimeID NVARCHAR(10) COLLATE DATABASE_DEFAULT, ValueFormula NVARCHAR(MAX) COLLATE DATABASE_DEFAULT, txtValuesPipe NVARCHAR(MAX) COLLATE DATABASE_DEFAULT)
		CREATE TABLE #Values5  (ValueSeriesID NVARCHAR(255) COLLATE DATABASE_DEFAULT, TimeID NVARCHAR(10) COLLATE DATABASE_DEFAULT, ValueFormula NVARCHAR(MAX) COLLATE DATABASE_DEFAULT, ValueInt NVARCHAR(255) COLLATE DATABASE_DEFAULT, txtValuesPipe NVARCHAR(MAX) COLLATE DATABASE_DEFAULT)
		CREATE TABLE #Values6  (ValueSeriesID NVARCHAR(255) COLLATE DATABASE_DEFAULT, TimeID NVARCHAR(10) COLLATE DATABASE_DEFAULT, ValueFormula NVARCHAR(MAX) COLLATE DATABASE_DEFAULT, ValueInt NVARCHAR(255) COLLATE DATABASE_DEFAULT, ValueText NVARCHAR(MAX) COLLATE DATABASE_DEFAULT, ValueComment NVARCHAR(MAX) COLLATE DATABASE_DEFAULT)

		-- Split String into Rows
		INSERT INTO #Values1 
			SELECT REPLACE(REPLACE(txtValues,N',''',N'|'''),N''',',N'''|') FROM [dbo].sx_pf_PivotStringIntoTable(@ValuesInBracketsCommaSeparated, N')],[(');

		-- Split one column into two Columns (separate ValueSeriesID)
		INSERT INTO #Values2
			SELECT  
				 REPLACE(LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 2),N'''','')
				,Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe))
			FROM #Values1;

		-- Split last columns once more (separate TimeID)
		INSERT INTO #Values3
			SELECT  
				 ValueSeriesID
				,LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 1) 
				,Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe)-1)
			FROM #Values2;
		
		-- Split last columns once more (separate ValueFormula)
		INSERT INTO #Values4
			SELECT  
				 ValueSeriesID
				,TimeID
				,LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 2) 
				,Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe)-1)
			FROM #Values3;

		-- Split last columns once more (separate ValueInt)
		INSERT INTO #Values5
			SELECT
				 ValueSeriesID  
				,TimeID
				,ValueFormula
				,LEFT(txtValuesPipe, CHARINDEX('|', txtValuesPipe) - 2) AS ValueInt
				,Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX('|', txtValuesPipe)-1)
			FROM #Values4;

		-- Split last columns once more (Separate ValueText and ValueComment)
		INSERT INTO #Values6
			SELECT 
				 ValueSeriesID 
				,TimeID
				,ValueFormula
				,ValueInt
				,LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 2) 
				,Left(Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe)-1),LEN(Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe)-1))-1)
			FROM #Values5;

		IF @DebugFlag = 1 
		BEGIN
			IF OBJECT_ID('tempdb..##Debug_ValuesInBracketsReceived') IS NOT NULL DROP TABLE ##Debug_ValuesInBracketsReceived;
			SELECT * INTO ##Debug_ValuesInBracketsReceived FROM #Values6;
		END;

		-- STEP 3.5 - UNION both temporary tables #######################################################################################################################

		INSERT INTO #ValueMergeTable
			SELECT 
				 0 AS ValueSeriesKey
				,ValueSeriesID
				,0 AS ValueSeriesNo
				,0 AS ValueKey
				,TimeID
				,ValueFormula
				,ValueInt
				,ValueText
				,ValueComment
				,0 AS [IsNumeric]
				,0 AS IsFormula
				,N'SENDED VALUES'
				,N'NONE'
			FROM #Values6;

		-- Add the header informations to the values
		UPDATE VMT 
		SET	 VMT.ValueSeriesNo = H.ValueSeriesNo
			,VMT.ValueSeriesKey = H.ValueSeriesKey
			,VMT.[IsNumeric] = H.[IsNumeric]
			,VMT.IsFormula = H.IsFormula 
		FROM #ValueMergeTable VMT, #Header H WHERE VMT.ValueSeriesID = H.ValueSeriesID

		IF EXISTS(SELECT 1 FROM #ValueMergeTable WHERE ValueSeriesKey = 0)
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('ValueSeriesID not found', 16, 10);
		END;

		-- STEP 3.6 - Prepare the ValueMergeTable #######################################################################################################################	
		-- FLAG OLD Values the user want to delete in Case of Numeric Series without formula
		UPDATE #ValueMergeTable 
		SET ProcessCode = N'OLD VALUES TO DELETE' 
		WHERE ProcessCode = N'OLD VALUES' AND [IsNumeric] = 1 AND IsFormula = 0 
			 AND ValueSeriesID + N'_' + TimeID IN 
			(SELECT ValueSeriesID + N'_' + TimeID FROM #ValueMergeTable WHERE ProcessCode = N'SENDED VALUES' AND
					(ValueInt = N'0' OR ValueInt = N''));

		-- FLAG OLD Values the user want to delete in Case of Numeric Series with formula
		UPDATE #ValueMergeTable 
		SET ProcessCode = N'OLD VALUES TO DELETE' 
		WHERE ProcessCode = N'OLD VALUES' AND [IsNumeric] = 1 AND IsFormula = 1  
			AND ValueSeriesID + N'_' + TimeID IN 
			(SELECT ValueSeriesID + N'_' + TimeID FROM #ValueMergeTable WHERE ProcessCode = N'SENDED VALUES' AND
					ValueFormula = N'' AND (ValueInt = N'0' OR ValueInt = N''));

		-- FLAG OLD Values the user want to delete in Case of NON-Numeric Series without formula
		UPDATE #ValueMergeTable 
		SET ProcessCode = N'OLD VALUES TO DELETE' 
		WHERE ProcessCode = N'OLD VALUES' AND [IsNumeric] = 0 AND IsFormula = 0  
			AND ValueSeriesID + N'_' + TimeID IN 
			(SELECT ValueSeriesID + N'_' + TimeID FROM #ValueMergeTable WHERE ProcessCode = N'SENDED VALUES' AND ValueText = N'' );

		-- FLAG OLD Values the user want to delete in Case of NON-Numeric Series with formula
		UPDATE #ValueMergeTable 
		SET ProcessCode = N'OLD VALUES TO DELETE' 
		WHERE ProcessCode = N'OLD VALUES' AND [IsNumeric] = 0 AND IsFormula = 1 
			 AND ValueSeriesID + N'_' + TimeID IN 
			(SELECT ValueSeriesID + N'_' + TimeID FROM #ValueMergeTable WHERE ProcessCode = N'SENDED VALUES' AND
					ValueText = N'' AND ValueFormula = N'');

		-- Debugging Output
		IF @DebugFlag = 1 
			BEGIN
				IF OBJECT_ID('tempdb..##Debug_ValueMergeTableFilled') IS NOT NULL DROP TABLE ##Debug_ValueMergeTableFilled;
				SELECT * INTO ##Debug_ValueMergeTableFilled FROM #ValueMergeTable;
			END;

		-- Delete Implicit sended periods (dont exit in current Product)
		DELETE FROM #ValueMergeTable WHERE TimeID NOT IN (SELECT TimeID FROM #Timeline);


		-- STEP 3.7 - Handle VMT #######################################################################################################################

		-- Determine Documentation entrys

			-- NEW is a Value which is not contained in existing Values
			UPDATE #ValueMergeTable 
			SET DocuCode = N'NEW VALUE'
			WHERE ProcessCode = N'SENDED VALUES' AND DocuCode = N'NONE' AND
				 ValueSeriesID + N'_' + CAST(TimeID AS NVARCHAR(10)) NOT IN 
						(SELECT ValueSeriesID + N'_' + CAST(TimeID AS NVARCHAR(10))
						FROM  #ValueMergeTable WHERE ProcessCode = N'OLD VALUES'); 

			-- CHANGED is a Value which is contained in existing Values
			UPDATE #ValueMergeTable 
			SET DocuCode = N'CHANGED VALUE'
			WHERE ProcessCode = N'SENDED VALUES' AND DocuCode = N'NONE' AND
				 ValueSeriesID + N'_' + CAST(TimeID AS NVARCHAR(10)) IN 
						(SELECT ValueSeriesID + N'_' + CAST(TimeID AS NVARCHAR(10))
						FROM  #ValueMergeTable WHERE ProcessCode = N'OLD VALUES'); 

			-- TODO: 
			/* INSERT INTO sx_pf_AuditLog VALUES
				SELECT * FROM #ValueMergeTable WHERE 
					ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) IN 
					(
					SELECT
						ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) FROM #ValueMergeTable WHERE ProcessCode = 'SENDED VALUES' AND
						DocuCode != 'NONE'
					)
			*/

		-- Handle <#NV> Parameters - Replace them with the old Values (if exist !)

		UPDATE VMT 
		SET VMT.ValueInt = OV.ValueInt 
		FROM #ValueMergeTable VMT, (SELECT * FROM #ValueMergeTable WHERE ProcessCode IN (N'OLD VALUES', N'OLD VALUES TO DELETE')) OV
		WHERE VMT.ProcessCode = N'SENDED VALUES' 
			AND VMT.ValueInt LIKE N'<#NV>' 
			AND VMT.ValueSeriesID = OV.ValueSeriesID 
			AND VMT.TimeID = OV.TimeID;

		UPDATE VMT 
		SET VMT.ValueText = OV.ValueText
		FROM #ValueMergeTable VMT, (SELECT * FROM #ValueMergeTable WHERE ProcessCode IN (N'OLD VALUES', N'OLD VALUES TO DELETE')) OV
		WHERE VMT.ProcessCode = N'SENDED VALUES' 
			AND VMT.ValueText = N'<#NV>'
			AND VMT.ValueSeriesID = OV.ValueSeriesID 
			AND VMT.TimeID = OV.TimeID;

		UPDATE VMT 
		SET VMT.ValueFormula = OV.ValueFormula 
		FROM #ValueMergeTable VMT, (SELECT * FROM #ValueMergeTable WHERE ProcessCode IN (N'OLD VALUES', N'OLD VALUES TO DELETE')) OV
		WHERE VMT.ProcessCode = N'SENDED VALUES' 
			AND VMT.ValueFormula = N'<#NV>'
			AND VMT.ValueSeriesID = OV.ValueSeriesID
			AND VMT.TimeID = OV.TimeID;

		UPDATE VMT 
		SET VMT.ValueComment = OV.ValueComment 
		FROM #ValueMergeTable VMT, (SELECT * FROM #ValueMergeTable WHERE ProcessCode IN (N'OLD VALUES', N'OLD VALUES TO DELETE')) OV
		WHERE VMT.ProcessCode = N'SENDED VALUES' 
			AND VMT.ValueComment = N'<#NV>'
			AND VMT.ValueSeriesID = OV.ValueSeriesID
			AND VMT.TimeID = OV.TimeID;

		-- Handle <#NV> Parameter, where no old Values existed
		UPDATE #ValueMergeTable SET ValueInt = N'0' WHERE ValueInt = N'<#NV>' OR [IsNumeric] = 0;
		UPDATE #ValueMergeTable SET ValueText = N'' WHERE ValueText = N'<#NV>' OR [IsNumeric] = 1;
		UPDATE #ValueMergeTable SET ValueFormula = N'' WHERE ValueFormula = N'<#NV>' OR IsFormula = 0;
		UPDATE #ValueMergeTable SET ValueComment = N'' WHERE ValueComment = N'<#NV>';

		-- Debugging Output
		IF @DebugFlag = 1 
		BEGIN
			IF OBJECT_ID('tempdb..##Debug_ValueMergeTableBeforeTransmissions') IS NOT NULL DROP TABLE ##Debug_ValueMergeTableBeforeTransmissions;
			SELECT * INTO ##Debug_ValueMergeTableBeforeTransmissions FROM #ValueMergeTable;
		END

		-- STEP 3.8 - Save data
		IF @IsIncrementalValuesFlag <> 1 
		BEGIN
			-- CASE FULL transmission #########################################

			-- Delete all Values
			DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductKey = @ProductKey;
			
			SET @EffectedRows += @@ROWCOUNT;

			-- Insert all Values
			INSERT INTO [dbo].[sx_pf_fValues]
				SELECT 
					ValueSeriesKey
					,@ProductKey
					,@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductLineID
					,@FactoryID
					,ValueSeriesID
					,TimeID
					,ValueFormula
					,ValueInt
					,ValueText
					,ValueComment
				FROM #ValueMergeTable 
				WHERE ProcessCode IN (N'SENDED VALUES', N'PLACEHOLDER');
				
			SET @EffectedRows += @@ROWCOUNT;
		END
		ELSE
		BEGIN
			-- CASE INCREMENTAL Transmission - it also leads to a full delete and insert !! #########################################
			-- DELETE Values, which are sended to delete in OLD VALUES
			DELETE FROM #ValueMergeTable WHERE ProcessCode = N'OLD VALUES TO DELETE';

			-- DELETE Sended Values the user want to delete
			DELETE FROM #ValueMergeTable
			WHERE ProcessCode = N'SENDED VALUES' AND [IsNumeric] = 1 AND IsFormula = 0 AND (ValueInt = N'0' OR ValueInt = N'');

			DELETE FROM #ValueMergeTable 
			WHERE ProcessCode = N'SENDED VALUES' AND [IsNumeric] = 1 AND IsFormula = 1 AND (ValueInt = N'0' OR ValueInt = N'') AND ValueFormula = N'';

			DELETE FROM #ValueMergeTable 
			WHERE ProcessCode = N'SENDED VALUES' AND [IsNumeric] = 0 AND IsFormula = 0 AND ValueText = N'';

			DELETE FROM #ValueMergeTable 
			WHERE ProcessCode = N'SENDED VALUES' AND [IsNumeric] = 0 AND IsFormula = 1 AND ValueText = N'' AND ValueFormula = N'';
					 
			-- DELETE all Values
			DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductKey = @ProductKey;
			SET @EffectedRows += @@ROWCOUNT;

			-- Delete OLD VALUES which are new sended
			DELETE FROM #ValueMergeTable 
			WHERE ProcessCode = N'OLD VALUES'  
				AND ValueSeriesID + N'_' + CAST(TimeID AS NVARCHAR(10)) IN 
						(SELECT ValueSeriesID + N'_' + CAST(TimeID AS NVARCHAR(10)) FROM  #ValueMergeTable WHERE ProcessCode = N'SENDED VALUES');

			-- Insert all Values
			INSERT INTO [dbo].[sx_pf_fValues]
				SELECT 
					ValueSeriesKey
					,@ProductKey
					,@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductLineID
					,@FactoryID
					,ValueSeriesID
					,TimeID
					,ValueFormula
					,CAST(ValueInt AS BIGINT)
					,ValueText
					,ValueComment
				FROM #ValueMergeTable 
				WHERE ProcessCode IN (N'SENDED VALUES', N'OLD VALUES', N'PLACEHOLDER');
			
			SET @EffectedRows += @@ROWCOUNT;
		END;
			
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductDataTableValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductDataTableValues] TO pf_PlanningFactoryService;
GO
/*
POST Operation for one empty Product
Not existing Product will be created, existing gets an Update
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty
If product will have no TimeIDs, as it has no values
If product will have no ValueSeries, when created new 

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight 
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / ProductLine key => 404 Not Found
5. Don`t exist Template for new ProductID => 404 Not Found
6. Product created => 201 Created
7. Product updated => 200 OK

	DECLARE @RC int
	DECLARE  @Username AS NVARCHAR(255) = 'SQL'
	DECLARE  @ProductID AS NVARCHAR(255)='53'
	DECLARE  @ProductLineID AS NVARCHAR(255)='U'
	DECLARE  @FactoryID  AS NVARCHAR(255)='ZT'
	DECLARE  @TimeType AS NVARCHAR(255)='<#NV>'--'VM'
	DECLARE  @NameShort AS NVARCHAR(255)='Testproduct'
	DECLARE  @NameLong AS NVARCHAR(255)='3 test'
	DECLARE  @CommentUser AS NVARCHAR(255)='komment'
	DECLARE  @CommentDev AS NVARCHAR(255)='DEVKOmm'
	DECLARE  @ResponsiblePerson AS NVARCHAR(255)= 'RR'
	DECLARE  @ImageName AS NVARCHAR(255)='ImgName test'
	DECLARE  @Status AS NVARCHAR(255)='Aktiv'
	DECLARE  @Template AS NVARCHAR(255)='Test_VM'
	DECLARE  @TemplateVersion AS NVARCHAR(255)='4.0'
	DECLARE  @GA1 AS NVARCHAR(255) ='Wert für GA1'--'<#NV>'
	DECLARE  @GA2 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA3 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA4 AS NVARCHAR(255) ='rer'
	DECLARE  @GA5 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA6 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA7 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA8 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA9 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA10 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA11 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA12 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA13 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA14 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA15 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA16 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA17 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA18 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA19 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA20 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA21 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA22 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA23 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA24 AS NVARCHAR(255) ='<#NV>'
	DECLARE  @GA25 AS NVARCHAR(255) ='<#NV>'

-- TODO: Set parameter values here.

EXECUTE @RC = [sx_pf_POST_ProductEmpty] @Username,@ProductID,@ProductLineID,@FactoryID,@TimeType,@NameShort,@NameLong,@CommentUser,@CommentDev,@ResponsiblePerson,@ImageName
  ,@Status,@Template,@TemplateVersion,@GA1,@GA2,@GA3,@GA4,@GA5,@GA6,@GA7,@GA8,@GA9,@GA10,@GA11,@GA12,@GA13,@GA14,@GA15,@GA16,@GA17,@GA18,@GA19,@GA20,@GA21,@GA22,@GA23,@GA24,@GA25

PRINT @RC
*/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ProductEmpty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ProductEmpty];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ProductEmpty]
	@Username  AS NVARCHAR(255),
	@ProductID  AS NVARCHAR(255),
	@ProductLineID  AS NVARCHAR(255),
	@FactoryID  AS NVARCHAR(255),
	@TimeType  AS NVARCHAR(255),
	@NameShort  AS NVARCHAR(255),
	@NameLong  AS NVARCHAR(255),
	@CommentUser  AS NVARCHAR(255),
	@CommentDev  AS NVARCHAR(255),
	@ResponsiblePerson  AS NVARCHAR(255),
	@ImageName  AS NVARCHAR(255),
	@Status  AS NVARCHAR(255),
	@Template  AS NVARCHAR(255),
	@TemplateVersion  AS NVARCHAR(255),
	@GA1  AS NVARCHAR(255),
	@GA2  AS NVARCHAR(255),
	@GA3  AS NVARCHAR(255),
	@GA4  AS NVARCHAR(255),
	@GA5  AS NVARCHAR(255),
	@GA6  AS NVARCHAR(255),
	@GA7  AS NVARCHAR(255),
	@GA8  AS NVARCHAR(255),
	@GA9  AS NVARCHAR(255),
	@GA10  AS NVARCHAR(255),
	@GA11  AS NVARCHAR(255),
	@GA12  AS NVARCHAR(255),
	@GA13  AS NVARCHAR(255),
	@GA14  AS NVARCHAR(255),
	@GA15  AS NVARCHAR(255),
	@GA16  AS NVARCHAR(255),
	@GA17  AS NVARCHAR(255),
	@GA18  AS NVARCHAR(255),
	@GA19  AS NVARCHAR(255),
	@GA20  AS NVARCHAR(255),
	@GA21  AS NVARCHAR(255),
	@GA22  AS NVARCHAR(255),
	@GA23  AS NVARCHAR(255),
	@GA24  AS NVARCHAR(255),
	@GA25 AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
		
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@TimeType, N'NULL') + N''',''' + ISNULL(@NameShort, N'NULL') + N''',''' + ISNULL(@NameLong, N'NULL') +
							   N''',''' + ISNULL(@CommentUser, N'NULL') + N''',''' + ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@ResponsiblePerson, N'NULL') + N''',''' + ISNULL(@ImageName, N'NULL') + N''',''' + ISNULL(@Status, N'NULL') + N''',''' + ISNULL(@Template, N'NULL') + N''',''' + ISNULL(@TemplateVersion, N'NULL') +
							   N''',''' + ISNULL(@GA1, N'NULL') + N''',''' + ISNULL(@GA2, N'NULL') + N''',''' + ISNULL(@GA3, N'NULL') + N''',''' + ISNULL(@GA4, N'NULL') + N''',''' + ISNULL(@GA5, N'NULL') + N''',''' + ISNULL(@GA6, N'NULL') + N''',''' + ISNULL(@GA7, N'NULL') + N''',''' + ISNULL(@GA8, N'NULL') + N''',''' + ISNULL(@GA9, N'NULL') + N''',''' + ISNULL(@GA10, N'NULL') +
							   N''',''' + ISNULL(@GA11, N'NULL') + N''',''' + ISNULL(@GA12, N'NULL') + N''',''' + ISNULL(@GA13, N'NULL') + N''',''' + ISNULL(@GA14, N'NULL') + N''',''' + ISNULL(@GA15, N'NULL') + N''',''' + ISNULL(@GA16, N'NULL') + N''',''' + ISNULL(@GA17, N'NULL') + N''',''' + ISNULL(@GA18, N'NULL') + N''',''' + ISNULL(@GA19, N'NULL') + N''',''' + ISNULL(@GA20, N'NULL') +
							   N''',''' + ISNULL(@GA21, N'NULL') + N''',''' + ISNULL(@GA22, N'NULL') + N''',''' + ISNULL(@GA23, N'NULL') + N''',''' + ISNULL(@GA24, N'NULL') + N''',''' + ISNULL(@GA25, N'NULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @TimeType IS NULL SET @TimeType = N'';
	IF @NameShort IS NULL SET @NameShort = N'';
	IF @NameLong IS NULL SET @NameLong = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @ResponsiblePerson IS NULL SET @ResponsiblePerson = N'';
	IF @ImageName IS NULL SET @ImageName = N'';
	IF @Status IS NULL SET @Status = N'';
	IF @Template IS NULL SET @Template = N'';
	IF @TemplateVersion IS NULL SET @TemplateVersion = N'';
	IF @GA1 IS NULL SET @GA1 = N'';
	IF @GA2 IS NULL SET @GA2 = N'';
	IF @GA3 IS NULL SET @GA3 = N'';
	IF @GA4 IS NULL SET @GA4 = N'';
	IF @GA5 IS NULL SET @GA5 = N'';
	IF @GA6 IS NULL SET @GA6 = N'';
	IF @GA7 IS NULL SET @GA7 = N'';
	IF @GA8 IS NULL SET @GA8 = N'';
	IF @GA9 IS NULL SET @GA9 = N'';
	IF @GA10 IS NULL SET @GA10 = N'';
	IF @GA11 IS NULL SET @GA11 = N'';
	IF @GA12 IS NULL SET @GA12 = N'';
	IF @GA13 IS NULL SET @GA13 = N'';
	IF @GA14 IS NULL SET @GA14 = N'';
	IF @GA15 IS NULL SET @GA15 = N'';
	IF @GA16 IS NULL SET @GA16 = N'';
	IF @GA17 IS NULL SET @GA17 = N'';
	IF @GA18 IS NULL SET @GA18 = N'';
	IF @GA19 IS NULL SET @GA19 = N'';
	IF @GA20 IS NULL SET @GA20 = N'';
	IF @GA21 IS NULL SET @GA21 = N'';
	IF @GA22 IS NULL SET @GA22 = N'';
	IF @GA23 IS NULL SET @GA23 = N'';
	IF @GA24 IS NULL SET @GA24 = N'';
	IF @GA25 IS NULL SET @GA25 = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @TimeType = [dbo].[sx_pf_pProtectString] (@TimeType);
		SET @NameShort = [dbo].[sx_pf_pProtectString] (@NameShort);
		SET @NameLong = [dbo].[sx_pf_pProtectString] (@NameLong);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @ResponsiblePerson = [dbo].[sx_pf_pProtectString] (@ResponsiblePerson);
		SET @ImageName = [dbo].[sx_pf_pProtectString] (@ImageName);
		SET @Status = [dbo].[sx_pf_pProtectString] (@Status);
		SET @Template = [dbo].[sx_pf_pProtectString] (@Template);
		SET @TemplateVersion = [dbo].[sx_pf_pProtectString] (@TemplateVersion);
		SET @GA1 = [dbo].[sx_pf_pProtectString] (@GA1);
		SET @GA2 = [dbo].[sx_pf_pProtectString] (@GA2);
		SET @GA3 = [dbo].[sx_pf_pProtectString] (@GA3);
		SET @GA4 = [dbo].[sx_pf_pProtectString] (@GA4);
		SET @GA5 = [dbo].[sx_pf_pProtectString] (@GA5);
		SET @GA6 = [dbo].[sx_pf_pProtectString] (@GA6);
		SET @GA7 = [dbo].[sx_pf_pProtectString] (@GA7);
		SET @GA8 = [dbo].[sx_pf_pProtectString] (@GA8);
		SET @GA9 = [dbo].[sx_pf_pProtectString] (@GA9);
		SET @GA10 = [dbo].[sx_pf_pProtectString] (@GA10);
		SET @GA11 = [dbo].[sx_pf_pProtectString] (@GA11);
		SET @GA12 = [dbo].[sx_pf_pProtectString] (@GA12);
		SET @GA13 = [dbo].[sx_pf_pProtectString] (@GA13);
		SET @GA14 = [dbo].[sx_pf_pProtectString] (@GA14);
		SET @GA15 = [dbo].[sx_pf_pProtectString] (@GA15);
		SET @GA16 = [dbo].[sx_pf_pProtectString] (@GA16);
		SET @GA17 = [dbo].[sx_pf_pProtectString] (@GA17);
		SET @GA18 = [dbo].[sx_pf_pProtectString] (@GA18);
		SET @GA19 = [dbo].[sx_pf_pProtectString] (@GA19);
		SET @GA20 = [dbo].[sx_pf_pProtectString] (@GA20);
		SET @GA21 = [dbo].[sx_pf_pProtectString] (@GA21);
		SET @GA22 = [dbo].[sx_pf_pProtectString] (@GA22);
		SET @GA23 = [dbo].[sx_pf_pProtectString] (@GA23);
		SET @GA24 = [dbo].[sx_pf_pProtectString] (@GA24);
		SET @GA25 = [dbo].[sx_pf_pProtectString] (@GA25);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID =  N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryID = @FactoryID AND ProductlineID = @ProductlineID AND ProductID = @ProductID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
			
		-- STEP 3.1 - If Product dont exists, create a new row in dProducts	
		IF @ProductKey = 0
		BEGIN
			--Handle wrong time types, cut them to two characters
			IF LEN(@TimeType) > 2 
				SET @TimeType = LEFT(@TimeType,2);

			--Create dProducts
			DECLARE @ProductKeyTable AS TABLE (KeyNumber BIGINT);

			INSERT INTO [dbo].[sx_pf_dProducts]  
			OUTPUT Inserted.ProductKey 
			INTO @ProductKeyTable 
			VALUES (@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductlineID
					,@FactoryID
					,@TimeType
					,@NameShort
					,@NameLong
					,@CommentUser
					,@CommentDev
					,@ResponsiblePerson
					,@ImageName
					,@Status
					,@Template
					,@TemplateVersion
					,IIF(@GA1 = N'<#NV>', N'', @GA1)
					,IIF(@GA2 = N'<#NV>', N'', @GA2)
					,IIF(@GA3 = N'<#NV>', N'', @GA3)
					,IIF(@GA4 = N'<#NV>', N'', @GA4)
					,IIF(@GA5 = N'<#NV>', N'', @GA5)
					,IIF(@GA6 = N'<#NV>', N'', @GA6)
					,IIF(@GA7 = N'<#NV>', N'', @GA7)
					,IIF(@GA8 = N'<#NV>', N'', @GA8)
					,IIF(@GA9 = N'<#NV>', N'', @GA9)
					,IIF(@GA10 = N'<#NV>', N'', @GA10)
					,IIF(@GA11 = N'<#NV>', N'', @GA11)
					,IIF(@GA12 = N'<#NV>', N'', @GA12)
					,IIF(@GA13 = N'<#NV>', N'', @GA13)
					,IIF(@GA14 = N'<#NV>', N'', @GA14)
					,IIF(@GA15 = N'<#NV>', N'', @GA15)
					,IIF(@GA16 = N'<#NV>', N'', @GA16)
					,IIF(@GA17 = N'<#NV>', N'', @GA17)
					,IIF(@GA18 = N'<#NV>', N'', @GA18)
					,IIF(@GA19 = N'<#NV>', N'', @GA19)
					,IIF(@GA20 = N'<#NV>', N'', @GA20)
					,IIF(@GA21 = N'<#NV>', N'', @GA21)
					,IIF(@GA22 = N'<#NV>', N'', @GA22)
					,IIF(@GA23 = N'<#NV>', N'', @GA23)
					,IIF(@GA24 = N'<#NV>', N'', @GA24)
					,IIF(@GA25 = N'<#NV>', N'', @GA25));

			SET @EffectedRows += @@ROWCOUNT;

			SELECT @ProductKey = KeyNumber 
			FROM @ProductKeyTable;

			--fStatements - create copy  informations
			INSERT INTO [dbo].[sx_pf_fStatements]
			SELECT @ProductKey, @ProductLineKey, @FactoryKey, 
					@ProductID,  @ProductlineID, @FactoryID, 
					N'COPY' AS ActionType,
					N'Product imported by Single Product Import ' AS [Statement],
					@TransactUsername AS UserName,
					N'' AS PCName, 
					N'' AS ProcessorCode, 
					N'' AS IPAddresses,
					CAST(CONVERT(NVARCHAR(10),GETDATE(),112) as BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5),N':',N'') AS BIGINT) AS [Timestamp],
					0 AS IsDeleted, 
					0 AS IsResolved;

			SET @EffectedRows += @@ROWCOUNT;	
			SET @ResultCode = 201;
		END;
			
		-- STEP 3.2 - Update the Product with the commited attributes
		UPDATE sx_pf_dProducts 
		SET  
			 TimeType = IIF(@Template=N'<#NV>', TimeType, RIGHT(@Template, 2))					 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 		 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	
			,NameShort = IIF(@NameShort=N'<#NV>', NameShort, @NameShort)
			,NameLong = IIF(@NameLong=N'<#NV>', NameLong, @NameLong)
			,CommentUser = IIF(@CommentUser=N'<#NV>', CommentUser, @CommentUser)
			,CommentDev = IIF(@CommentDev=N'<#NV>', CommentDev, @CommentDev)
			,ResponsiblePerson = IIF(@ResponsiblePerson=N'<#NV>', ResponsiblePerson, @ResponsiblePerson)
			,ImageName = IIF(@ImageName=N'<#NV>', ImageName, @ImageName)
			,[Status] = IIF(@Status=N'<#NV>', [Status], @Status)
			,Template = IIF(@Template=N'<#NV>', Template, @Template)
			,TemplateVersion = IIF(@TemplateVersion=N'<#NV>', TemplateVersion, @TemplateVersion)
			,GlobalAttribute1 = IIF(@GA1=N'<#NV>', GlobalAttribute1, @GA1), GlobalAttribute2 = IIF(@GA2=N'<#NV>', GlobalAttribute2, @GA2)	
			,GlobalAttribute3 = IIF(@GA3=N'<#NV>', GlobalAttribute3, @GA3), GlobalAttribute4 = IIF(@GA4=N'<#NV>', GlobalAttribute4, @GA4)	
			,GlobalAttribute5 = IIF(@GA5=N'<#NV>', GlobalAttribute5, @GA5), GlobalAttribute6 = IIF(@GA6=N'<#NV>', GlobalAttribute6, @GA6)	
			,GlobalAttribute7 = IIF(@GA7=N'<#NV>', GlobalAttribute7, @GA7), GlobalAttribute8 = IIF(@GA8=N'<#NV>', GlobalAttribute8, @GA8)	
			,GlobalAttribute9 = IIF(@GA9=N'<#NV>', GlobalAttribute9, @GA9), GlobalAttribute10 = IIF(@GA10=N'<#NV>', GlobalAttribute10, @GA10)
			,GlobalAttribute11 = IIF(@GA11=N'<#NV>', GlobalAttribute11, @GA11), GlobalAttribute12 = IIF(@GA12=N'<#NV>', GlobalAttribute12, @GA12)
			,GlobalAttribute13 = IIF(@GA13=N'<#NV>', GlobalAttribute13, @GA13), GlobalAttribute14 = IIF(@GA14=N'<#NV>', GlobalAttribute14, @GA14)
			,GlobalAttribute15 = IIF(@GA15=N'<#NV>', GlobalAttribute15, @GA15), GlobalAttribute16 = IIF(@GA16=N'<#NV>', GlobalAttribute16, @GA16)
			,GlobalAttribute17 = IIF(@GA17=N'<#NV>', GlobalAttribute17, @GA17), GlobalAttribute18 = IIF(@GA18=N'<#NV>', GlobalAttribute18, @GA18)
			,GlobalAttribute19 = IIF(@GA19=N'<#NV>', GlobalAttribute19, @GA19), GlobalAttribute20 = IIF(@GA20=N'<#NV>', GlobalAttribute20, @GA20)
			,GlobalAttribute21 = IIF(@GA21=N'<#NV>', GlobalAttribute21, @GA21), GlobalAttribute22 = IIF(@GA22=N'<#NV>', GlobalAttribute22, @GA22)
			,GlobalAttribute23 = IIF(@GA23=N'<#NV>', GlobalAttribute23, @GA23), GlobalAttribute24 = IIF(@GA24=N'<#NV>', GlobalAttribute24, @GA24)
			,GlobalAttribute25 = IIF(@GA25=N'<#NV>', GlobalAttribute25, @GA25)	
		FROM [dbo].[sx_pf_dProducts]
		WHERE ProductKey = @ProductKey;

		SET @EffectedRows += @@ROWCOUNT;	

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductEmpty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductEmpty] TO pf_PlanningFactoryService;
GO
/*
POST Operation for ProductLine
Not existing ProductLine will be created, existing gets an Update
If attributes passed with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID  => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
3. Username does not have write access to Factory on Create => 401 Unauthorized
5. Non exists Factory / Productline keys => 404 Not Found
6. ProductLine created => 201 Created
7. ProductLine updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'ee'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @NameShort AS NVARCHAR(255) = ''
		DECLARE @NameLong AS NVARCHAR(255) = ''
		DECLARE @CommentUser AS NVARCHAR(255) = ''
		DECLARE @CommentDev AS NVARCHAR(255) = ''
		DECLARE @ResponsiblePerson AS NVARCHAR(255) = ''
		DECLARE @ImageName AS NVARCHAR(255) = ''
		DECLARE @DefaultTemplate AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource1 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias1 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource2 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias2 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource3 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias3 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource4 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias4 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource5 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias5 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource6 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias6 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource7 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias7 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource8 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias8 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource9 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias9 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource10 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias10 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource11 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias11 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource12 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias12 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource13 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias13 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource14 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias14 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource15 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias15 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource16 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias16 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource17 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias17 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource18 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias18 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource19 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias19 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource20 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias20 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource21 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias21 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource22 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias22 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource23 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias23 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource24 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias24 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeSource25 AS NVARCHAR(255) = ''
		DECLARE @GlobalAttributeAlias25 AS NVARCHAR(255) = ''

EXECUTE @RC = [sx_pf_POST_ProductLine] 	@Username,@ProductLineID,@FactoryID,@NameShort,@NameLong,@CommentUser,@CommentDev,@ResponsiblePerson,@ImageName,@DefaultTemplate,
		@GlobalAttributeSource1,@GlobalAttributeAlias1,@GlobalAttributeSource2,@GlobalAttributeAlias2,@GlobalAttributeSource3,@GlobalAttributeAlias3,@GlobalAttributeSource4,
		@GlobalAttributeAlias4,@GlobalAttributeSource5,@GlobalAttributeAlias5,@GlobalAttributeSource6,@GlobalAttributeAlias6,@GlobalAttributeSource7,@GlobalAttributeAlias7,
		@GlobalAttributeSource8,@GlobalAttributeAlias8,@GlobalAttributeSource9,@GlobalAttributeAlias9,@GlobalAttributeSource10,@GlobalAttributeAlias10,@GlobalAttributeSource11,
		@GlobalAttributeAlias11,@GlobalAttributeSource12,@GlobalAttributeAlias12,@GlobalAttributeSource13,@GlobalAttributeAlias13,@GlobalAttributeSource14,@GlobalAttributeAlias14,
		@GlobalAttributeSource15,@GlobalAttributeAlias15,@GlobalAttributeSource16,@GlobalAttributeAlias16,@GlobalAttributeSource17,@GlobalAttributeAlias17,@GlobalAttributeSource18,
		@GlobalAttributeAlias18,@GlobalAttributeSource19,@GlobalAttributeAlias19,@GlobalAttributeSource20,@GlobalAttributeAlias20,@GlobalAttributeSource21,@GlobalAttributeAlias21,
		@GlobalAttributeSource22,@GlobalAttributeAlias22,@GlobalAttributeSource23,@GlobalAttributeAlias23,@GlobalAttributeSource24,@GlobalAttributeAlias24,@GlobalAttributeSource25,
		@GlobalAttributeAlias25

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ProductLine]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ProductLine];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ProductLine]
	@Username AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@NameShort AS NVARCHAR(255),
	@NameLong AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@ResponsiblePerson AS NVARCHAR(255),
	@ImageName AS NVARCHAR(255),
	@DefaultTemplate AS NVARCHAR(255),
	@GlobalAttributeSource1 AS NVARCHAR(255),
	@GlobalAttributeAlias1 AS NVARCHAR(255),
	@GlobalAttributeSource2 AS NVARCHAR(255),
	@GlobalAttributeAlias2 AS NVARCHAR(255),
	@GlobalAttributeSource3 AS NVARCHAR(255),
	@GlobalAttributeAlias3 AS NVARCHAR(255),
	@GlobalAttributeSource4 AS NVARCHAR(255),
	@GlobalAttributeAlias4 AS NVARCHAR(255),
	@GlobalAttributeSource5 AS NVARCHAR(255),
	@GlobalAttributeAlias5 AS NVARCHAR(255),
	@GlobalAttributeSource6 AS NVARCHAR(255),
	@GlobalAttributeAlias6 AS NVARCHAR(255),
	@GlobalAttributeSource7 AS NVARCHAR(255),
	@GlobalAttributeAlias7 AS NVARCHAR(255),
	@GlobalAttributeSource8 AS NVARCHAR(255),
	@GlobalAttributeAlias8 AS NVARCHAR(255),
	@GlobalAttributeSource9 AS NVARCHAR(255),
	@GlobalAttributeAlias9 AS NVARCHAR(255),
	@GlobalAttributeSource10 AS NVARCHAR(255),
	@GlobalAttributeAlias10 AS NVARCHAR(255),
	@GlobalAttributeSource11 AS NVARCHAR(255),
	@GlobalAttributeAlias11 AS NVARCHAR(255),
	@GlobalAttributeSource12 AS NVARCHAR(255),
	@GlobalAttributeAlias12 AS NVARCHAR(255),
	@GlobalAttributeSource13 AS NVARCHAR(255),
	@GlobalAttributeAlias13 AS NVARCHAR(255),
	@GlobalAttributeSource14 AS NVARCHAR(255),
	@GlobalAttributeAlias14 AS NVARCHAR(255),
	@GlobalAttributeSource15 AS NVARCHAR(255),
	@GlobalAttributeAlias15 AS NVARCHAR(255),
	@GlobalAttributeSource16 AS NVARCHAR(255),
	@GlobalAttributeAlias16 AS NVARCHAR(255),
	@GlobalAttributeSource17 AS NVARCHAR(255),
	@GlobalAttributeAlias17 AS NVARCHAR(255),
	@GlobalAttributeSource18 AS NVARCHAR(255),
	@GlobalAttributeAlias18 AS NVARCHAR(255),
	@GlobalAttributeSource19 AS NVARCHAR(255),
	@GlobalAttributeAlias19 AS NVARCHAR(255),
	@GlobalAttributeSource20 AS NVARCHAR(255),
	@GlobalAttributeAlias20 AS NVARCHAR(255),
	@GlobalAttributeSource21 AS NVARCHAR(255),
	@GlobalAttributeAlias21 AS NVARCHAR(255),
	@GlobalAttributeSource22 AS NVARCHAR(255),
	@GlobalAttributeAlias22 AS NVARCHAR(255),
	@GlobalAttributeSource23 AS NVARCHAR(255),
	@GlobalAttributeAlias23 AS NVARCHAR(255),
	@GlobalAttributeSource24 AS NVARCHAR(255),
	@GlobalAttributeAlias24 AS NVARCHAR(255),
	@GlobalAttributeSource25 AS NVARCHAR(255),
	@GlobalAttributeAlias25 AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
		
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@NameShort, N'NULL') + N''',''' + ISNULL(@NameLong, N'NULL') + N''',''' + ISNULL(@CommentUser, N'NULL') + N''',''' + ISNULL(@CommentDev, N'NULL') 
		+ N''',''' + ISNULL(@ResponsiblePerson, N'NULL') + N''',''' + ISNULL(@ImageName, N'NULL') + N''',''' + ISNULL(@DefaultTemplate, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource1, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias1, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource2, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias2, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource3, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias3, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource4, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias4, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource5, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias5, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource6, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias6, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource7, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias7, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource8, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias8, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource9, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias9, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource10, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias10, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource11, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias11, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource12, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias12, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource13, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias13, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource14, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias14, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource15, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias15, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource16, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias16, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource17, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias17, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource18, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias18, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource19, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias19, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource20, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias20, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource21, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias21, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource22, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias22, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource23, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeAlias23, N'NULL') + N''',''' + ISNULL(@GlobalAttributeSource24, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias24, N'NULL') 
		+ N''',''' + ISNULL(@GlobalAttributeSource25, N'NULL') + N''',''' + ISNULL(@GlobalAttributeAlias25, N'NULL') + N'''';
 
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @NameShort IS NULL SET @NameShort = N'';
	IF @NameLong IS NULL SET @NameLong = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @ResponsiblePerson IS NULL SET @ResponsiblePerson = N'';
	IF @ImageName IS NULL SET @ImageName = N'';
	IF @DefaultTemplate IS NULL SET @DefaultTemplate = N'';
	IF @GlobalAttributeSource1 IS NULL SET @GlobalAttributeSource1 = N'';
	IF @GlobalAttributeAlias1 IS NULL SET @GlobalAttributeAlias1 = N'';
	IF @GlobalAttributeSource2 IS NULL SET @GlobalAttributeSource2 = N'';
	IF @GlobalAttributeAlias2 IS NULL SET @GlobalAttributeAlias2 = N'';
	IF @GlobalAttributeSource3 IS NULL SET @GlobalAttributeSource3 = N'';
	IF @GlobalAttributeAlias3 IS NULL SET @GlobalAttributeAlias3 = N'';
	IF @GlobalAttributeSource4 IS NULL SET @GlobalAttributeSource4 = N'';
	IF @GlobalAttributeAlias4 IS NULL SET @GlobalAttributeAlias4 = N'';
	IF @GlobalAttributeSource5 IS NULL SET @GlobalAttributeSource5 = N'';
	IF @GlobalAttributeAlias5 IS NULL SET @GlobalAttributeAlias5 = N'';
	IF @GlobalAttributeSource6 IS NULL SET @GlobalAttributeSource6 = N'';
	IF @GlobalAttributeAlias6 IS NULL SET @GlobalAttributeAlias6 = N'';
	IF @GlobalAttributeSource7 IS NULL SET @GlobalAttributeSource7 = N'';
	IF @GlobalAttributeAlias7 IS NULL SET @GlobalAttributeAlias7 = N'';
	IF @GlobalAttributeSource8 IS NULL SET @GlobalAttributeSource8 = N'';
	IF @GlobalAttributeAlias8 IS NULL SET @GlobalAttributeAlias8 = N'';
	IF @GlobalAttributeSource9 IS NULL SET @GlobalAttributeSource9 = N'';
	IF @GlobalAttributeAlias9 IS NULL SET @GlobalAttributeAlias9 = N'';
	IF @GlobalAttributeSource10 IS NULL SET @GlobalAttributeSource10 = N'';
	IF @GlobalAttributeAlias10 IS NULL SET @GlobalAttributeAlias10 = N'';
	IF @GlobalAttributeSource11 IS NULL SET @GlobalAttributeSource11 = N'';
	IF @GlobalAttributeAlias11 IS NULL SET @GlobalAttributeAlias11 = N'';
	IF @GlobalAttributeSource12 IS NULL SET @GlobalAttributeSource12 = N'';
	IF @GlobalAttributeAlias12 IS NULL SET @GlobalAttributeAlias12 = N'';
	IF @GlobalAttributeSource13 IS NULL SET @GlobalAttributeSource13 = N'';
	IF @GlobalAttributeAlias13 IS NULL SET @GlobalAttributeAlias13 = N'';
	IF @GlobalAttributeSource14 IS NULL SET @GlobalAttributeSource14 = N'';
	IF @GlobalAttributeAlias14 IS NULL SET @GlobalAttributeAlias14 = N'';
	IF @GlobalAttributeSource15 IS NULL SET @GlobalAttributeSource15 = N'';
	IF @GlobalAttributeAlias15 IS NULL SET @GlobalAttributeAlias15 = N'';
	IF @GlobalAttributeSource16 IS NULL SET @GlobalAttributeSource16 = N'';
	IF @GlobalAttributeAlias16 IS NULL SET @GlobalAttributeAlias16 = N'';
	IF @GlobalAttributeSource17 IS NULL SET @GlobalAttributeSource17 = N'';
	IF @GlobalAttributeAlias17 IS NULL SET @GlobalAttributeAlias17 = N'';
	IF @GlobalAttributeSource18 IS NULL SET @GlobalAttributeSource18 = N'';
	IF @GlobalAttributeAlias18 IS NULL SET @GlobalAttributeAlias18 = N'';
	IF @GlobalAttributeSource19 IS NULL SET @GlobalAttributeSource19 = N'';
	IF @GlobalAttributeAlias19 IS NULL SET @GlobalAttributeAlias19 = N'';
	IF @GlobalAttributeSource20 IS NULL SET @GlobalAttributeSource20 = N'';
	IF @GlobalAttributeAlias20 IS NULL SET @GlobalAttributeAlias20 = N'';
	IF @GlobalAttributeSource21 IS NULL SET @GlobalAttributeSource21 = N'';
	IF @GlobalAttributeAlias21 IS NULL SET @GlobalAttributeAlias21 = N'';
	IF @GlobalAttributeSource22 IS NULL SET @GlobalAttributeSource22 = N'';
	IF @GlobalAttributeAlias22 IS NULL SET @GlobalAttributeAlias22 = N'';
	IF @GlobalAttributeSource23 IS NULL SET @GlobalAttributeSource23 = N'';
	IF @GlobalAttributeAlias23 IS NULL SET @GlobalAttributeAlias23 = N'';
	IF @GlobalAttributeSource24 IS NULL SET @GlobalAttributeSource24 = N'';
	IF @GlobalAttributeAlias24 IS NULL SET @GlobalAttributeAlias24 = N'';
	IF @GlobalAttributeSource25 IS NULL SET @GlobalAttributeSource25 = N'';
	IF @GlobalAttributeAlias25 IS NULL SET @GlobalAttributeAlias25 = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
		
		-- STEP 0.2 - Protect input parameters	
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @NameShort = [dbo].[sx_pf_pProtectString] (@NameShort);
		SET @NameLong = [dbo].[sx_pf_pProtectString] (@NameLong);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @ResponsiblePerson = [dbo].[sx_pf_pProtectString] (@ResponsiblePerson);
		SET @ImageName = [dbo].[sx_pf_pProtectString] (@ImageName);
		SET @DefaultTemplate = [dbo].[sx_pf_pProtectString] (@DefaultTemplate);
		IF @GlobalAttributeSource1 !='<#NV>' SET @GlobalAttributeSource1 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource1)
		SET @GlobalAttributeAlias1 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias1);
		IF @GlobalAttributeSource2 !='<#NV>' SET @GlobalAttributeSource2 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource2)
		SET @GlobalAttributeAlias2 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias2);
		IF @GlobalAttributeSource3 !='<#NV>' SET @GlobalAttributeSource3 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource3)
		SET @GlobalAttributeAlias3 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias3);
		IF @GlobalAttributeSource4 !='<#NV>' SET @GlobalAttributeSource4 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource4)
		SET @GlobalAttributeAlias4 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias4);
		IF @GlobalAttributeSource5 !='<#NV>' SET @GlobalAttributeSource5 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource5)
		SET @GlobalAttributeAlias5 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias5);
		IF @GlobalAttributeSource6 !='<#NV>' SET @GlobalAttributeSource6 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource6)
		SET @GlobalAttributeAlias6 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias6);
		IF @GlobalAttributeSource7 !='<#NV>' SET @GlobalAttributeSource7 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource7)
		SET @GlobalAttributeAlias7 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias7);
		IF @GlobalAttributeSource8 !='<#NV>' SET @GlobalAttributeSource8 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource8)
		SET @GlobalAttributeAlias8 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias8);
		IF @GlobalAttributeSource9 !='<#NV>' SET @GlobalAttributeSource9 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource9)
		SET @GlobalAttributeAlias9 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias9);
		IF @GlobalAttributeSource10 !='<#NV>' SET @GlobalAttributeSource10 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource10)
		SET @GlobalAttributeAlias10 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias10);
		IF @GlobalAttributeSource11 !='<#NV>' SET @GlobalAttributeSource11 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource11)
		SET @GlobalAttributeAlias11 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias11);
		IF @GlobalAttributeSource12 !='<#NV>' SET @GlobalAttributeSource12 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource12)
		SET @GlobalAttributeAlias12 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias12);
		IF @GlobalAttributeSource13 !='<#NV>' SET @GlobalAttributeSource13 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource13)
		SET @GlobalAttributeAlias13 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias13);
		IF @GlobalAttributeSource14 !='<#NV>' SET @GlobalAttributeSource14 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource14)
		SET @GlobalAttributeAlias14 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias14);
		IF @GlobalAttributeSource15 !='<#NV>' SET @GlobalAttributeSource15 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource15)
		SET @GlobalAttributeAlias15 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias15);
		IF @GlobalAttributeSource16 !='<#NV>' SET @GlobalAttributeSource16 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource16)
		SET @GlobalAttributeAlias16 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias16);
		IF @GlobalAttributeSource17 !='<#NV>' SET @GlobalAttributeSource17 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource17)
		SET @GlobalAttributeAlias17 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias17);
		IF @GlobalAttributeSource18 !='<#NV>' SET @GlobalAttributeSource18 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource18)
		SET @GlobalAttributeAlias18 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias18);
		IF @GlobalAttributeSource19 !='<#NV>' SET @GlobalAttributeSource19 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource19)
		SET @GlobalAttributeAlias19 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias19);
		IF @GlobalAttributeSource20 !='<#NV>' SET @GlobalAttributeSource20 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource20)
		SET @GlobalAttributeAlias20 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias20);
		IF @GlobalAttributeSource21 !='<#NV>' SET @GlobalAttributeSource21 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource21)
		SET @GlobalAttributeAlias21 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias21);
		IF @GlobalAttributeSource22 !='<#NV>' SET @GlobalAttributeSource22 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource22)
		SET @GlobalAttributeAlias22 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias22);
		IF @GlobalAttributeSource23 !='<#NV>' SET @GlobalAttributeSource23 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource23)
		SET @GlobalAttributeAlias23 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias23);
		IF @GlobalAttributeSource24 !='<#NV>' SET @GlobalAttributeSource24 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource24)
		SET @GlobalAttributeAlias24 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias24);
		IF @GlobalAttributeSource25 !='<#NV>' SET @GlobalAttributeSource25 = [dbo].[sx_pf_pProtectID] (@GlobalAttributeSource25)
		SET @GlobalAttributeAlias25 = [dbo].[sx_pf_pProtectString] (@GlobalAttributeAlias25);

		IF @FactoryID = N'' OR @ProductLineID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;

		IF @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		IF @ProductLineKey = 0
			EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID
		ELSE
			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3.1 - If Product Line does not yet exist, it will be created in minimal configuration		
		IF @ProductLineKey = 0
		BEGIN

			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_dProductlines] (FactoryKey, ProductlineID, FactoryID, NameShort) 
			OUTPUT INSERTED.ProductLineKey INTO @Keys([Key]) 
			VALUES (@FactoryKey, @ProductLineID, @FactoryID, @NameShort);

			SELECT TOP 1 @ProductLineKey = [Key] FROM @Keys;
			
			SET @EffectedRows = 1;

			-- Standard properties in g-Table
			INSERT INTO sx_pf_gProductLines	(
				ProductLineKey
				,FactoryKey
				,ProductLineID
				,FactoryID
				,PropertyID
				,PropertyName
				,CommentUser
				,CommentDev
				,Unit
				,ValueText
				,ValueInt
				,Scale
				,IsROSystemproperty
				,FormatID)
			VALUES
				(@ProductLineKey, @FactoryKey, @ProductLineID, @FactoryID, 'PL01', 'IsInImportMode', 'Import into ProductLine is running', '', 'Integer', '', 0, 0, 1, '')
				,(@ProductLineKey, @FactoryKey, @ProductLineID, @FactoryID, 'PL02', 'FinancialYearStartMonth', 'In this Month, Financial Year starts', '', 'Integer', '', 1, 1, 0, '');

			SET @EffectedRows += @@ROWCOUNT;
			SET @Resultcode = 201;
		END;

		-- STEP 3.2 - Update values
		UPDATE [dbo].[sx_pf_dProductLines]
		SET NameShort = IIF(@NameShort = N'<#NV>', NameShort, @NameShort)
			, NameLong = IIF(@NameLong = N'<#NV>', NameLong, @NameLong)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, ResponsiblePerson = IIF(@ResponsiblePerson = N'<#NV>', ResponsiblePerson, @ResponsiblePerson)
			, ImageName = IIF(@ImageName = N'<#NV>', ImageName, @ImageName)
			, DefaultTemplate = IIF(@DefaultTemplate = N'<#NV>', DefaultTemplate, @DefaultTemplate)
			, GlobalAttributeSource1 = IIF(@GlobalAttributeSource1 = N'<#NV>', GlobalAttributeSource1, @GlobalAttributeSource1)
			, GlobalAttributeAlias1 = IIF(@GlobalAttributeAlias1 = N'<#NV>', GlobalAttributeAlias1, @GlobalAttributeAlias1)			
			, GlobalAttributeSource2 = IIF(@GlobalAttributeSource2 = N'<#NV>', GlobalAttributeSource2, @GlobalAttributeSource2)
			, GlobalAttributeAlias2 = IIF(@GlobalAttributeAlias2 = N'<#NV>', GlobalAttributeAlias2, @GlobalAttributeAlias2)
			, GlobalAttributeSource3 = IIF(@GlobalAttributeSource3 = N'<#NV>', GlobalAttributeSource3, @GlobalAttributeSource3)
			, GlobalAttributeAlias3 = IIF(@GlobalAttributeAlias3 = N'<#NV>', GlobalAttributeAlias3, @GlobalAttributeAlias3)
			, GlobalAttributeSource4 = IIF(@GlobalAttributeSource4 = N'<#NV>', GlobalAttributeSource4, @GlobalAttributeSource4)
			, GlobalAttributeAlias4 = IIF(@GlobalAttributeAlias4 = N'<#NV>', GlobalAttributeAlias4, @GlobalAttributeAlias4)
			, GlobalAttributeSource5 = IIF(@GlobalAttributeSource5 = N'<#NV>', GlobalAttributeSource5, @GlobalAttributeSource5)
			, GlobalAttributeAlias5 = IIF(@GlobalAttributeAlias5 = N'<#NV>', GlobalAttributeAlias5, @GlobalAttributeAlias5)
			, GlobalAttributeSource6 = IIF(@GlobalAttributeSource6 = N'<#NV>', GlobalAttributeSource6, @GlobalAttributeSource6)
			, GlobalAttributeAlias6 = IIF(@GlobalAttributeAlias6 = N'<#NV>', GlobalAttributeAlias6, @GlobalAttributeAlias6)
			, GlobalAttributeSource7 = IIF(@GlobalAttributeSource7 = N'<#NV>', GlobalAttributeSource7, @GlobalAttributeSource7)
			, GlobalAttributeAlias7 = IIF(@GlobalAttributeAlias7 = N'<#NV>', GlobalAttributeAlias7, @GlobalAttributeAlias7)
			, GlobalAttributeSource8 = IIF(@GlobalAttributeSource8 = N'<#NV>', GlobalAttributeSource8, @GlobalAttributeSource8)
			, GlobalAttributeAlias8 = IIF(@GlobalAttributeAlias8 = N'<#NV>', GlobalAttributeAlias8, @GlobalAttributeAlias8)
			, GlobalAttributeSource9 = IIF(@GlobalAttributeSource9 = N'<#NV>', GlobalAttributeSource9, @GlobalAttributeSource9)
			, GlobalAttributeAlias9 = IIF(@GlobalAttributeAlias9 = N'<#NV>', GlobalAttributeAlias9, @GlobalAttributeAlias9)
			, GlobalAttributeSource10 = IIF(@GlobalAttributeSource10 = N'<#NV>', GlobalAttributeSource10, @GlobalAttributeSource10)
			, GlobalAttributeAlias10 = IIF(@GlobalAttributeAlias10 = N'<#NV>', GlobalAttributeAlias10, @GlobalAttributeAlias10)

			, GlobalAttributeSource11 = IIF(@GlobalAttributeSource11 = N'<#NV>', GlobalAttributeSource11, @GlobalAttributeSource11)
			, GlobalAttributeAlias11 = IIF(@GlobalAttributeAlias11 = N'<#NV>', GlobalAttributeAlias11, @GlobalAttributeAlias11)			
			, GlobalAttributeSource12 = IIF(@GlobalAttributeSource12 = N'<#NV>', GlobalAttributeSource12, @GlobalAttributeSource12)
			, GlobalAttributeAlias12 = IIF(@GlobalAttributeAlias12 = N'<#NV>', GlobalAttributeAlias12, @GlobalAttributeAlias12)
			, GlobalAttributeSource13 = IIF(@GlobalAttributeSource13 = N'<#NV>', GlobalAttributeSource13, @GlobalAttributeSource13)
			, GlobalAttributeAlias13 = IIF(@GlobalAttributeAlias13 = N'<#NV>', GlobalAttributeAlias13, @GlobalAttributeAlias13)
			, GlobalAttributeSource14 = IIF(@GlobalAttributeSource14 = N'<#NV>', GlobalAttributeSource14, @GlobalAttributeSource14)
			, GlobalAttributeAlias14 = IIF(@GlobalAttributeAlias14 = N'<#NV>', GlobalAttributeAlias14, @GlobalAttributeAlias14)
			, GlobalAttributeSource15 = IIF(@GlobalAttributeSource15 = N'<#NV>', GlobalAttributeSource15, @GlobalAttributeSource15)
			, GlobalAttributeAlias15 = IIF(@GlobalAttributeAlias15 = N'<#NV>', GlobalAttributeAlias15, @GlobalAttributeAlias15)
			, GlobalAttributeSource16 = IIF(@GlobalAttributeSource16 = N'<#NV>', GlobalAttributeSource16, @GlobalAttributeSource16)
			, GlobalAttributeAlias16 = IIF(@GlobalAttributeAlias16 = N'<#NV>', GlobalAttributeAlias16, @GlobalAttributeAlias16)
			, GlobalAttributeSource17 = IIF(@GlobalAttributeSource17 = N'<#NV>', GlobalAttributeSource17, @GlobalAttributeSource17)
			, GlobalAttributeAlias17 = IIF(@GlobalAttributeAlias17 = N'<#NV>', GlobalAttributeAlias17, @GlobalAttributeAlias17)
			, GlobalAttributeSource18 = IIF(@GlobalAttributeSource18 = N'<#NV>', GlobalAttributeSource18, @GlobalAttributeSource18)
			, GlobalAttributeAlias18 = IIF(@GlobalAttributeAlias18 = N'<#NV>', GlobalAttributeAlias18, @GlobalAttributeAlias18)
			, GlobalAttributeSource19 = IIF(@GlobalAttributeSource19 = N'<#NV>', GlobalAttributeSource19, @GlobalAttributeSource19)
			, GlobalAttributeAlias19 = IIF(@GlobalAttributeAlias19 = N'<#NV>', GlobalAttributeAlias19, @GlobalAttributeAlias19)
			, GlobalAttributeSource20 = IIF(@GlobalAttributeSource20 = N'<#NV>', GlobalAttributeSource20, @GlobalAttributeSource20)
			, GlobalAttributeAlias20 = IIF(@GlobalAttributeAlias20 = N'<#NV>', GlobalAttributeAlias20, @GlobalAttributeAlias20)
	
			, GlobalAttributeSource21 = IIF(@GlobalAttributeSource21 = N'<#NV>', GlobalAttributeSource21, @GlobalAttributeSource21)
			, GlobalAttributeAlias21 = IIF(@GlobalAttributeAlias21 = N'<#NV>', GlobalAttributeAlias21, @GlobalAttributeAlias21)			
			, GlobalAttributeSource22 = IIF(@GlobalAttributeSource22 = N'<#NV>', GlobalAttributeSource22, @GlobalAttributeSource22)
			, GlobalAttributeAlias22 = IIF(@GlobalAttributeAlias22 = N'<#NV>', GlobalAttributeAlias22, @GlobalAttributeAlias22)
			, GlobalAttributeSource23 = IIF(@GlobalAttributeSource23 = N'<#NV>', GlobalAttributeSource23, @GlobalAttributeSource23)
			, GlobalAttributeAlias23 = IIF(@GlobalAttributeAlias23 = N'<#NV>', GlobalAttributeAlias23, @GlobalAttributeAlias23)
			, GlobalAttributeSource24 = IIF(@GlobalAttributeSource24 = N'<#NV>', GlobalAttributeSource24, @GlobalAttributeSource24)
			, GlobalAttributeAlias24 = IIF(@GlobalAttributeAlias24 = N'<#NV>', GlobalAttributeAlias24, @GlobalAttributeAlias24)
			, GlobalAttributeSource25 = IIF(@GlobalAttributeSource25 = N'<#NV>', GlobalAttributeSource25, @GlobalAttributeSource25)
			, GlobalAttributeAlias25 = IIF(@GlobalAttributeAlias25 = N'<#NV>', GlobalAttributeAlias25, @GlobalAttributeAlias25)
		FROM [dbo].[sx_pf_dProductLines]
		WHERE ProductLineKey = @ProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		-- STEP 3.3 - Rights materialize (only possible for users with Factory WriteRight or Cluster Admin)
		EXEC [dbo].[sx_pf_materialize_vUserRights];

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductLine] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductLine] TO pf_PlanningFactoryService;
GO
/*
POST Operation for ProductLineProperty
Not existing ProductLine will be created, existing gets an Update
If attributes passed with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
5. Property created => 201 Created
6. Property updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'U'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @PropertyID AS NVARCHAR(255) = 'rreo'
		DECLARE @PropertyName AS NVARCHAR(255) = ''
		DECLARE @CommentUser AS NVARCHAR(255) = ''
		DECLARE @CommentDev AS NVARCHAR(255) = ''
		DECLARE @Unit AS NVARCHAR(255) = ''
		DECLARE @ValueText AS NVARCHAR(255) = ''
		DECLARE @ValueInt AS NVARCHAR(255) = '678'
		DECLARE @Scale AS NVARCHAR(255) = '<#NV>'
		DECLARE @IsROSystemProperty AS NVARCHAR(255) = '1'
		DECLARE @FormatID AS NVARCHAR(255) = '<#NV>'

EXECUTE @RC = [sx_pf_POST_ProductLineProperty] @Username,@ProductLineID,@FactoryID,@PropertyID,	@PropertyName,@CommentUser,@CommentDev,
	@Unit,@ValueText,@ValueInt,	@Scale,@IsROSystemProperty,@FormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ProductLineProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ProductLineProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ProductLineProperty]
	@Username AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255),
	@PropertyName AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@Unit AS NVARCHAR(255),
	@ValueText AS NVARCHAR(255),
	@ValueInt AS NVARCHAR(255),
	@Scale AS NVARCHAR(255),
	@IsROSystemProperty AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @PropertyOwner AS INT = 0;

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@PropertyID, N'NULL') + N''',''' + ISNULL(@PropertyName, N'NULL') + N''',''' + ISNULL(@CommentUser, N'NULL') + N''',''' + ISNULL(@CommentDev, N'NULL') 
		+ N''',''' + ISNULL(@Unit, N'NULL') + N''',''' + ISNULL(@ValueText, N'NULL') + N''',''' + ISNULL(@ValueInt, N'NULL') + N''',''' + ISNULL(@Scale, N'NULL') 
		+ N''',''' + ISNULL(@IsROSystemProperty, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';
	IF @PropertyName IS NULL SET @PropertyName = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @Unit IS NULL SET @Unit = N'';
	IF @ValueText IS NULL SET @ValueText = N'';
	IF @ValueInt IS NULL SET @ValueInt = N'';
	IF @Scale IS NULL SET @Scale = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters	
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);
		SET @PropertyName = [dbo].[sx_pf_pProtectString] (@PropertyName);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @Unit = [dbo].[sx_pf_pProtectString] (@Unit);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);
		SET @ValueInt = [dbo].[sx_pf_pProtectInt] (@ValueInt);
		SET @Scale = [dbo].[sx_pf_pProtectInt] (@Scale);
		SET @FormatID = [dbo].[sx_pf_pProtectString] (@FormatID); --as it can be #<NV>

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @PropertyID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gProductLines] WHERE ProductLineKey =  @ProductLineKey AND PropertyID = @PropertyID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Don`t allow changing of system RO Properties - Disabled from version 4.0.63 on to enable export/import
		--SELECT @PropertyOwner = IsROSystemProperty FROM [dbo].[sx_pf_gProductLines] WHERE ProductLineKey = @ProductLineKey AND PropertyID = @PropertyID;
		--IF @PropertyOwner = 1
		--BEGIN
		--	SET @ResultCode = 403;
		--	RAISERROR('Don`t allow changing of system RO Properties', 16, 10);
		--END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 3.1 - If Key does not yet exist, it will be created in minimal configuration		
		IF @PropertyKey = 0
		BEGIN
			
			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_gProductLines] (PropertyID, FactoryKey, FactoryID, ProductLineKey, ProductLineID) 
			OUTPUT INSERTED.PropertyKey INTO @Keys([Key]) 
			VALUES (@PropertyID, @FactoryKey, @FactoryID, @ProductLineKey, @ProductLineID);

			SELECT TOP 1 @PropertyKey = [Key] FROM @Keys;

			SET @EffectedRows = 1;
			SET @Resultcode = 201;
		END;

		-- STEP 3.2 - The property receives the transmitted attributes undelivered be maintained
		UPDATE [dbo].[sx_pf_gProductLines] 
		SET PropertyName = IIF(@PropertyName = N'<#NV>', PropertyName, @PropertyName)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, Unit = IIF(@Unit = N'<#NV>', Unit, @Unit)
			, ValueText = IIF(@ValueText = N'<#NV>', ValueText, @ValueText)
			, ValueInt = IIF(@ValueInt = N'<#NV>', ValueInt, @ValueInt)
			, Scale = IIF(@Scale = N'<#NV>', Scale, @Scale)
			, IsROSystemProperty = IIF(@IsROSystemProperty = N'<#NV>', IsROSystemProperty, @IsROSystemProperty)
			, FormatID = IIF(@FormatID = N'<#NV>', FormatID, @FormatID)
		FROM [dbo].[sx_pf_gProductLines]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductLineProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductLineProperty] TO pf_PlanningFactoryService;
GO
/*
POST Operation for ProductProperty
Not existing ProductLine will be created, existing gets an Update
If attributes passed with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
5. Property created => 201 Created
6. Property updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ProductID AS NVARCHAR(255) = '1'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'U'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @PropertyID AS NVARCHAR(255) = 'rreo'
		DECLARE @PropertyName AS NVARCHAR(255) = ''
		DECLARE @CommentUser AS NVARCHAR(255) = ''
		DECLARE @CommentDev AS NVARCHAR(255) = ''
		DECLARE @Unit AS NVARCHAR(255) = ''
		DECLARE @ValueText AS NVARCHAR(255) = ''
		DECLARE @ValueInt AS NVARCHAR(255) = '678'
		DECLARE @Scale AS NVARCHAR(255) = '<#NV>'
		DECLARE @IsROSystemProperty AS NVARCHAR(255) = '1'
		DECLARE @FormatID AS NVARCHAR(255) = '<#NV>'

EXECUTE @RC = [sx_pf_POST_ProductProperty] 	@Username,	@ProductID,	@ProductLineID,	@FactoryID,	@PropertyID,@PropertyName,@CommentUser,@CommentDev,@Unit,@ValueText,
		@ValueInt,@Scale,@IsROSystemProperty,@FormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ProductProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ProductProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ProductProperty]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255),
	@PropertyName AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@Unit AS NVARCHAR(255),
	@ValueText AS NVARCHAR(255),
	@ValueInt AS NVARCHAR(255),
	@Scale AS NVARCHAR(255),
	@IsROSystemProperty AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @ProductKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @PropertyOwner AS INT = 0;  --0 = User, 1=Database, 2=Client

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + N''',''' + ISNULL(@PropertyName, N'NULL') + N''',''' + ISNULL(@CommentUser, N'NULL') 
		+ N''',''' + ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@Unit, N'NULL') + N''',''' + ISNULL(@ValueText, N'NULL') + N''',''' + ISNULL(@ValueInt, N'NULL') 
		+ N''',''' + ISNULL(@Scale, N'NULL') + N''',''' + ISNULL(@IsROSystemProperty, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';
	IF @PropertyName IS NULL SET @PropertyName = N'';
	IF @CommentUser IS NULL SET @CommentUser = N'';
	IF @CommentDev IS NULL SET @CommentDev = N'';
	IF @Unit IS NULL SET @Unit = N'';
	IF @ValueText IS NULL SET @ValueText = N'';
	IF @ValueInt IS NULL SET @ValueInt = N'';
	IF @Scale IS NULL SET @Scale = N'';
	IF @FormatID IS NULL SET @FormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
			
		-- STEP 0.2 - Protect input parameters	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);
		SET @PropertyName = [dbo].[sx_pf_pProtectString] (@PropertyName);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @Unit = [dbo].[sx_pf_pProtectString] (@Unit);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);
		SET @ValueInt = [dbo].[sx_pf_pProtectInt] (@ValueInt);
		SET @Scale = [dbo].[sx_pf_pProtectInt] (@Scale);
		--SET @PropertyOwner = [dbo].[sx_pf_pProtectBoolean] (@IsROSystemProperty); -- NO Protection at the moment, as value can be 0,1,2
		SET @FormatID = [dbo].[sx_pf_pProtectID] (@FormatID);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @PropertyID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gProducts] WHERE ProductKey =  @ProductKey AND PropertyID = @PropertyID;
		
		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Don`t allow changing of system RO Properties - Disabled from version 4.0.63 on to enable export/import
		--SELECT @PropertyOwner = IsROSystemProperty FROM [dbo].[sx_pf_gProducts] WHERE ProductKey =  @ProductKey AND PropertyID = @PropertyID;
		--IF @PropertyOwner = 1
		--BEGIN
		--	SET @ResultCode = 403;
		--	RAISERROR('Don`t allow changing of system RO Properties', 16, 10);
		--END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3.1 - If Key does not yet exist, it will be created in minimal configuration				
		IF @PropertyKey = 0
		BEGIN

			DECLARE @Keys AS TABLE ([Key] INT);

			INSERT INTO [dbo].[sx_pf_gProducts] (PropertyID,FactoryKey,FactoryID,ProductLineKey,ProductLineID, ProductKey, ProductID) 
			OUTPUT INSERTED.PropertyKey INTO @Keys([Key]) 
			VALUES (@PropertyID,@FactoryKey,@FactoryID,@ProductLineKey, @ProductLineID, @ProductKey, @ProductID);
			
			SELECT TOP 1 @PropertyKey = [Key] FROM @Keys;

			SET @Resultcode = 201;
			SET @EffectedRows = 1;
		END

		-- STEP 3.2 - The property receives the transmitted attributes undelivered be maintained
		UPDATE [dbo].[sx_pf_gProducts]
		SET PropertyName = IIF(@PropertyName = N'<#NV>', PropertyName, @PropertyName)
			, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
			, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
			, Unit = IIF(@Unit = N'<#NV>', Unit, @Unit)
			, ValueText = IIF(@ValueText = N'<#NV>', ValueText, @ValueText)
			, ValueInt = IIF(@ValueInt = N'<#NV>', ValueInt, @ValueInt)
			, Scale = IIF(@Scale = N'<#NV>', Scale, @Scale)
			, IsROSystemProperty = IIF(@IsROSystemProperty = N'<#NV>', IsROSystemProperty, @IsROSystemProperty)
			, FormatID = IIF(@FormatID = N'<#NV>', FormatID, @FormatID)
		FROM [dbo].[sx_pf_gProducts]
		WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ProductProperty] TO pf_PlanningFactoryService;
GO
/*
POST Operation for UserRight
UserRight will be created always, not fitting other rights will be deleted to ensure enheritance
Procedure filter special Usernames 'PlanningFactory' or 'public'

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Right or PostUserName is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username has no write access to the cluster at Create => 401 Unauthorized
4. FactoryID or ProductLineID not exists => 404 Not Found
5. User existiert nicht in sx_pf_rUser  => 404 Not Found
6. Right updated => 200 OK
7. Right deleted (set to denied) => 204 No Content

DECLARE @RC int
DECLARE @UserName AS NVARCHAR(255) = 'W8\admin'
DECLARE @PostUserName AS NVARCHAR(255) = 'Hase'
DECLARE @FactoryID AS NVARCHAR(255) = '2'
DECLARE @ProductLineID AS NVARCHAR(255) = '4'
DECLARE @Right AS NVARCHAR(255) = 'Write'
DECLARE @ReadCommentMandatory AS NVARCHAR(255) = ''
DECLARE @WriteCommentMandatory AS NVARCHAR(255) = ''
		

EXECUTE @RC = [sx_pf_POST_Right] 
		@UserName,
		@PostUserName,
		@FactoryID,
        @ProductLineID,
        @Right,
        @ReadCommentMandatory,
        @WriteCommentMandatory

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Right]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Right];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Right]
	@UserName AS NVARCHAR(255),
	@PostUserName AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
    @ProductLineID AS NVARCHAR(255),
    @Right AS NVARCHAR(255),
    @ReadCommentMandatory AS NVARCHAR(255),
    @WriteCommentMandatory AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @RightKey AS INT = 0;
	DECLARE @PostUserKey AS INT = 0;
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @TransactUsername AS NVARCHAR(255) = N'';
	DECLARE @ClusterRight AS NVARCHAR(255) = N'';
	DECLARE @FactoryRight AS NVARCHAR(255) = N'';
	DECLARE @tmpRightKeyTable AS TABLE (RightKey INT);

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'ISNULL') + N''',''' + ISNULL(@PostUserName, N'ISNULL') + N''',''' + ISNULL(@FactoryID, N'ISNULL')
		 + N''',''' + ISNULL(@ProductLineID, N'ISNULL') + N''',''' + ISNULL(@Right, N'ISNULL') + N''',''' + ISNULL(@ReadCommentMandatory, N'ISNULL')
		 + N''',''' + ISNULL(@WriteCommentMandatory, N'ISNULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @PostUserName IS NULL SET @PostUserName = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @Right IS NULL SET @Right = N'';
	IF @ReadCommentMandatory IS NULL SET @ReadCommentMandatory = N'';
	IF @WriteCommentMandatory IS NULL SET @WriteCommentMandatory = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;	

		-- STEP 0.2 - Protect input parameters	
		SET @PostUserName = [dbo].[sx_pf_pProtectString] (@PostUserName);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @Right = [dbo].[sx_pf_pProtectString] (@Right);
		SET @ReadCommentMandatory = [dbo].[sx_pf_pProtectBoolean] (@ReadCommentMandatory);
		SET @WriteCommentMandatory = [dbo].[sx_pf_pProtectBoolean] (@WriteCommentMandatory);
		
		-- STEP 0.3 - Clean IDs
		SET @Right = LTRIM(RTRIM(@Right));
		SET @PostUserName = LTRIM(RTRIM(@PostUserName));
		SET @FactoryID = LTRIM(RTRIM(@FactoryID));
		SET @ProductLineID = LTRIM(RTRIM(@ProductLineID));

		IF @Right = N'' OR @PostUserName = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	
				
		-- STEP 1.1 - It`s forbidden to post rights for system users with name 'SQL' or '* Planning Factory'
		IF @PostUserName = N'SQL' OR RIGHT(@PostUserName, 15) = N'PlanningFactory'	
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Forbidden to post rights for system users with name %s', 16, 10, @PostUserName);
		END;	

		-- STEP 1.2 - Determine transaction user, the transactuser 'public' is not allowed to post rights
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END 
		ELSE IF @TransactUsername = N'public'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('''Public'' user is not allowed to post rights', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);	

		-- STEP 2.1 - It`s forbidden for a ClusterAdmin to change his own rights
		IF @PostUserName = @TransactUsername	
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Forbidden for a ClusterAdmin to change his own rights', 16, 10);
		END;

		-- STEP 2.2 - Empty factory ID must always be connected to empty ProductLineID
		IF @FactoryID = N'' AND @ProductLineID <> N''
		BEGIN
			SET @ResultCode = 401;
			RAISERROR('Empty factory ID must always be connected to empty ProductLineID', 16, 10);
		END;
		
		-- STEP 2.3 - Check keys
		IF @FactoryID <> N''
		BEGIN
			SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

			IF @FactoryKey = 0 
			BEGIN
				SET @ResultCode = 404;
				RAISERROR('Keys not exists', 16, 10);
			END;
		END;

		IF @ProductLineID <> N'' 
		BEGIN
			SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
			
			IF @ProductLineKey = 0 
			BEGIN
				SET @ResultCode = 404;
				RAISERROR('Keys not exists', 16, 10);
			END;
		END;

		SELECT @PostUserKey = UserKey FROM [dbo].[sx_pf_rUser] WHERE Username = @PostUserName;

		IF @PostUserKey  = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys not exists', 16, 10);
		END;

		-- STEP 3 - Set Rule
		IF @Right = N'Deny'
		BEGIN
			-- 'Deny' will delete a right, but never create an entry

			IF @FactoryID = N''
				DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey;
			ELSE IF @ProductLineID = N''
				DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID;
			ELSE
				DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID;

			SET @EffectedRows += @@ROWCOUNT;
			SET @ResultCode = 204;
		END
		ELSE
		BEGIN
			-- Saves only explicit rights on objects and deletes rights which get invalid through right definition on upper levels
			-- Check always Clusteright 
			
			SELECT TOP 1 @ClusterRight = COALESCE([Right], N'None') FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = N'';
			SET @ResultCode = 204;

			-- CLUSTER RIGHTS are posted +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			-- Write / Read -> delete all other Rights and insert
			IF @FactoryID = N'' AND @ProductLineID = N''
			BEGIN
				DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey;

				SET @EffectedRows += @@ROWCOUNT;

				INSERT INTO [dbo].[sx_pf_rRights]
						(UserKey
						,UserName
						,FactoryID
						,ProductLineID
						,ProductID
						,[Right]
						,ReadCommentMandatory
						,WriteCommentMandatory)
				VALUES  (@PostUserKey  -- UserKey - int
						,@PostUserName -- UserName - nvarchar(255)
						,N''  -- FactoryID - nvarchar(255)
						,N''  -- ProductLineID - nvarchar(255)
						,N''  -- ProductID - nvarchar(255)
						,@Right  -- Right - nvarchar(255)
						,@ReadCommentMandatory  -- ReadCommentMandatory - int
						,@WriteCommentMandatory  -- WriteCommentMandatory - int
						);
				
				SET @EffectedRows += @@ROWCOUNT;
				SET @ResultCode = 200;
			END;

			-- FACTORY RIGHTS are posted +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			IF @FactoryID <> N'' AND @ProductLineID = N''
			BEGIN
				-- Write -> delete all other Right in this Factory, dont accept if user has write on Cluster
				IF @Right = N'Write' AND @ClusterRight <> N'Write'
				BEGIN
					DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID;
					SET @EffectedRows += @@ROWCOUNT;

					INSERT INTO [dbo].[sx_pf_rRights]
							( UserKey
							,UserName
							,FactoryID
							,ProductLineID
							,ProductID
							,[Right]
							,ReadCommentMandatory
							,WriteCommentMandatory)
					VALUES  (@PostUserKey  -- UserKey - int
							,@PostUserName  -- UserName - nvarchar(255)
							,@FactoryID  -- FactoryID - nvarchar(255)
							,N''  -- ProductLineID - nvarchar(255)
							,N''  -- ProductID - nvarchar(255)
							,@Right  -- Right - nvarchar(255)
							,@ReadCommentMandatory  -- ReadCommentMandatory - int
							,@WriteCommentMandatory  -- WriteCommentMandatory - int
							);

					SET @EffectedRows += @@ROWCOUNT;
					SET @ResultCode = 200;
				END;

				-- Read if no cluster rights set -> delete all other Rights in this Factory, dont accept if user has write or read on Cluster
				IF @Right = N'Read' AND @ClusterRight <> N'Write' AND @ClusterRight <> N'Read'
				BEGIN
					DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID;
					SET @EffectedRows += @@ROWCOUNT;

					INSERT INTO [dbo].[sx_pf_rRights]
							(UserKey
							,UserName
							,FactoryID
							,ProductLineID
							,ProductID
							,[Right]
							,ReadCommentMandatory
							,WriteCommentMandatory)
					VALUES  ( @PostUserKey  -- UserKey - int
							,@PostUserName  -- UserName - nvarchar(255)
							,@FactoryID  -- FactoryID - nvarchar(255)
							,N''  -- ProductLineID - nvarchar(255)
							,N''  -- ProductID - nvarchar(255)
							,@Right  -- Right - nvarchar(255)
							,@ReadCommentMandatory  -- ReadCommentMandatory - int
							,@WriteCommentMandatory  -- WriteCommentMandatory - int
							);

					SET @EffectedRows += @@ROWCOUNT;
					SET @ResultCode = 200;
				END;

				-- Read if Clusterwrite rights -> delete all other Rights in this Factory, dont accept if user has write or read on Cluster
				IF @Right = N'Read' AND @ClusterRight = N'Read'
				BEGIN
					DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID;

					SET @EffectedRows += @@ROWCOUNT;
					SET @ResultCode = 200;
				END
			END;

			-- PRODUCTLINE RIGHT is posted +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			IF @FactoryID <> N'' AND @ProductLineID <> N''
			BEGIN
				-- Look for Rights on Factory Level
				SELECT TOP 1  @FactoryRight = COALESCE([Right], N'None') FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID AND ProductLineID = N'';

				-- Write -> dont accept if user has already write on Cluster or Factory
				IF @Right = N'Write' AND @ClusterRight <> N'Write' AND @FactoryRight <> N'Write'
				BEGIN
					DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID;
					SET @EffectedRows += @@ROWCOUNT;

					INSERT INTO [dbo].[sx_pf_rRights]
							( UserKey
							,UserName
							,FactoryID
							,ProductLineID
							,ProductID
							,[Right]
							,ReadCommentMandatory
							,WriteCommentMandatory)
					VALUES  ( @PostUserKey  -- UserKey - int
							,@PostUserName  -- UserName - nvarchar(255)
							,@FactoryID  -- FactoryID - nvarchar(255)
							,@ProductLineID  -- ProductLineID - nvarchar(255)
							,N''  -- ProductID - nvarchar(255)
							,@Right  -- Right - nvarchar(255)
							,@ReadCommentMandatory  -- ReadCommentMandatory - int
							,@WriteCommentMandatory  -- WriteCommentMandatory - int
							);

					SET @EffectedRows += @@ROWCOUNT;
					SET @ResultCode = 200;
				END;

				-- Read -> don`t accept if user has read or write on Cluster or Factory
				IF @Right = N'Read' AND @ClusterRight <> N'Write' AND @ClusterRight <> N'Read' AND @FactoryRight <> N'Write' AND @FactoryRight <> N'Read'
				BEGIN
					DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID;
					SET @EffectedRows += @@ROWCOUNT;

					INSERT INTO [dbo].[sx_pf_rRights]
							( UserKey
							,UserName
							,FactoryID
							,ProductLineID
							,ProductID
							,[Right]
							,ReadCommentMandatory
							,WriteCommentMandatory)
					VALUES  ( @PostUserKey  -- UserKey - int
							,@PostUserName  -- UserName - nvarchar(255)
							,@FactoryID  -- FactoryID - nvarchar(255)
							,@ProductLineID  -- ProductLineID - nvarchar(255)
							,N''  -- ProductID - nvarchar(255)
							,@Right  -- Right - nvarchar(255)
							,@ReadCommentMandatory  -- ReadCommentMandatory - int
							,@WriteCommentMandatory  -- WriteCommentMandatory - int
							);

					SET @EffectedRows += @@ROWCOUNT;
					SET @ResultCode = 200;
				END;
						
				-- Read -> if read should only kill an existing write in Factories with global Read Rights, just delete Write Right
				IF @Right = N'Read' AND @FactoryRight = N'Read'
				BEGIN
					DELETE FROM [dbo].[sx_pf_rRights] WHERE UserKey = @PostUserKey AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID;
					SET @EffectedRows += @@ROWCOUNT;
				END;
			END;
		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Right] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Right] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a new Statement
A Statement can only created, there is no Update or Delete

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pProtectBoolean
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ProductID, ProductLineID, FactoryID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. ProductKey, ProductLineKey, FactoryKey does not exist => 404 Not Found
5. Statement created => 201 Created

DECLARE @RC int
	  DECLARE @Username AS NVARCHAR(255) = 'SQL'
      DECLARE @ProductID AS NVARCHAR(255) = '1'
      DECLARE @ProductLineID AS NVARCHAR(255) = 'ZT'
      DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
      DECLARE @ActionType AS NVARCHAR(255) = 'SAVE'
      DECLARE @Statement AS NVARCHAR(255) = 'ALLES GUT'
      DECLARE @PCName AS NVARCHAR(255) = ''
      DECLARE @ProcessorCode AS NVARCHAR(255) = ''
      DECLARE @IPAddresses AS NVARCHAR(255) = ''
      DECLARE @IsDeleted AS NVARCHAR(255) = ''
      DECLARE @IsResolved AS NVARCHAR(255) = ''

EXECUTE @RC = [sx_pf_POST_Statement] @Username,	@ProductID,	@ProductLineID,	@FactoryID,	@ActionType,@Statement,	@PCName,@ProcessorCode,	@IPAddresses,@IsDeleted,@IsResolved

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Statement]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Statement];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Statement]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ActionType AS NVARCHAR(255),
	@Statement AS NVARCHAR(255),
	@PCName AS NVARCHAR(255),
	@ProcessorCode AS NVARCHAR(255),
	@IPAddresses AS NVARCHAR(255),
	@IsDeleted AS NVARCHAR(255),
	@IsResolved AS NVARCHAR(255)	
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @ProductKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ActionType, N'NULL') + N''',''' + ISNULL(@Statement, N'NULL') + N''',''' + ISNULL(@PCName, N'NULL') 
		+ N''',''' + ISNULL(@ProcessorCode, N'NULL') + N''',''' + ISNULL(@IPAddresses, N'NULL') + N''',''' + ISNULL(@IsDeleted, N'NULL') + N''',''' + ISNULL(@IsResolved, N'NULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ActionType IS NULL SET @ActionType = N'';
	IF @Statement IS NULL SET @Statement = N'';
	IF @PCName IS NULL SET @PCName = N'';
	IF @ProcessorCode IS NULL SET @ProcessorCode = N'';
	IF @IPAddresses IS NULL SET @IPAddresses = N'';
	IF @IsDeleted IS NULL SET @IsDeleted = N'';
	IF @IsResolved IS NULL SET @IsResolved = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ActionType = [dbo].[sx_pf_pProtectString] (@ActionType);
		SET @Statement = [dbo].[sx_pf_pProtectString] (@Statement);
		SET @PCName = [dbo].[sx_pf_pProtectString] (@PCName);
		SET @ProcessorCode = [dbo].[sx_pf_pProtectString] (@ProcessorCode);
		SET @IPAddresses = [dbo].[sx_pf_pProtectString] (@IPAddresses);
		SET @IsDeleted = [dbo].[sx_pf_pProtectBoolean] (@IsDeleted);
		SET @IsResolved = [dbo].[sx_pf_pProtectBoolean] (@IsResolved);
		
		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;	
				
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID  AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID  AND ProductLineKey = @ProductLinekey AND FactoryKey = @FactoryKey;
		
		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 3 - Insert new Statement
		INSERT INTO [dbo].[sx_pf_fStatements] (
			ProductKey,
			ProductLineKey,
			FactoryKey,
			ProductID,
			ProductLineID,
			FactoryID,
			ActionType,
			[Statement],
			UserName,
			PCName,
			ProcessorCode,
			IPAddresses,
			[Timestamp],
			IsDeleted,
			IsResolved) 
		VALUES
			(@ProductKey,
			@ProductLineKey,
			@FactoryKey,
			@ProductID,
			@ProductLineID,
			@FactoryID,
			@ActionType,
			@Statement,
			@TransactUsername,
			@PCName,
			@ProcessorCode,
			@IPAddresses,
			CAST(YEAR(CURRENT_TIMESTAMP) AS BIGINT)*10000000000 + CAST(MONTH(CURRENT_TIMESTAMP) as BIGINT)*100000000 + DAY(CURRENT_TIMESTAMP)*1000000 + DATEPART(hh,CURRENT_TIMESTAMP)*10000 + DATEPART(MINUTE,CURRENT_TIMESTAMP) *100 + DATEPART(ss, CURRENT_TIMESTAMP),
			@IsDeleted,
			@IsResolved);

		SET @EffectedRows += @@ROWCOUNT;
		SET @ResultCode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Statement] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Statement] TO pf_PlanningFactoryService;
GO
/*
POST Operation to apply a template (again) on a Product
Existing Values in the Product will be saved, new/other logic will be added
It means the Template inherits its properties again to the object

The logical process is

1. replace the Target Product by a new copy of the Template
2. transfer all global attributes whitout changing
2. Import all Values from ValueSeries which are of type "Input" in the Template to the Template

Dependencies:
	- Functions: 
		- sx_pf_pProtectInt
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

02/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no rights => 401 Unauthorized
4. Non exists Factory / Productline keys => 404 Not Found
5. Not existing template for new ProductID => 404 Not Found
6. Product created => 201 Created
7. Product updated => 200 OK

DECLARE @RC int 
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) ='1'
DECLARE @ProductLineID nvarchar(255) = '1'
DECLARE @FactoryID nvarchar(255) ='1'

DECLARE @TemplateProductID nvarchar(255) ='1'
DECLARE @TemplateProductLineID nvarchar(255) ='U'
DECLARE @TemplateFactoryID nvarchar(255) = 'ZT'

DECLARE @CompareByNameInsteadOfIDFlag int = 1

EXECUTE @RC = [dbo].[sx_pf_POST_Template] 
   @Username
  ,@ProductID
  ,@ProductLineID
  ,@FactoryID
  ,@TemplateProductID
  ,@TemplateProductLineID
  ,@TemplateFactoryID
  ,@CompareByNameInsteadOfIDFlag

PRINT @RC

*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Template]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Template]
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Template]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@TemplateProductID AS NVARCHAR(255),
	@TemplateProductLineID AS NVARCHAR(255),
	@TemplateFactoryID AS NVARCHAR(255),
	@CompareByNameInsteadOfIDFlag AS INT
AS 
BEGIN
	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @TemplateFactoryKey AS INT = 0;
	DECLARE @TemplateProductLineKey AS INT = 0;
	DECLARE @TemplateProductKey AS INT = 0;
	DECLARE @TemplateFactoryNameShort AS NVARCHAR(255)= N'';
	DECLARE @TemplateProductLineNameShort AS NVARCHAR(255)= N'';
	DECLARE @TemplateProductNameShort AS NVARCHAR(255)= N'';
	DECLARE @TemplateName AS NVARCHAR(255)= N'';
	
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@TemplateProductID, N'NULL') + N''',''' + ISNULL(@TemplateProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@TemplateFactoryID, N'NULL') + N''',' + ISNULL(CAST(@CompareByNameInsteadOfIDFlag AS NVARCHAR(255)), N'NULL');
	DECLARE @EffectedRows AS INT = 0;				-- SET during Execution
	DECLARE @ResultCode AS INT = 501;				-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';			-- SET during Execution


	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @TemplateProductID IS NULL SET @TemplateProductID = N'';
	IF @TemplateProductLineID IS NULL SET @TemplateProductLineID = N'';
	IF @TemplateFactoryID IS NULL SET @TemplateFactoryID = N'';
	IF @CompareByNameInsteadOfIDFlag IS NULL SET @CompareByNameInsteadOfIDFlag = 0;
		 
	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters	
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @TemplateFactoryID = [dbo].[sx_pf_pProtectID] (@TemplateFactoryID);
		SET @TemplateProductlineID = [dbo].[sx_pf_pProtectID] (@TemplateProductlineID);
		SET @TemplateProductID = [dbo].[sx_pf_pProtectID] (@TemplateProductID);
		SET @CompareByNameInsteadOfIDFlag = [dbo].[sx_pf_pProtectInt] (@CompareByNameInsteadOfIDFlag);
	
		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	
		
		-- STEP 0.3. - Exit if CompareByNameInsteadOfIDFlag not 0 or 1
		IF NOT (@CompareByNameInsteadOfIDFlag = 0 OR @CompareByNameInsteadOfIDFlag = 1) 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Invalid CompareByNameInsteadOfIDFlag parameter', 16, 10);
		END
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @TemplateFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TemplateFactoryID;
		SELECT @TemplateProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TemplateFactoryKey AND ProductlineID = @TemplateProductlineID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @TemplateFactoryKey = 0 OR @TemplateProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		 -- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
		BEGIN

			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode <> 200
				RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 2.1 - Try to identify the product keys
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @ProductlineKey AND ProductID = @ProductID;
		SELECT @TemplateProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @TemplateProductlineKey AND ProductID = @TemplateProductID;
		
		IF @ProductKey = 0 OR @TemplateProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2.2 - Stop, if compare by name and there are doubled ValueSerieNames
		IF	@CompareByNameInsteadOfIDFlag = 1 AND 
			EXISTS (SELECT COUNT(NameShort) FROM sx_pf_dValueSeries WHERE ValueSeriesKey = @TemplateProductKey GROUP BY NameShort HAVING COUNT(NameShort)>1)
			BEGIN
				SET @ResultCode = 403;
				RAISERROR('ValueSeriesNames not unique', 16, 10);
			END

		-- STEP 3.1 - Determine Template values
		SELECT @TemplateFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryKey = @FactoryKey;
		SELECT @TemplateProductLineNameShort = NameShort FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey;
		SELECT @TemplateProductNameShort = NameShort FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @ProductKey;
		SELECT @TemplateName = Template FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @TemplateProductKey;

		-- Table for storing static Data
		CREATE TABLE #ProductDataStorage (
			
			  ValueSeriesID NVARCHAR(255) NOT NULL
			, ValueSeriesName NVARCHAR(255) NOT NULL
			, Scale INT NOT NULL
			, TimeID INT NOT NULL
			, ValueInt BIGINT NOT NULL
			, ValueText NVARCHAR(MAX) NOT NULL
			, ValueComment NVARCHAR (MAX) NOT NULL
			)

		-- Store Data of Product in Storage (but not formulas, they come from template)
		INSERT INTO #ProductDataStorage    
			SELECT 
				  fV.ValueSeriesID
				, dVS.NameShort AS ValueSeriesName
				, dVS.Scale
				, fV.TimeID
				, fV.ValueInt
				, fV.ValueText
				, fV.ValueComment 
			FROM 
				[dbo].[sx_pf_fValues] fV LEFT JOIN [dbo].[sx_pf_dValueSeries] dVS 
				ON	fV.ValueSeriesKey = dVS.ValueSeriesKey
			WHERE fV.ProductKey = @ProductKey
		
		
		-- STEP 3.2 - Delete all Values and ValueSeries of old Product (but not the dProduct, gTables, Statements...)
		DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dValueSeries]  WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM dbo.sx_pf_dTime WHERE ProductKey = @ProductKey;

		CREATE TABLE #VSKeys(
			ValueSeriesKey BIGINT,
			ValueSeriesID NVARCHAR(255),
			ValueSeriesName NVARCHAR(255),
			Scale INT
			)

		-- STEP 3.3 Copy ValueSeries of Template to Product 
		INSERT INTO dbo.sx_pf_dValueSeries OUTPUT inserted.ValueSeriesKey, inserted.ValueSeriesID, Inserted.NameShort, Inserted.Scale INTO #VSKeys
			SELECT 
				 @ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,dVS.ValueSeriesID
				,dVS.ValueSeriesNo
				,dVS.NameShort
				,dVS.NameLong
				,dVS.CommentUser
				,dVS.CommentDev
				,dVS.ImageName
				,dVS.[IsNumeric]
				,dVS.VisibilityLevel
				,dVS.ValueSource
				,dVS.ValueListID
				,dVS.ValueFormatID
				,dVS.Unit
				,dVS.Scale
				,dVS.Effect
				,dVS.EffectParameter

			FROM dbo.sx_pf_dValueSeries dVS WHERE dVS.ProductKey = @TemplateProductKey

		-- STEP 3.4 Copy Timeline of Template to Product 
		INSERT INTO dbo.sx_pf_dTime
		    SELECT 
				 @ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,TimeID
			FROM dbo.sx_pf_dTime dT WHERE dT.ProductKey = @TemplateProductKey

		-- STEP 3.4 Copy Values of Template to Product 
		INSERT INTO dbo.sx_pf_fValues
			SELECT
				 vk.ValueSeriesKey
				,@ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,fV.ValueSeriesID
				,fV.TimeID
				,fV.ValueFormula
				,fV.ValueInt
				,fV.ValueText
				,fV.ValueComment
			FROM dbo.sx_pf_fValues fV LEFT JOIN #VSKeys vk ON
				fV.ValueSeriesID = vk.ValueSeriesID
						
			WHERE fV.ProductKey = @TemplateProductKey


		-- Possible Changes:
			-- New ValueSeries where created								=>	ok, exists empty
			-- ValueSeries where deleted									=>	ok, values lost
			-- ValueSeries of type Formula where changed in its definition	=>	ok, new formulas are used
			-- The timeline was changed										=>	ok, only fitting values are transfered
			-- ValueSeriesID or Names may be changed						=>	ok, but one must keept constant
			-- Typ of Input Series has changed from Int to Text etc.		=>	ok, empty then
			-- Scale of numeric Input Series has changed					=>  ok, old values will be rescaled


		-- STEP 3.5 - Update new Values by ID or Name
		IF @CompareByNameInsteadOfIDFlag = 0 -- compare by ID
		BEGIN
			-- Delete Values, which belong to calculated Series in Template
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesID IN (
									SELECT dVS.ValueSeriesID 
									FROM dbo.sx_pf_dValueSeries dVS
									WHERE
									dVS.ProductKey = @TemplateProductKey AND
									dVS.ValueSource IN ('XLS','XLS-Strict')
								  )
			-- Delete Values, which belong to no longer existing IDs
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesID NOT IN	(
											SELECT dVS.ValueSeriesID 
											FROM dbo.sx_pf_dValueSeries dVS
											WHERE
											dVS.ProductKey = @TemplateProductKey 
										)	
			-- Delete Values, which belong to no longer existing TimeIDs,
			DELETE FROM #ProductDataStorage WHERE
				TimeID NOT IN	(	
									SELECT dT.TimeID
									FROM dbo.sx_pf_dTime dT
									WHERE
									dT.ProductKey = @TemplateProductKey 
								)

			-- Delete Values in fact table which came from Template, to override them
			DELETE FROM dbo.sx_pf_fValues WHERE 
							ProductKey = @ProductKey AND
							(
								ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(255)) IN 
									(	
										SELECT ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(255)) 
										FROM #ProductDataStorage pds
									)
							)

			-- Insert all other Values
			INSERT INTO dbo.sx_pf_fValues
				SELECT 
					 vk.ValueSeriesKey
					,@ProductKey
					,@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductLineID
					,@FactoryID
					,pds.ValueSeriesID
					,pds.TimeID
					,'' AS ValueFormula
					,CAST(CAST(pds.ValueInt AS MONEY) / pds.Scale * vk.Scale AS BIGINT) --rescaling the int Values !!
					,pds.ValueText
					,pds.ValueComment

				FROM #ProductDataStorage pds LEFT JOIN #VSKeys vk ON pds.ValueSeriesID = vk.ValueSeriesID
			        
		END
		ELSE
		BEGIN -- compare by Name
			-- Delete Values, which belong to calculated Series in Template
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesName IN (SELECT dVS.NameShort
								  FROM dbo.sx_pf_dValueSeries dVS
								  WHERE
									dVS.ProductKey = @TemplateProductKey AND
									dVS.ValueSource IN ('XLS','XLS-Strict')
								  )
			-- Delete Values, which belong to no longer existing Names
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesName NOT IN (SELECT dVS.NameShort
								  FROM dbo.sx_pf_dValueSeries dVS
								  WHERE
									dVS.ProductKey = @TemplateProductKey 
								  )

			-- Delete Values, which belong to no longer existing TimeIDs,
			DELETE FROM #ProductDataStorage WHERE
				TimeID NOT IN	(	
									SELECT dT.TimeID
									FROM dbo.sx_pf_dTime dT
									WHERE
									dT.ProductKey = @TemplateProductKey 
								)

			-- Delete Values in fact table which came from Template, to override them
			DELETE fV FROM dbo.sx_pf_fValues fV LEFT JOIN sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey
						 WHERE 
							fV.ProductKey = @ProductKey AND
							(
								dVS.NameShort + '_' + CAST(TimeID AS NVARCHAR(255)) IN 
									(	
										SELECT pds.ValueSeriesName + '_' + CAST(TimeID AS NVARCHAR(255)) 
										FROM #ProductDataStorage pds
									)
							)

			-- Insert all other Values, if they fit to timeline
			INSERT INTO dbo.sx_pf_fValues
				SELECT 
					 vk.ValueSeriesKey
					,@ProductKey
					,@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductLineID
					,@FactoryID
					,dVS.ValueSeriesID
					,pds.TimeID
					,'' AS ValueFormula
					,CAST(CAST(pds.ValueInt AS MONEY) / pds.Scale * vk.Scale AS BIGINT) --rescaling the int Values !!
					,pds.ValueText
					,pds.ValueComment

				FROM #ProductDataStorage pds 
					-- to determine ValueSeries Key
					LEFT JOIN #VSKeys vk ON pds.ValueSeriesName = vk.ValueSeriesName
					
					-- to determine new ValueSeriesID
					LEFT JOIN (SELECT dVS.ValueSeriesID,dVS.NameShort FROM dbo.sx_pf_dValueSeries dVS WHERE dVS.ProductKey = @TemplateProductKey) dVS ON
						dVS.NameShort = pds.ValueSeriesName

				-- filter only fitting TimeIDs
				WHERE pds.TimeID IN (
										SELECT TimeID 
										FROM dbo.sx_pf_dTime dT 
										WHERE dT.ProductKey = @TemplateProductKey
									)

		END;

		-- Create a System Statement
		INSERT INTO [dbo].[sx_pf_fStatements]  
		SELECT  
			  @ProductKey
			, @ProductLineKey
			, @FactoryKey
			, @ProductID
			, @ProductlineID
			, @FactoryID
			, N'POST_Template' AS ActionType
			, N'Product Template updated with Template Factory <' + @TemplateFactoryID + N'>"' 
				+ @TemplateFactoryNameShort + N'"/ ProductLine <' + @TemplateProductlineID + N'>"' 
				+ @TemplateProductLineNameShort + N'"/ Product <' + @TemplateProductID + N'>"' 
				+ @TemplateProductNameShort +'"' AS [Statement]
			, @TransactUsername AS UserName
			, N'' AS PCName
			, N'' AS ProcessorCode
			, N'' AS IPAddresses
			, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10), GETDATE(), 108), 5), N':', N'') AS BIGINT) AS [Timestamp]
			, 0 AS IsDeleted
			, 0 AS IsResolved;

		-- STEP 3.4 - Update the TemplateName of the Product
		UPDATE [dbo].[sx_pf_dProducts]
		SET   Template = @TemplateName
			, TimeType = RIGHT(Template, 2) 
		WHERE ProductKey = @ProductKey;

		SET @EffectedRows += @@ROWCOUNT;
		
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Template] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Template] TO pf_PlanningFactoryService;
GO
/*
POST Operation to apply a template (again) to many Products
Existing Values in the Product will be saved, new/other logic will be added
It means the Template inherits its properties again to the object

NOT READY FOR PRODUCTIVE USE !!

The logical process is

1. replace the Target Product by a new copy of the Template
2. transfer all global attributes whitout changing
2. Import all Values from ValueSeries which are of type "Input" in the Template to the Template

Dependencies:
	- Functions: 
		- sx_pf_pProtectInt
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no rights => 401 Unauthorized
4. Non exists Factory / Productline keys => 404 Not Found
5. Not existing template for new ProductID => 404 Not Found
6. Product created => 201 Created
7. Product updated => 200 OK

DECLARE @RC int 
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) ='1'
DECLARE @ProductLineID nvarchar(255) = '1'
DECLARE @FactoryID nvarchar(255) ='1'

DECLARE @TemplateProductID nvarchar(255) ='1'
DECLARE @TemplateProductLineID nvarchar(255) ='U'
DECLARE @TemplateFactoryID nvarchar(255) = 'ZT'

DECLARE @CompareByNameInsteadOfIDFlag int = 1

EXECUTE @RC = [dbo].[sx_pf_POST_Template_All] 
   @Username
  ,@ProductID
  ,@ProductLineID
  ,@FactoryID
  ,@TemplateProductID
  ,@TemplateProductLineID
  ,@TemplateFactoryID
  ,@CompareByNameInsteadOfIDFlag

PRINT @RC

*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Template_All]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Template_All]
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Template_All]
	@Username AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@SearchTemplateName AS NVARCHAR(255),
	@TemplateProductID AS NVARCHAR(255),
	@TemplateProductLineID AS NVARCHAR(255),
	@TemplateFactoryID AS NVARCHAR(255),
	@CompareByNameInsteadOfIDFlag AS INT
AS 
BEGIN
	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ProductID NVARCHAR(255) = '';
	DECLARE @TemplateFactoryKey AS INT = 0;
	DECLARE @TemplateProductLineKey AS INT = 0;
	DECLARE @TemplateProductKey AS INT = 0;
	DECLARE @TemplateFactoryNameShort AS NVARCHAR(255)= N'';
	DECLARE @TemplateProductLineNameShort AS NVARCHAR(255)= N'';
	DECLARE @TemplateProductNameShort AS NVARCHAR(255)= N'';
	DECLARE @TemplateName AS NVARCHAR(255)= N'';
	
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@SearchTemplateName,N'NULL') + N''',''' + ISNULL(@TemplateProductID, N'NULL') + N''',''' + ISNULL(@TemplateProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@TemplateFactoryID, N'NULL') + N''',' + ISNULL(CAST(@CompareByNameInsteadOfIDFlag AS NVARCHAR(255)), N'NULL');
	DECLARE @EffectedRows AS INT = 0;				-- SET during Execution
	DECLARE @ResultCode AS INT = 501;				-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';			-- SET during Execution


	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @SearchTemplateName IS NULL SET @SearchTemplateName = N'';
	IF @TemplateProductID IS NULL SET @TemplateProductID = N'';
	IF @TemplateProductLineID IS NULL SET @TemplateProductLineID = N'';
	IF @TemplateFactoryID IS NULL SET @TemplateFactoryID = N'';
	IF @CompareByNameInsteadOfIDFlag IS NULL SET @CompareByNameInsteadOfIDFlag = 0;
		 
	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters	
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @SearchTemplateName = [dbo].[sx_pf_pProtectID] (@SearchTemplateName);
		SET @TemplateFactoryID = [dbo].[sx_pf_pProtectID] (@TemplateFactoryID);
		SET @TemplateProductlineID = [dbo].[sx_pf_pProtectID] (@TemplateProductlineID);
		SET @TemplateProductID = [dbo].[sx_pf_pProtectID] (@TemplateProductID);
		SET @CompareByNameInsteadOfIDFlag = [dbo].[sx_pf_pProtectInt] (@CompareByNameInsteadOfIDFlag);

		
		-- STEP 0.3. - Exit if CompareByNameInsteadOfIDFlag not 0 or 1
		IF NOT (@CompareByNameInsteadOfIDFlag = 0 OR @CompareByNameInsteadOfIDFlag = 1) 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Invalid CompareByNameInsteadOfIDFlag parameter', 16, 10);
		END
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

-- STEP 1.2 - CREATE TODO Liste


		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @TemplateFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TemplateFactoryID;
		SELECT @TemplateProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TemplateFactoryKey AND ProductlineID = @TemplateProductlineID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @TemplateFactoryKey = 0 OR @TemplateProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		 -- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
		BEGIN

			EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;

			IF @ResultCode <> 200
				RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 2.1 - Try to identify the product keys
		SELECT @TemplateProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @TemplateProductlineKey AND ProductID = @TemplateProductID;
		
		IF @ProductKey = 0 OR @TemplateProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2.2 - Stop, if compare by name and there are doubled ValueSerieNames
		IF	@CompareByNameInsteadOfIDFlag = 1 AND 
			EXISTS (SELECT COUNT(NameShort) FROM sx_pf_dValueSeries WHERE ValueSeriesKey = @TemplateProductKey GROUP BY NameShort HAVING COUNT(NameShort)>1)
			BEGIN
				SET @ResultCode = 403;
				RAISERROR('ValueSeriesNames not unique', 16, 10);
			END

		-- STEP 3.1 - Determine Template values
		SELECT @TemplateFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryKey = @FactoryKey;
		SELECT @TemplateProductLineNameShort = NameShort FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey;
		SELECT @TemplateProductNameShort = NameShort FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @ProductKey;
		SELECT @TemplateName = Template FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @TemplateProductKey;

		-- Table for storing static Data
		CREATE TABLE #ProductDataStorage (
			
			  ValueSeriesID NVARCHAR(255) NOT NULL
			, ValueSeriesName NVARCHAR(255) NOT NULL
			, Scale INT NOT NULL
			, TimeID INT NOT NULL
			, ValueInt BIGINT NOT NULL
			, ValueText NVARCHAR(MAX) NOT NULL
			, ValueComment NVARCHAR (MAX) NOT NULL
			)

		-- Store Data of Product in Storage (but not formulas, they come from template)
		INSERT INTO #ProductDataStorage    
			SELECT 
				  fV.ValueSeriesID
				, dVS.NameShort AS ValueSeriesName
				, dVS.Scale
				, fV.TimeID
				, fV.ValueInt
				, fV.ValueText
				, fV.ValueComment 
			FROM 
				[dbo].[sx_pf_fValues] fV LEFT JOIN [dbo].[sx_pf_dValueSeries] dVS 
				ON	fV.ValueSeriesKey = dVS.ValueSeriesKey
			WHERE fV.ProductKey = @ProductKey
		
		
		-- STEP 3.2 - Delete all Values and ValueSeries of old Product (but not the dProduct, gTables, Statements...)
		DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dValueSeries]  WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM dbo.sx_pf_dTime WHERE ProductKey = @ProductKey;

		CREATE TABLE #VSKeys(
			ValueSeriesKey BIGINT,
			ValueSeriesID NVARCHAR(255),
			ValueSeriesName NVARCHAR(255),
			Scale INT
			)

		-- STEP 3.3 Copy ValueSeries of Template to Product 
		INSERT INTO dbo.sx_pf_dValueSeries OUTPUT inserted.ValueSeriesKey, inserted.ValueSeriesID, Inserted.NameShort, Inserted.Scale INTO #VSKeys
			SELECT 
				 @ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,dVS.ValueSeriesID
				,dVS.ValueSeriesNo
				,dVS.NameShort
				,dVS.NameLong
				,dVS.CommentUser
				,dVS.CommentDev
				,dVS.ImageName
				,dVS.[IsNumeric]
				,dVS.VisibilityLevel
				,dVS.ValueSource
				,dVS.ValueListID
				,dVS.ValueFormatID
				,dVS.Unit
				,dVS.Scale
				,dVS.Effect
				,dVS.EffectParameter

			FROM dbo.sx_pf_dValueSeries dVS WHERE dVS.ProductKey = @TemplateProductKey

		-- STEP 3.4 Copy Timeline of Template to Product 
		INSERT INTO dbo.sx_pf_dTime
		    SELECT 
				 @ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,TimeID
			FROM dbo.sx_pf_dTime dT WHERE dT.ProductKey = @TemplateProductKey

		-- STEP 3.4 Copy Values of Template to Product 
		INSERT INTO dbo.sx_pf_fValues
			SELECT
				 vk.ValueSeriesKey
				,@ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,fV.ValueSeriesID
				,fV.TimeID
				,fV.ValueFormula
				,fV.ValueInt
				,fV.ValueText
				,fV.ValueComment
			FROM dbo.sx_pf_fValues fV LEFT JOIN #VSKeys vk ON
				fV.ValueSeriesID = vk.ValueSeriesID
						
			WHERE fV.ProductKey = @TemplateProductKey


		-- Possible Changes:
			-- New ValueSeries where created								=>	ok, exists empty
			-- ValueSeries where deleted									=>	ok, values lost
			-- ValueSeries of type Formula where changed in its definition	=>	ok, new formulas are used
			-- The timeline was changed										=>	ok, only fitting values are transfered
			-- ValueSeriesID or Names may be changed						=>	ok, but one must keept constant
			-- Typ of Input Series has changed from Int to Text etc.		=>	ok, empty then
			-- Scale of numeric Input Series has changed					=>  ok, old values will be rescaled


		-- STEP 3.5 - Update new Values by ID or Name
		IF @CompareByNameInsteadOfIDFlag = 0 -- compare by ID
		BEGIN
			-- Delete Values, which belong to calculated Series in Template
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesID IN (
									SELECT dVS.ValueSeriesID 
									FROM dbo.sx_pf_dValueSeries dVS
									WHERE
									dVS.ProductKey = @TemplateProductKey AND
									dVS.ValueSource IN ('XLS','XLS-Strict')
								  )
			-- Delete Values, which belong to no longer existing IDs
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesID NOT IN	(
											SELECT dVS.ValueSeriesID 
											FROM dbo.sx_pf_dValueSeries dVS
											WHERE
											dVS.ProductKey = @TemplateProductKey 
										)	
			-- Delete Values, which belong to no longer existing TimeIDs,
			DELETE FROM #ProductDataStorage WHERE
				TimeID NOT IN	(	
									SELECT dT.TimeID
									FROM dbo.sx_pf_dTime dT
									WHERE
									dT.ProductKey = @TemplateProductKey 
								)

			-- Delete Values in fact table which came from Template, to override them
			DELETE FROM dbo.sx_pf_fValues WHERE 
							ProductKey = @ProductKey AND
							(
								ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(255)) IN 
									(	
										SELECT ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(255)) 
										FROM #ProductDataStorage pds
									)
							)

			-- Insert all other Values
			INSERT INTO dbo.sx_pf_fValues
				SELECT 
					 vk.ValueSeriesKey
					,@ProductKey
					,@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductLineID
					,@FactoryID
					,pds.ValueSeriesID
					,pds.TimeID
					,'' AS ValueFormula
					,CAST(CAST(pds.ValueInt AS MONEY) / pds.Scale * vk.Scale AS BIGINT) --rescaling the int Values !!
					,pds.ValueText
					,pds.ValueComment

				FROM #ProductDataStorage pds LEFT JOIN #VSKeys vk ON pds.ValueSeriesID = vk.ValueSeriesID
			        
		END
		ELSE
		BEGIN -- compare by Name
			-- Delete Values, which belong to calculated Series in Template
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesName IN (SELECT dVS.NameShort
								  FROM dbo.sx_pf_dValueSeries dVS
								  WHERE
									dVS.ProductKey = @TemplateProductKey AND
									dVS.ValueSource IN ('XLS','XLS-Strict')
								  )
			-- Delete Values, which belong to no longer existing Names
			DELETE FROM #ProductDataStorage WHERE
				ValueSeriesName NOT IN (SELECT dVS.NameShort
								  FROM dbo.sx_pf_dValueSeries dVS
								  WHERE
									dVS.ProductKey = @TemplateProductKey 
								  )

			-- Delete Values, which belong to no longer existing TimeIDs,
			DELETE FROM #ProductDataStorage WHERE
				TimeID NOT IN	(	
									SELECT dT.TimeID
									FROM dbo.sx_pf_dTime dT
									WHERE
									dT.ProductKey = @TemplateProductKey 
								)

			-- Delete Values in fact table which came from Template, to override them
			DELETE fV FROM dbo.sx_pf_fValues fV LEFT JOIN sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey
						 WHERE 
							fV.ProductKey = @ProductKey AND
							(
								dVS.NameShort + '_' + CAST(TimeID AS NVARCHAR(255)) IN 
									(	
										SELECT pds.ValueSeriesName + '_' + CAST(TimeID AS NVARCHAR(255)) 
										FROM #ProductDataStorage pds
									)
							)

			-- Insert all other Values, if they fit to timeline
			INSERT INTO dbo.sx_pf_fValues
				SELECT 
					 vk.ValueSeriesKey
					,@ProductKey
					,@ProductLineKey
					,@FactoryKey
					,@ProductID
					,@ProductLineID
					,@FactoryID
					,dVS.ValueSeriesID
					,pds.TimeID
					,'' AS ValueFormula
					,CAST(CAST(pds.ValueInt AS MONEY) / pds.Scale * vk.Scale AS BIGINT) --rescaling the int Values !!
					,pds.ValueText
					,pds.ValueComment

				FROM #ProductDataStorage pds 
					-- to determine ValueSeries Key
					LEFT JOIN #VSKeys vk ON pds.ValueSeriesName = vk.ValueSeriesName
					
					-- to determine new ValueSeriesID
					LEFT JOIN (SELECT dVS.ValueSeriesID,dVS.NameShort FROM dbo.sx_pf_dValueSeries dVS WHERE dVS.ProductKey = @TemplateProductKey) dVS ON
						dVS.NameShort = pds.ValueSeriesName

				-- filter only fitting TimeIDs
				WHERE pds.TimeID IN (
										SELECT TimeID 
										FROM dbo.sx_pf_dTime dT 
										WHERE dT.ProductKey = @TemplateProductKey
									)

		END;

		-- Create a System Statement
		INSERT INTO [dbo].[sx_pf_fStatements]  
		SELECT  
			  @ProductKey
			, @ProductLineKey
			, @FactoryKey
			, @ProductID
			, @ProductlineID
			, @FactoryID
			, N'POST_Template' AS ActionType
			, N'Product Template updated with Template Factory <' + @TemplateFactoryID + N'>"' 
				+ @TemplateFactoryNameShort + N'"/ ProductLine <' + @TemplateProductlineID + N'>"' 
				+ @TemplateProductLineNameShort + N'"/ Product <' + @TemplateProductID + N'>"' 
				+ @TemplateProductNameShort +'"' AS [Statement]
			, @TransactUsername AS UserName
			, N'' AS PCName
			, N'' AS ProcessorCode
			, N'' AS IPAddresses
			, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10), GETDATE(), 108), 5), N':', N'') AS BIGINT) AS [Timestamp]
			, 0 AS IsDeleted
			, 0 AS IsResolved;

		-- STEP 3.4 - Update the TemplateName of the Product
		UPDATE [dbo].[sx_pf_dProducts]
		SET   Template = @TemplateName
			, TimeType = RIGHT(Template, 2) 
		WHERE ProductKey = @ProductKey;

		SET @EffectedRows += @@ROWCOUNT;
		
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Template] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Template] TO pf_PlanningFactoryService;
GO
/*
POST Operation for TimeID
Create new TimeID

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID / TimeID =0  => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / Productline / Product / ValueSeries keys => 404 Not Found
5. TimeID created => 201 Created

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @ProductID AS NVARCHAR(255)='52'
		DECLARE  @ProductLineID AS NVARCHAR(255)='ZT'
		DECLARE  @FactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TimeID AS INT =20150728	

-- TODO: Set parameter values here.

EXECUTE @RC = [sx_pf_POST_TimeID] 
   @Username
  ,@ProductID
  ,@ProductLineID
  ,@FactoryID
  ,@TimeID

PRINT @RC
*/
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_TimeID]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_TimeID];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_TimeID]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@TimeID AS INT
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
		
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',' + ISNULL(CAST(@TimeID AS NVARCHAR(255)), N'NULL');
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @TimeID IS NULL SET @TimeID = 0;

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		IF @TimeID = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 0.2 - Protect input parameters	
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		
		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;	

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID  AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID  AND ProductLineKey = @ProductLinekey AND FactoryKey = @FactoryKey;

		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 2.1 - Test if TimeID exists
		IF EXISTS(SELECT TimeID FROM [dbo].[sx_pf_dTime] WHERE [ProductKey] = @ProductKey AND TimeID = @TimeID)
		BEGIN
			SET @ResultCode = 204;
		END;

		-- STEP 3 - Create new entry if TimeID does not exist

		IF @ResultCode != 204
		BEGIN
			INSERT INTO [dbo].[sx_pf_dTime] 
				 (
				 [ProductKey]
				,[ProductLineKey]
				,[FactoryKey]
				,[ProductID]
				,[ProductLineID]
				,[FactoryID]
				,[TimeID]
				)
			VALUES 
				(
				@ProductKey,
				@ProductLineKey,
				@FactoryKey,
				@ProductID,
				@ProductLineID,
				@FactoryID,
				@TimeID
				);

			SET @ResultCode = 201;
			SET @EffectedRows = @@ROWCOUNT;
		END

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF (@ResultCode IS NULL OR @ResultCode/100 = 2) AND @ResultCode <> 204
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
    
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_TimeID] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_TimeID] TO pf_PlanningFactoryService;
GO
/*
POST Operation for the Timeline
The method can be switched between incremental POST and full POST
Values with DeleteFlag will be deleted
Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectValueArray
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / Productline / Product keys => 404 Not Found
5. Product updated => 200 OK

Test case 1 - Incremental Sended
1. One Value for an existing Value must replace them
2. One Value for an not exiting Value must create it
3. If all Parameter are posted empty, the value is deleted
4. if one or more of the parameter are sended with <#NV> there Value is replaced with the existing value (or nothing if it exists not)

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '23'
DECLARE @ProductLineID nvarchar(255) = '1'
DECLARE @FactoryID nvarchar(255) = 'U'
DECLARE @IsIncrementalValuesFlag INT = 0

--3 TimeIDs
DECLARE @TimeIDsInBracketsCommaSeparated nvarchar(max) = '[(20160115,0,0,''AliasName1'')],[(20160215,0,0,''AliasName2'')],[(20160415,0,0,''AliasName3'')]'


EXECUTE @RC = [sx_pf_POST_Timeline]
	 @Username
	,@ProductID
	,@ProductLineID
	,@FactoryID
	,@IsIncrementalValuesFlag
	,@TimeIDsInBracketsCommaSeparated

PRINT @RC

Test case 2 - all values in a Value Series of Products:
Additional 1. Empty FactoryID / ProductLineID / ProductID / ValueSeriesID / TimeID => 404 Not Found

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '21'
DECLARE @ProductLineID nvarchar(255) = '1'
DECLARE @FactoryID nvarchar(255) = 'U'
DECLARE @IsIncrementalValuesFlag INT = 0

DECLARE @TimeIDsInBracketsCommaSeparated nvarchar(max) = ''
DECLARE @start_time DATETIME

-- Generate fictitious values for all TimeIDs of Products
SELECT @TimeIDsInBracketsCommaSeparated =  @TimeIDsInBracketsCommaSeparated + '[(''' + dVS2.ValueSeriesID + ''',' + CAST(TimeID AS nvarchar(255)) +',''=A2'',1000,''Hase'',''Kommentar'')],' 
FROM sx_pf_fValues fV LEFT JOIN 
	sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey LEFT JOIN
	(SELECT ValueSeriesID FROM sx_pf_dValueSeries WHERE FactoryID =  @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID GROUP BY ValueSeriesID) dVS2
		ON 1=1 
WHERE fV.FactoryID =  @FactoryID AND fV.ProductLineID = @ProductLineID AND fV.ProductID = @ProductID AND dVS.ValueSeriesNo = 1

SET @TimeIDsInBracketsCommaSeparated = Left(@TimeIDsInBracketsCommaSeparated,Len(@TimeIDsInBracketsCommaSeparated) -1)

PRINT @TimeIDsInBracketsCommaSeparated

SET @start_time = GETDATE()

EXECUTE @RC = [sx_pf_POST_ProductDataTableValues] 
	 @Username
	,@ProductID
	,@ProductLineID
	,@FactoryID
	,@IsIncrementalValuesFlag
	,@TimeIDsInBracketsCommaSeparated

PRINT @RC

SELECT RTRIM(CAST(DATEDIFF(MS, @start_time, GETDATE()) AS CHAR(10))) AS 'TimeTaken'
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Timeline]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Timeline];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Timeline]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@IsIncrementalValuesFlag AS INT,
	@TimeIDsInBracketsCommaSeparated AS NVARCHAR(MAX)
/*
@TimeIDsInBracketsCommaSeparated format: (TimeID,DeleteFlag,AddValue,AliasName)
if you check this in SQL Server Profiler, every String must have two inverted commas, the whole Parameter must have Single inverted comma
this must show profiler: '[(''TimeID,DeleteFlag,AddValue,''AliasName'')],[(TimeID,DeleteFlag,AddValue,AliasName)]'

if you check this in table sx_pf_API_Log, every String must have one inverted comma, whole String has no inverted comma
this must show Log: [(TimeID,DeleteFlag,AddValue,AliasName)],[(TimeID,DeleteFlag,AddValue,'AliasName')]
*/
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@TimeIDsInBracketsCommaSeparated, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @IsIncrementalValuesFlag IS NULL SET @IsIncrementalValuesFlag = 0;
	IF @TimeIDsInBracketsCommaSeparated IS NULL SET @TimeIDsInBracketsCommaSeparated = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
		
		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID)
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID)
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID)
		SET @TimeIDsInBracketsCommaSeparated = [dbo].[sx_pf_pProtectValueArray] (@TimeIDsInBracketsCommaSeparated)

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey =  @ProductLineKey AND ProductID = @ProductID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		
		-- STEP 3.2 - Check for count of delimiter in Array

		DECLARE @OpenDelimetersCount INT = 0;
		DECLARE @DelimetersIndex INT = CHARINDEX(N'[(', @TimeIDsInBracketsCommaSeparated);

		WHILE (@DelimetersIndex > 0) BEGIN
			SET @OpenDelimetersCount += 1;
			SET @DelimetersIndex = CHARINDEX(N'[(', @TimeIDsInBracketsCommaSeparated, @DelimetersIndex + 1);
		END;
				
		IF @OpenDelimetersCount = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('No delimiters found in @TimeIDsInBracketsCommaSeparated', 16, 10);
		END;

		SET @DelimetersIndex = CHARINDEX(N')]', @TimeIDsInBracketsCommaSeparated);

		WHILE (@DelimetersIndex > 0) BEGIN
			SET @OpenDelimetersCount -= 1;
			SET @DelimetersIndex = CHARINDEX(N')]', @TimeIDsInBracketsCommaSeparated, @DelimetersIndex + 1);
		END;

		IF @OpenDelimetersCount <> 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Invalid count of delimiter in @TimeIDsInBracketsCommaSeparated', 16, 10);
		END;

		-- STEP 3.3 - Splitt the Array with the new values for the Product to a temporary table #######################################################################################################################
		-- cut leading/following brackets and ' from ValueSeriesID
		SET @TimeIDsInBracketsCommaSeparated = LEFT(@TimeIDsInBracketsCommaSeparated, LEN(@TimeIDsInBracketsCommaSeparated) - 2);
		SET @TimeIDsInBracketsCommaSeparated = RIGHT(@TimeIDsInBracketsCommaSeparated, LEN(@TimeIDsInBracketsCommaSeparated) - 2);

		DECLARE @tblValues1 TABLE (txtValuesPipe NVARCHAR(MAX));
		DECLARE @tblValues2 TABLE (TimeID NVARCHAR(MAX), txtValuesPipe NVARCHAR(MAX));
		DECLARE @tblValues3 TABLE (TimeID BIGINT, DeleteFlag INT, txtValuesPipe NVARCHAR(MAX));
		DECLARE @tblValues4 TABLE (TimeID BIGINT, DeleteFlag INT, AddValue BIGINT, AliasName NVARCHAR(255));

		-- Split String into Rows
		INSERT INTO @tblValues1 
			SELECT txtValues FROM [dbo].sx_pf_PivotStringIntoTable(@TimeIDsInBracketsCommaSeparated, N')],[(');

		-- Split one column into two Columns (separate TimeID)
		INSERT INTO @tblValues2
			SELECT  
				 LEFT(txtValuesPipe, CHARINDEX(N',', txtValuesPipe)-1 ) AS TimeID
				,RIGHT(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N',', txtValuesPipe)) AS Rest
			FROM @tblValues1;

		IF EXISTS(SELECT TimeID FROM @tblValues2 GROUP BY TimeID HAVING(COUNT(TimeID) > 1))
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Doubled TimeID in @TimeIDsInBracketsCommaSeparated', 16, 10);
		END;

		-- Split last columns once more (separate DeleteFlag)
		INSERT INTO @tblValues3
			SELECT  
				 TimeID
				,LEFT(txtValuesPipe, CHARINDEX(N',', txtValuesPipe) - 1) AS DeleteFlag
				,Right(txtValuesPipe, Len(txtValuesPipe) - CHARINDEX(N',', txtValuesPipe)-1) AS Rest
			FROM @tblValues2;

		-- Split last columns once more (separate AddValue)
		INSERT INTO @tblValues4
			SELECT  
				 TimeID
				,DeleteFlag
				,LEFT(txtValuesPipe, CHARINDEX(N',', txtValuesPipe) - 1) AS AddValue
				,Replace(Right(txtValuesPipe, LEN(txtValuesPipe) - 1), N'''','') AS AliasName
			FROM @tblValues3;

		-- STEP 3.4 - Actions #######################################################################################################################
	
		-- Delete TimeIDs which are sended as deleted in fValues and in dTime
		DELETE FROM [dbo].[sx_pf_dTime] 
			WHERE @ProductKey = @ProductKey AND TimeID IN 
			(SELECT TimeID FROM @tblValues4 WHERE DeleteFlag = 1);
	
		DELETE FROM [dbo].[sx_pf_fValues] 
		WHERE ProductKey = @ProductKey AND TimeID IN 
			(SELECT TimeID FROM @tblValues4 WHERE DeleteFlag = 1);

		SET @EffectedRows = @@ROWCOUNT;


		-- STEP 3.5 - CASE FULL transmission or Incremental does not matter anymore #########################################
		IF @IsIncrementalValuesFlag != 1 OR  @IsIncrementalValuesFlag = 1 
		BEGIN
			-- Insert all New TimeIDs
			INSERT INTO [dbo].[sx_pf_dTime] 

				SELECT  
					@ProductKey,
					@ProductLineKey,
					@FactoryKey,
					@ProductID,
					@ProductLineID,
					@FactoryID,
					TimeID

				FROM @tblValues4 WHERE TimeID NOT IN 
													(
														SELECT TimeID FROM sx_pf_dTime WHERE ProductKey = @ProductKey
													)
				
			SET @EffectedRows += @@ROWCOUNT;
		END;
			
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Timeline] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Timeline] TO pf_PlanningFactoryService;
GO
-- UNUSED BLOCKS

-- Create Placeholder in Series No 1 

		-- Delete ValueSeriesNo1 Values FROM this product

		-- Write Values of ValueSerisNo1 of this Product

		-- Add the Add Value from the sended Values to the TimeIDs


		-- Handle VMT #######################################################################################################################

									-- Determine Documentation entrys

										---- NEW is a Value which is not contained in existing Values
										--UPDATE @tblTimeMergeTable SET DocuCode = 'NEW VALUE'
										--WHERE ProcessCode = 'SENDED VALUES' AND
										--	 ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) NOT IN 
										--			(
										--			SELECT 
										--				ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10))
										--			FROM  @tblTimeMergeTable WHERE ProcessCode = 'OLD VALUES'
										--			) AND
										--	 DocuCode = 'NONE' 

										---- CHANGED is a Value which is contained in existing Values
										--UPDATE @tblTimeMergeTable SET DocuCode = 'CHANGED VALUE'
										--WHERE ProcessCode = 'SENDED VALUES' AND
										--	 ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) IN 
										--			(
										--			SELECT 
										--				ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10))
										--			FROM  @tblTimeMergeTable WHERE ProcessCode = 'OLD VALUES'
										--			) AND
										--	 DocuCode = 'NONE' 

										-- TODO: 
										/* INSERT INTO sx_pf_AuditLog VALUES
											SELECT * FROM @tblTimeMergeTable WHERE 
												ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) IN 
												(
												SELECT
													ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) FROM @tblTimeMergeTable WHERE ProcessCode = 'SENDED VALUES' AND
													DocuCode != 'NONE'
												)
										*/

-- CASE INCREMENTAL Transmission - it also leads to a full delete and insert !! #########################################
		
							--IF @IsIncrementalValuesFlag = 1 
							--	BEGIN

							--	    -- DELETE Values, which are sended to delete in OLD VALUES
							--		DELETE FROM @tblTimeMergeTable WHERE ProcessCode = 'OLD VALUES TO DELETE'

							--		-- DELETE Sended Values the user want to delete
							--		DELETE FROM @tblTimeMergeTable WHERE ProcessCode = 'SENDED VALUES' AND
							--			 [IsNumeric] = 1 AND IsFormula = 0 AND (ValueInt = '0' OR ValueInt = '')

							--		DELETE FROM @tblTimeMergeTable WHERE ProcessCode = 'SENDED VALUES' AND
							--			 [IsNumeric] = 1 AND IsFormula = 1 AND (ValueInt = '0' OR ValueInt = '') AND ValueFormula = ''

							--		DELETE FROM @tblTimeMergeTable WHERE ProcessCode = 'SENDED VALUES' AND
							--			 [IsNumeric] = 0 AND IsFormula = 0 AND ValueText = ''

							--		DELETE FROM @tblTimeMergeTable WHERE ProcessCode = 'SENDED VALUES' AND
							--			 [IsNumeric] = 0 AND IsFormula = 1 AND ValueText = '' AND ValueFormula = ''
					 
							--		-- Create New Placeholder Values in VMT
							--		INSERT INTO @tblTimeMergeTable 
							--			SELECT
							--					 @ValueSeriesNo1Key
							--					,@ValueSeriesNo1ID
							--					,1 AS ValueSeriesNo
							--					,0 AS ValueKey
							--					,TimeID
							--					,''
							--					,0
							--					,'-'
							--					,''
							--					,0 AS [IsNumeric]
							--					,0 AS IsFormula
							--					,'PLACEHOLDER' AS ProcessCode
							--					,'NONE' AS DocuCode
							--			FROM @tblTimeline WHERE TimeID NOT IN 
							--				(SELECT TimeID FROM @tblTimeMergeTable WHERE ValueSeriesNo = 1 AND ProcessCode IN ('SENDED VALUES','OLD VALUES') GROUP BY TimeID)
			
							--		-- Delete all Values
							--		DELETE FROM sx_pf_fValues WHERE ProductKey = @ProductKey AND ValueSeriesKey = @ValueSeriesNo1Key

							--		-- DELETE OLD VALUES which are new sended

							--		DELETE FROM @tblTimeMergeTable WHERE ProcessCode = 'OLD VALUES' AND 
							--			ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10)) IN 
							--					(
							--					SELECT 
							--						ValueSeriesID + '_' + CAST(TimeID AS NVARCHAR(10))
							--					FROM  @tblTimeMergeTable WHERE ProcessCode = 'SENDED VALUES'
							--					) 


							--		-- Insert all Values
							--		INSERT INTO sx_pf_fValues
							--			SELECT 
							--				 ValueSeriesKey
							--				,@ProductKey
							--				,@ProductLineKey
							--				,@FactoryKey
							--				,@ProductID
							--				,@ProductLineID
							--				,@FactoryID
							--				,ValueSeriesID
							--				,TimeID
							--				,ValueFormula
							--				,CAST(ValueInt AS bigint)
							--				,ValueText
							--				,ValueComment
							--			FROM @tblTimeMergeTable WHERE ProcessCode IN ('SENDED VALUES', 'OLD VALUES','PLACEHOLDER')
							--		END
/*
POST Operation for a User
Not existing User will be created, existing one updated
If attributes passed  with value <#NV>, it will be ignored during the update and maintain the existing value, during insert the attribute is created empty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PostUserName is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username has no write access to the cluster at Create => 401 Unauthorized
4. PostUserName created => 201 Created
5. PostUserName updated => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @PostUserName AS NVARCHAR(255) = 'sx'
		DECLARE @PersonSurname AS NVARCHAR(255) = ''
		DECLARE @PersonFirstName AS NVARCHAR(255) = ''
		DECLARE @Email AS NVARCHAR(255) = ''
		DECLARE @LDAPIP AS NVARCHAR(255) = ''
		DECLARE @Status AS NVARCHAR(255) = ''
		DECLARE @ImageName AS NVARCHAR(255) = ''

EXECUTE @RC = [sx_pf_POST_User] 
		@Username,
		@PostUserName,
		@PersonSurname,
		@PersonFirstName,
		@Email,
		@LDAPIP,
		@Status

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_User]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_User];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_User]
	@Username AS NVARCHAR(255),
	@PostUserName AS NVARCHAR(255),
    @PersonSurname AS NVARCHAR(255),
    @PersonFirstName AS NVARCHAR(255),
    @Email AS NVARCHAR(255),
    @LDAPIP AS NVARCHAR(255),
    @Status AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @PostUserKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255)= N'';
	DECLARE @tmpUserTable AS TABLE (UserKey INT);

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PostUserName, N'NULL') + N''',''' + ISNULL(@PersonSurname, N'NULL') 
		+ N''',''' + ISNULL(@PersonFirstName, N'NULL') + N''',''' + ISNULL(@Email, N'NULL') + N''',''' + ISNULL(@LDAPIP, N'NULL') + N''',''' + ISNULL(@Status, N'NULL') + N'''';

	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @PostUserName IS NULL SET @PostUserName =  N'';
	IF @PersonSurname IS NULL SET @PersonSurname =  N'';
	IF @PersonFirstName IS NULL SET @PersonFirstName =  N'';
	IF @Email IS NULL SET @Email =  N'';
	IF @LDAPIP IS NULL SET @LDAPIP =  N'';
	IF @Status IS NULL SET @Status =  N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters	
		SET @PostUserName = [dbo].[sx_pf_pProtectString] (@PostUserName);
		SET @PersonSurname = [dbo].[sx_pf_pProtectString] (@PersonSurname);
		SET @PersonFirstName = [dbo].[sx_pf_pProtectString] (@PersonFirstName);
		SET @Email = [dbo].[sx_pf_pProtectString] (@Email);
		SET @LDAPIP = [dbo].[sx_pf_pProtectString] (@LDAPIP);
		SET @Status = [dbo].[sx_pf_pProtectString] (@Status);

		IF @PostUserName = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	

		-- STEP 1.1 - Don`t allow creation or changing of systemuser SQL
		-- the Username "FactoryService" is not allowed, as it would lead to confusion with the similar named db role
		IF @PostUserName = N'SQL' OR @PostUserName = N'FactoryService'	
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Forbidden creation or changing of systemuser', 16, 10);
		END;
			
		-- STEP 1.2 - Don't allow changes on the members of the DB role pf_PlanningFactoryService (which are not visible in the frontend) - not over the function IS_ROLEMEMBER, its buggy
		IF EXISTS(SELECT r.name from sys.database_role_members rm 
			INNER JOIN sys.database_principals r on rm.role_principal_id = r.principal_id
			INNER JOIN sys.database_principals m on rm.member_principal_id = m.principal_id
			WHERE r.name = 'pf_PlanningFactoryService' AND m.name = @PostUserName)
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Don`t allow changes on the members of the DB role pf_PlanningFactoryService', 16, 10);
		END;

		-- STEP 1.2 - Don`t allow the user 'public' to change his Rights
		IF LOWER(@UserName) = 'public'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Don`t allow the user ''public'' to change his Rights', 16, 10);
		END;

		-- STEP 1.2 - Determine transaction user, the transactuser 'public' is not allowed to change rights
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END 
		ELSE IF @TransactUsername = N'public'
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('''Public'' user is not allowed to change rights', 16, 10);
		END;
					
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);	

		-- The Clusteradmin can`t set himself to Inactive
		IF @TransactUsername = @PostUsername AND @Status <> 'Active' 
			SET @Status = 'Active';
		
		-- STEP 2 - Get keys
		SELECT @PostUserKey = UserKey FROM sx_pf_rUser WHERE Username = @PostUserName
				
		-- STEP 3.1 - If user does not yet exist, it will be created
		IF @PostUserKey = 0
		BEGIN
			INSERT INTO [dbo].[sx_pf_rUser] (UserName) 
			OUTPUT Inserted.UserKey INTO @tmpUserTable 
			VALUES (@PostUserName);
			
			SET @EffectedRows = 1;
				
			-- the determination on the table variable is necessary because of TRIGGERS on rUser
			SELECT TOP 1 @PostUserKey = UserKey FROM @tmpUserTable;
						
			SET @Resultcode = 201;
		END

		-- STEP 3.2 - Update the User with the commited attributes
		UPDATE [dbo].[sx_pf_rUser]
		SET PersonSurname = IIF(@PersonSurname = N'<#NV>', PersonSurname, @PersonSurname)
			, PersonFirstName = IIF(@PersonFirstName = N'<#NV>', PersonFirstName, @PersonFirstName)
			, Email = IIF(@Email = N'<#NV>', Email, @Email)
			, LDAPIP = IIF(@LDAPIP = N'<#NV>', LDAPIP, @LDAPIP)
			, [Status] = IIF(@Status = N'<#NV>', [Status], @Status)
		FROM [dbo].[sx_pf_rUser]
		WHERE UserKey = @PostUserKey;

		SET @EffectedRows += @@ROWCOUNT;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_User] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_User] TO pf_PlanningFactoryService;
GO
/*
POST Operation for Value
The Value will be deleted and writen new

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

07/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID / ValueSeriesID / TimeID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no rights => 401 Unauthorized
4. Non exists Factory / Productline keys => 404 Not Found
5. Not existing template for new ProductID => 404 Not Found
6. Product created => 201 Created
7. Product deleted => 204 No content
8. Empty text passed without value formula in Value Series 1 => placeholder "-"

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = 'U'
DECLARE @FactoryID nvarchar(255) = 'ZT'
DECLARE @ValueSeriesID nvarchar(255) = 'E1'
DECLARE @TimeID bigint = 20160315
DECLARE @ValueFormula nvarchar(max) = '<#NV>'
DECLARE @ValueInt NVARCHAR(255) = '555' 
DECLARE @ValueText nvarchar(max) = 'Hase2'
DECLARE @ValueComment nvarchar(max) = 'Hase2'
DECLARE @i as INTEGER = 0

-- individual values 
-- Text with Comment
EXECUTE @RC = [sx_pf_POST_Value] @Username,@ProductID,@ProductLineID,@FactoryID,'E1',20160115,'',0,'Hase','Kommentar für Hase'
PRINT @RC

-- Integer with Comment
EXECUTE @RC = [sx_pf_POST_Value] @Username,@ProductID,@ProductLineID,@FactoryID,'K1',20160215,'',44,'','Kommentar für Hase44'
PRINT @RC

-- 1b. Variant with loop
--WHILE @i < 1000
--BEGIN
EXECUTE @RC = [sx_pf_POST_Value] @Username,@ProductID,@ProductLineID,@FactoryID,@ValueSeriesID,@TimeID,@ValueFormula,@i,@ValueText,@ValueComment
--SET @i = @i +1
PRINT @RC
END

-- 2. Variant with Script Creator
PRINT 'DECLARE @RC as INTEGER = 0'

WHILE @i < 5000
BEGIN
	PRINT 'EXECUTE @RC = sx_pf_POST_Value ''' + @Username + ''','''+ @ProductID+ ''','''+@ProductLineID+ ''','''+ @FactoryID + ''','''+ @ValueSeriesID + ''','+ CAST(@TimeID AS NVARCHAR (8)) + ','''+ @ValueFormula + ''','+ CAST(@i AS NVARCHAR(10)) + ','''+@ValueText+ ''','''+	@ValueComment + ''''
	PRINT 'PRINT @RC' 
	SET @i = @i +1 
END
--about 12 sec for 5000 Values Values = 400 / second
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_Value]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_Value];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_Value]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ValueSeriesID AS NVARCHAR(255),		
	@TimeID AS INT,
	@ValueFormula AS NVARCHAR(MAX),
	@ValueInt AS NVARCHAR(255), -- to be able to send <#NV>
	@ValueText AS NVARCHAR(MAX),
	@ValueComment AS NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSeriesKey AS INT = 0;
	DECLARE @ValueKey AS INT = 0;
	DECLARE @RightCode AS INT = 501;
	DECLARE @Right as NVARCHAR (255) = N'';
	DECLARE @ValueSeriesNo AS INT = 0;

	DECLARE @OLDValueFormula NVARCHAR (255) = N'';
	DECLARE @OLDValueInt BIGINT = 0; 
	DECLARE @OLDValueText NVARCHAR (255) = N'';
	DECLARE @OLDValueComment NVARCHAR (MAX) = N'';

	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ValueSeriesID, N'NULL') + N''',' + ISNULL(CAST(@TimeID AS NVARCHAR(255)), N'NULL') 
		+ N',''' + ISNULL(@ValueFormula, N'NULL') + N''',''' + ISNULL(@ValueInt, N'NULL') + N''',''' + ISNULL(@ValueText, N'NULL') 
		+ N''',''' + ISNULL(@ValueComment, N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;				-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;				-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';			-- SET during Execution
	
	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ValueSeriesID IS NULL SET @ValueSeriesID = N'';
	IF @TimeID IS NULL SET @TimeID = 0;
	IF @ValueFormula IS NULL SET @ValueFormula = N'';
	IF @ValueInt IS NULL SET @ValueInt = N'';
	IF @ValueText IS NULL SET @ValueText = N'';
	IF @ValueComment IS NULL SET @ValueComment = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters	
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ValueSeriesID = [dbo].[sx_pf_pProtectID] (@ValueSeriesID);
		SET @TimeID = [dbo].[sx_pf_pProtectID] (@TimeID);
		SET @ValueFormula = [dbo].[sx_pf_pProtectString] (@ValueFormula);
		SET @ValueInt = [dbo].[sx_pf_pProtectString] (@ValueInt);
		SET @ValueText = [dbo].[sx_pf_pProtectString] (@ValueText);
		SET @ValueComment = [dbo].[sx_pf_pProtectString] (@ValueComment);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N'' OR @ValueSeriesID = N'' OR @TimeID = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;	

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

 	     -- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);	

		-- STEP 1.3 - Try to detect and cancel the ValueSeriesKey if does not exist
		SELECT @ValueSeriesKey = ValueSeriesKey, @ValueSeriesNo = ValueSeriesNo FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey= @ProductKey AND ValueSeriesID =  @ValueSeriesID;
		IF @ValueSeriesKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 2.1 - Cancel if TimeID not exists	
		IF NOT EXISTS(SELECT TimeID FROM [dbo].[sx_pf_dTime] WHERE ProductKey = @ProductKey AND TimeID = @TimeID)
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('TimeID not exists', 16, 10);
		END;

		-- STEP 3. Determine ValueKey identify and old values
		SELECT @ValueKey = ValueKey, @OLDValueFormula = ValueFormula, @OLDValueInt = ValueInt, @OLDValueText = ValueText, @OLDValueComment = ValueComment
		FROM [dbo].[sx_pf_fValues] 
		WHERE ValueSeriesKey = @ValueSeriesKey AND TimeID = @TimeID;
				
		-- STEP 3.1 - If Value Key exists delete
		IF  @ValueKey > 0 
		BEGIN
			DELETE FROM [dbo].[sx_pf_fValues] 
			WHERE ValueKey = @ValueKey;

			SET @EffectedRows = @@ROWCOUNT;
			SET @ResultCode = 204; -- Ok, but deleted

			SET @ValueFormula = IIF(@ValueFormula = N'<#NV>', @OLDValueFormula, @ValueFormula);
			SET @ValueText = IIF(@ValueText = N'<#NV>', @OLDValueText, @ValueText);
			SET @ValueComment = IIF(@ValueComment = N'<#NV>', @OLDValueComment, @ValueComment);
			SET @ValueInt = IIF(@ValueInt = N'<#NV>', @OLDValueInt, @ValueInt);
		END
		ELSE
		BEGIN
			SET @ValueFormula = IIF(@ValueFormula = N'<#NV>', N'', @ValueFormula);
			SET @ValueText = IIF(@ValueText = N'<#NV>', N'', @ValueText);
			SET @ValueComment = IIF(@ValueComment = N'<#NV>', N'', @ValueComment);
			SET @ValueInt = IIF(@ValueInt = N'<#NV>', N'0', @ValueInt);
		END;

		-- STEP 3.2 - Insert, while no empty values outside of column 1
		IF @ValueFormula = N'' AND @ValueText = N'' AND @ValueInt = N'0'
		BEGIN 
			SET @ResultCode = 204; --> discarded !!! 
		END
		ELSE
		BEGIN 
			SET @ValueInt = COALESCE(TRY_CAST(@ValueInt AS BIGINT), 0);

			INSERT INTO [dbo].[sx_pf_fValues]
			VALUES (@ValueSeriesKey, @ProductKey, @ProductLineKey, @FactoryKey, @ProductID, @ProductLineID, @FactoryID, @ValueSeriesID,  @TimeID,  
				@ValueFormula, @ValueInt, @ValueText, @ValueComment);
			
			SET @EffectedRows += @@ROWCOUNT;
			SET @ResultCode = 201;
		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Value] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_Value] TO pf_PlanningFactoryService;
GO
/*
POST Operation for a ValueArray
The Value Series will be deleted completly and written new

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID / ValueSeriesID / TimeID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / Productline keys => 404 Not Found
5. Product created => 201 Created
6. Product updated => 200 OK

--Test case 1:

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '3'
DECLARE @ProductLineID nvarchar(255) = '7'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ValueSeriesID nvarchar(255) = 'K3'
DECLARE @ValueSeriesNo INT = 3
DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = '(20150115,''=IF(H25=4,3,2.1)'',555,''HaseTextValue'',''HaseComment''),(20150215,''=IF(H25=4,3,2)'',555,''HaseTextValue'',''HaseComment''),(20150315,''=A1'',555,''HaseTextValue'',''HaseComment'')'

EXECUTE @RC = [sx_pf_POST_ValueArray] @Username,@ProductID,@ProductLineID,@FactoryID,@ValueSeriesID,@ValueSeriesNo,@ValuesInBracketsCommaSeparated
PRINT @RC

--Test case 2 - all values in a Value Series of Products:

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @ProductID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ValueSeriesID nvarchar(255) = 'K1'
DECLARE @ValueSeriesNo INT = 1
DECLARE @ValuesInBracketsCommaSeparated nvarchar(max) = ''
DECLARE @start_time DATETIME


-- generate fictive values for all TimeIDs of Products
SELECT @ValuesInBracketsCommaSeparated =  @ValuesInBracketsCommaSeparated + '(' + CAST(TimeID AS nvarchar(255)) +', ''=A2'',1000,''Hase'',''Kommentar''),' 
FROM sx_pf_fValues 
WHERE FactoryID =  @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID 
GROUP BY TimeID

SET @ValuesInBracketsCommaSeparated = Left(@ValuesInBracketsCommaSeparated,Len(@ValuesInBracketsCommaSeparated) -1)

PRINT @ValuesInBracketsCommaSeparated

SET @start_time = GETDATE()

EXECUTE @RC = [sx_pf_POST_ValueArray] @Username,@ProductID,@ProductLineID,@FactoryID,@ValueSeriesID,@ValueSeriesNo,@ValuesInBracketsCommaSeparated
PRINT @RC

SELECT RTRIM(CAST(DATEDIFF(MS, @start_time, GETDATE()) AS CHAR(10))) AS 'TimeTaken'
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ValueArray]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ValueArray];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ValueArray]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ValueSeriesID AS NVARCHAR(255),
	@ValueSeriesNo AS INT,
	@ValuesInBracketsCommaSeparated AS NVARCHAR(MAX) 
/* 
@ValuesInBracketsCommaSeparated format:
(TimeID,Formula,Value,ValueText,ValueComment),(TimeID,Formula,Value,ValueText,ValueComment)
if you check this in SQL Server Profiler, every String must have two inverted commas, the whole Parameter must have Single inverted comma
this must show profiler: '(TimeID,''Formula'',Value,''ValueText'',''ValueComment''),(TimeID,''Formula'',Value,''ValueText'',''ValueComment'')'

if you check this in table sx_pf_API_Log, every String must have one inverted comma, whole String has no inverted comma
this must show Log: (TimeID,'Formula',Value,'ValueText','ValueComment'),(TimeID,'Formula',Value,'ValueText','ValueComment')
*/
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername AS NVARCHAR(255) = N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSeriesKey AS INT = 0;
	DECLARE @ISNumeric AS INT = 0;
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ValueSeriesID, N'NULL') + N''',' + ISNULL(CAST(@ValueSeriesNo AS NVARCHAR(255)), N'NULL') 
		+ N',''' + ISNULL(@ValuesInBracketsCommaSeparated, N'NULL') + N'''';
	
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ValueSeriesID IS NULL SET @ValueSeriesID = N'';
	IF @ValueSeriesNo IS NULL SET @ValueSeriesNo = 0;
	IF @ValuesInBracketsCommaSeparated IS NULL SET @ValuesInBracketsCommaSeparated = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ValueSeriesID = [dbo].[sx_pf_pProtectID] (@ValueSeriesID);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N'' OR @ValueSeriesID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
	
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey =  @ProductLineKey AND ProductID = @ProductID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
				
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
	
		-- STEP 2.1 - Determine ValueSeriesKey and cancel if it does not exist
		SELECT @ValueSeriesKey = ValueSeriesKey, @ValueSeriesNo = ValueSeriesNo, @ISNumeric =[IsNumeric]  
		FROM [dbo].[sx_pf_dValueSeries] 
		WHERE ProductKey = @ProductKey AND ValueSeriesNo = @ValueSeriesNo;
		
		IF @ValueSeriesKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('ValueSeriesKey don`t exists', 16, 10);
		END;
		
		-- STEP 3.1 - Delete old Values
		DELETE FROM [dbo].[sx_pf_fValues]
		WHERE ValueSeriesKey = @ValueSeriesKey;

		SET @EffectedRows = @@ROWCOUNT;

		-- cut leading/following brackets
		IF LEN(@ValuesInBracketsCommaSeparated) > 2 
		BEGIN
			SET @ValuesInBracketsCommaSeparated = LEFT(@ValuesInBracketsCommaSeparated, LEN(@ValuesInBracketsCommaSeparated)-1);
			SET @ValuesInBracketsCommaSeparated = RIGHT(@ValuesInBracketsCommaSeparated, LEN(@ValuesInBracketsCommaSeparated)-1);

			DECLARE @tblValues1 TABLE (txtValuesPipe NVARCHAR(MAX));
			DECLARE @tblValues2 TABLE (TimeID NVARCHAR(10), txtValuesPipe NVARCHAR(MAX));
			DECLARE @tblValues3 TABLE (TimeID NVARCHAR(10), ValueFormula NVARCHAR(MAX), txtValuesPipe NVARCHAR(MAX));
			DECLARE @tblValues4 TABLE (TimeID NVARCHAR(10), ValueFormula NVARCHAR(MAX), ValueInt BigInt, txtValuesPipe NVARCHAR(MAX));
			DECLARE @tblValues5 TABLE (TimeID NVARCHAR(10), ValueFormula NVARCHAR(MAX), ValueInt BigInt, ValueText NVARCHAR(MAX), ValueComment NVARCHAR(MAX));

			-- Split String into Rows
			INSERT INTO @tblValues1 
				SELECT REPLACE(REPLACE(txtValues, N',''', N'|'''), N''',', N'''|') 
				FROM [dbo].[sx_pf_PivotStringIntoTable] (@ValuesInBracketsCommaSeparated, N'),(');

			-- Split one column into two Columns 
			INSERT INTO @tblValues2
				SELECT LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 1) 
					, RIGHT(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe) - 1)
				FROM @tblValues1;

			-- Split last columns once more
			INSERT INTO @tblValues3
				SELECT TimeID
					, LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 2) 
					, RIGHT(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe))
				FROM @tblValues2;

			-- Split last columns once more
			INSERT INTO @tblValues4
				SELECT TimeID
					,ValueFormula
					,LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 1) 
					,RIGHT(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe) - 1)
				FROM @tblValues3;

			-- Split last columns once more
			INSERT INTO @tblValues5
				SELECT TimeID
					,ValueFormula
					,ValueInt
					,LEFT(txtValuesPipe, CHARINDEX(N'|', txtValuesPipe) - 2) 
					,LEFT(RIGHT(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe)-1),LEN(Right(txtValuesPipe, LEN(txtValuesPipe) - CHARINDEX(N'|', txtValuesPipe)-1))-1)
				FROM @tblValues4;

			-- DELETE useless Values
			IF @ValueSeriesNo <> 1 
			BEGIN
				DELETE FROM @tblValues5 WHERE (ValueText=N'' OR ValueText = N'-') AND ValueFormula = N'' AND ValueInt = 0;
			END;

			-- Dont accept Values outside Timeline
			DELETE FROM @tblValues5 WHERE TimeID NOT IN 
														(
															SELECT TimeID FROM sx_pf_dTime WHERE ProductKey = @ProductKey
														)

			-- STEP 3.2 - Insert Values into FactTable
			INSERT INTO [dbo].[sx_pf_fValues] 
				(ValueSeriesKey
				,ProductKey
				,ProductLineKey
				,FactoryKey
				,ProductID
				,ProductLineID
				,FactoryID
				,ValueSeriesID
				,TimeID
				,ValueFormula
				,ValueInt
				,ValueText
				,ValueComment) 
			SELECT @ValueSeriesKey
				,@ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,@ValueSeriesID
				,TimeID
				,ValueFormula
				,ValueInt
				,ValueText
				,ValueComment 
			FROM @tblValues5;

			SET @EffectedRows += @@ROWCOUNT;
			SET @ResultCode = 201;
		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ValueArray] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ValueArray] TO pf_PlanningFactoryService;
GO
/*
POST Operation for one ValueSeries
Operation will create a ValueSeries if it not exist
It will change an existing ValueSeries
Works under the assumtion, that the ValueSeries ID is not changed ! The ID is used to identify the valueSeries

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_pProtectBoolean
		- sx_pf_pProtectInt
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

01/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID / ValueSeriesID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. Username does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / Productline / Product keys => 404 Not Found
6. Product created => 201 Created

DECLARE @RC int
DECLARE @Username AS NVARCHAR(255)='SQL'
DECLARE @ProductID AS NVARCHAR(255)='1'
DECLARE @ProductLineID AS NVARCHAR(255)='T'
DECLARE @FactoryID AS NVARCHAR(255)='ZT'
DECLARE @ValueSeriesID AS NVARCHAR(255)='38550'
DECLARE @RequestedValueSeriesNo AS INTEGER = 249
DECLARE @NameShort AS NVARCHAR(255)='<#NV>'
DECLARE @NameLong AS NVARCHAR(255)='<#NV>'
DECLARE @CommentUser AS NVARCHAR(255)='<#NV>'
DECLARE @CommentDev AS NVARCHAR(255)='<#NV>'
DECLARE @ImageName AS NVARCHAR(255)='<#NV>'
DECLARE @IsNumeric AS NVARCHAR(255)='1'
DECLARE @VisibilityLevel AS NVARCHAR(255)='<#NV>'
DECLARE @ValueSource AS NVARCHAR(255)='<#NV>'
DECLARE @ValueListID AS NVARCHAR(255)='<#NV>'
DECLARE @ValueFormatID AS NVARCHAR(255)='<#NV>'
DECLARE @Unit AS NVARCHAR(255)='<#NV>'
DECLARE @Scale AS NVARCHAR(255)='100'
DECLARE @Effect AS NVARCHAR(255)='<#NV>'
DECLARE @EffectParameter AS NVARCHAR(255)='<#NV>'

-- TODO: Set parameter values here.

EXECUTE @RC = [sx_pf_POST_ValueSerie] @Username,	@ProductID,	@ProductLineID,	@FactoryID,	@ValueSeriesID,	@RequestedValueSeriesNo,@NameShort,	@NameLong,@CommentUser,
		@CommentDev,@ImageName,@IsNumeric,@VisibilityLevel,@ValueSource,@ValueListID,@ValueFormatID,@Unit,@Scale,@Effect,@EffectParameter

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_POST_ValueSerie]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_POST_ValueSerie];
GO

CREATE PROCEDURE [dbo].[sx_pf_POST_ValueSerie]
	@Username AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ValueSeriesID AS NVARCHAR(255),
	@RequestedValueSeriesNo AS INTEGER,
	@NameShort AS NVARCHAR(255),
	@NameLong AS NVARCHAR(255),
	@CommentUser AS NVARCHAR(255),
	@CommentDev AS NVARCHAR(255),
	@ImageName AS NVARCHAR(255),
	@IsNumeric AS NVARCHAR(255),
	@VisibilityLevel AS NVARCHAR(255),
	@ValueSource AS NVARCHAR(255),
	@ValueListID AS NVARCHAR(255),
	@ValueFormatID AS NVARCHAR(255),
	@Unit AS NVARCHAR(255),
	@Scale AS NVARCHAR(255),
	@Effect AS NVARCHAR(255),
	@EffectParameter AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSeriesKey AS INT = 0;
	DECLARE @OldValueSeriesNo AS INT = 0;
	DECLARE @OldIsNumeric AS INT = 0;
	DECLARE @OldScale AS INT = 0;
	DECLARE	@FirstTimeID AS BIGINT = 0;
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ValueSeriesID, N'NULL') + 
		 N''',' + ISNULL(CAST(@RequestedValueSeriesNo AS NVARCHAR(255)), N'NULL') + N',''' + ISNULL(@NameShort, N'NULL') + N''',''' + ISNULL(@NameLong, N'NULL') + N''',''' + ISNULL(@CommentUser, N'NULL') + 
		 N''',''' + ISNULL(@CommentDev, N'NULL') + N''',''' + ISNULL(@ImageName, N'NULL') + N''',''' + ISNULL(@IsNumeric, N'NULL') + N''',''' + ISNULL(@VisibilityLevel, N'NULL') + N''',''' + ISNULL(@ValueSource, N'NULL') + N''',''' + ISNULL(@ValueListID, N'NULL') + 
		 N''',''' + ISNULL(@ValueFormatID, N'NULL') + N''',''' + ISNULL(@Unit, N'NULL') + N''',''' + ISNULL(@Scale, N'NULL') + N''',''' + ISNULL(@Effect, N'NULL') + N''',''' + ISNULL(@EffectParameter, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ProductID IS NULL SET @ProductID = N'NULL';
	IF @ProductLineID IS NULL SET @ProductLineID = N'NULL';
	IF @FactoryID IS NULL SET @FactoryID = N'NULL';
	IF @ValueSeriesID IS NULL SET @ValueSeriesID = N'NULL';
	IF @RequestedValueSeriesNo IS NULL SET @RequestedValueSeriesNo = 0;
	IF @NameShort IS NULL SET @NameShort = N'NULL';
	IF @NameLong IS NULL SET @NameLong = N'NULL';
	IF @CommentUser IS NULL SET @CommentUser = N'NULL';
	IF @CommentDev IS NULL SET @CommentDev = N'NULL';
	IF @ImageName IS NULL SET @ImageName = N'NULL';
	IF @IsNumeric IS NULL SET @IsNumeric = N'NULL';
	IF @VisibilityLevel IS NULL SET @VisibilityLevel = N'NULL';
	IF @ValueSource IS NULL SET @ValueSource = N'NULL';
	IF @ValueListID IS NULL SET @ValueListID = N'NULL';
	IF @ValueFormatID IS NULL SET @ValueFormatID = N'NULL';
	IF @Unit IS NULL SET @Unit = N'NULL';
	IF @Scale IS NULL SET @Scale = N'NULL';
	IF @Effect IS NULL SET @Effect = N'NULL';
	IF @EffectParameter IS NULL SET @EffectParameter = N'NULL';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.1 - NULL Protection
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ValueSeriesID = [dbo].[sx_pf_pProtectID] (@ValueSeriesID);
		SET @NameShort = [dbo].[sx_pf_pProtectString] (@NameShort);
		SET @NameLong = [dbo].[sx_pf_pProtectString] (@NameLong);
		SET @CommentUser = [dbo].[sx_pf_pProtectString] (@CommentUser);
		SET @CommentDev = [dbo].[sx_pf_pProtectString] (@CommentDev);
		SET @ImageName = [dbo].[sx_pf_pProtectString] (@ImageName);
		SET @IsNumeric = [dbo].[sx_pf_pProtectBoolean] (@IsNumeric);
		SET @VisibilityLevel = [dbo].[sx_pf_pProtectInt] (@VisibilityLevel);
		SET @ValueSource = [dbo].[sx_pf_pProtectString] (@ValueSource);
		IF @ValueListID <> N'<#NV>' SET @ValueListID = [dbo].[sx_pf_pProtectID] (@ValueListID);
		IF @ValueFormatID <> N'<#NV>' SET @ValueFormatID = [dbo].[sx_pf_pProtectID] (@ValueFormatID);
		SET @Unit = [dbo].[sx_pf_pProtectString] (@Unit);
		SET @Scale = [dbo].[sx_pf_pProtectInt] (@Scale);
		SET @Effect = [dbo].[sx_pf_pProtectString] (@Effect);
		SET @EffectParameter = [dbo].[sx_pf_pProtectString] (@EffectParameter);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N'' OR @ValueSeriesID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 1.2 - Determine keys	
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLinekey AND ProductID= @ProductID;
		SELECT @ValueSeriesKey = ValueSeriesKey, @OldIsNumeric = [IsNumeric], @OldScale = Scale FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey AND ValueSeriesID= @ValueSeriesID;

		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 3.1 - Insert the ValueSeries, if Key does not exist
		IF @ValueSeriesKey = 0
		BEGIN
			-- INCREMENT all following Requested ValueSeriesNumbers based on requested No
			UPDATE [dbo].[sx_pf_dValueSeries]
			SET ValueSeriesNo = ValueSeriesNo + 1 
			WHERE ProductKey = @ProductKey 
				AND ValueSeriesNo >= @RequestedValueSeriesNo;
			
			SET @EffectedRows = @@ROWCOUNT;

			DECLARE @Keys AS TABLE ([Key] INT);

			-- Insert with requested number
			INSERT INTO [dbo].[sx_pf_dValueSeries] (
				ProductKey
				,ProductLineKey
				,FactoryKey
				,ProductID
				,ProductLineID
				,FactoryID
				,ValueSeriesID
				,ValueSeriesNo
				,NameShort
				,NameLong
				,CommentUser
				,CommentDev
				,ImageName
				,[IsNumeric]
				,VisibilityLevel
				,ValueSource
				,ValueListID
				,ValueFormatID
				,Unit
				,Scale
				,Effect
				,EffectParameter) 
			OUTPUT INSERTED.ValueSeriesKey INTO @Keys([Key])
			VALUES ( 
				@ProductKey
				,@ProductLineKey
				,@FactoryKey
				,@ProductID
				,@ProductLineID
				,@FactoryID
				,@ValueSeriesID
				,@RequestedValueSeriesNo
				,@NameShort,@NameLong
				,@CommentUser
				,@CommentDev
				,@ImageName
				,@IsNumeric
				,@VisibilityLevel
				,@ValueSource
				,@ValueListID
				,@ValueFormatID
				,@Unit
				,@Scale
				,@Effect
				,@EffectParameter);
			
			SET @EffectedRows += @@ROWCOUNT;
			SELECT TOP 1 @ValueSeriesKey = [Key] FROM @Keys;
		END
		ELSE
		BEGIN 
		-- STEP 3.2 - Update ValueSeries if it already exists
			SELECT @OldValueSeriesNo = ValueSeriesNo FROM [dbo].[sx_pf_dValueSeries] WHERE ValueSeriesKey = @ValueSeriesKey;
									
			-- Use the old one, if no SeriesNo is commited (lower than one means not commited)
			IF @RequestedValueSeriesNo < 1 
				SET @RequestedValueSeriesNo = @OldValueSeriesNo;
			
			-- Adjust Numbers if not equal
			IF @OldValueSeriesNo < @RequestedValueSeriesNo
			BEGIN 
				-- decrement all between actual and requsted Position
				UPDATE [dbo].[sx_pf_dValueSeries] 
				SET ValueSeriesNo = ValueSeriesNo - 1 
				WHERE ProductKey = @ProductKey 
					AND ValueSeriesNo > @OldValueSeriesNo 
					AND ValueSeriesNo <= @RequestedValueSeriesNo;
														
				SET @EffectedRows += @@ROWCOUNT;
			END
			ELSE IF @OldValueSeriesNo > @RequestedValueSeriesNo
			BEGIN 
				-- increment all between actual and requsted Position
				UPDATE [dbo].[sx_pf_dValueSeries] 
				SET ValueSeriesNo = ValueSeriesNo + 1 
				WHERE ProductKey = @ProductKey 
					AND ValueSeriesNo < @OldValueSeriesNo 
					AND ValueSeriesNo >= @RequestedValueSeriesNo;

				SET @EffectedRows += @@ROWCOUNT;
			END;

			UPDATE [dbo].[sx_pf_dValueSeries] 
			SET ValueSeriesNo = @RequestedValueSeriesNo
				, NameShort = IIF(@NameShort = N'<#NV>', NameShort, @NameShort)
				, NameLong = IIF(@NameLong = N'<#NV>', NameLong, @NameLong)
				, CommentUser = IIF(@CommentUser = N'<#NV>', CommentUser, @CommentUser)
				, CommentDev = IIF(@CommentDev = N'<#NV>', CommentDev, @CommentDev)
				, ImageName = IIF(@ImageName = N'<#NV>', ImageName, @ImageName)
				, [IsNumeric] = IIF(@IsNumeric = N'<#NV>', [IsNumeric], @IsNumeric)
				, VisibilityLevel = IIF(@VisibilityLevel = N'<#NV>', VisibilityLevel, @VisibilityLevel)
				, ValueSource = IIF(@ValueSource = N'<#NV>', ValueSource, @ValueSource)
				, ValueListID = IIF(@ValueListID = N'<#NV>', ValueListID, @ValueListID)
				, ValueFormatID = IIF(@ValueFormatID = N'<#NV>', ValueFormatID, @ValueFormatID)
				, Unit = IIF(@Unit = N'<#NV>', Unit, @Unit)
				, Scale = IIF(@Scale = N'<#NV>', Scale, @Scale)
				, Effect = IIF(@Effect = N'<#NV>', Effect, @Effect)
				, EffectParameter = IIF(@EffectParameter = N'<#NV>', EffectParameter, @EffectParameter)
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE ValueSeriesKey = @ValueSeriesKey;
				
			SET @EffectedRows += @@ROWCOUNT;

			-- STEP 3.3 - Update exists Values due to possible rescaling or changing type from Numeric to Non-Numeric
			DECLARE @vals AS TABLE ([ValueKey] INT, [ValueInt] INT, [ValueText] NVARCHAR(MAX));

			-- Changing type Numeric / Non Numeric
			IF (@IsNumeric <> N'<#NV>' AND @OldIsNumeric <> @IsNumeric)
			BEGIN
				-- Copy ValueText to ValueInt, after Try_Cast to Int to get only valid numbers and multiplied by OldScale, as the int values use scale, while the text value not
				IF @IsNumeric = N'1'
				BEGIN							 
					INSERT INTO @vals ([ValueKey], [ValueInt], [ValueText])
					SELECT [ValueKey], ISNULL(TRY_CAST([ValueText] AS INT), 0) * @OldScale, ''
					FROM [dbo].[sx_pf_fValues]
					WHERE ValueSeriesKey = @ValueSeriesKey; 
				END
				ELSE
				BEGIN
					-- If Numeric is made to non numeric the value in the Database must be be divided by scale and converted to text, as text dont uses scale
					IF (@OldScale <> 0)
					BEGIN
						INSERT INTO @vals ([ValueKey], [ValueInt], [ValueText])
						SELECT [ValueKey], 0, CAST([ValueInt] / @OldScale AS NVARCHAR(MAX))
						FROM [dbo].[sx_pf_fValues]
						WHERE ValueSeriesKey = @ValueSeriesKey;	
					END
					ELSE
					BEGIN
						INSERT INTO @vals ([ValueKey], [ValueInt], [ValueText])
						SELECT [ValueKey], 0, CAST([ValueInt] AS NVARCHAR(MAX))
						FROM [dbo].[sx_pf_fValues]
						WHERE ValueSeriesKey = @ValueSeriesKey; 
					END;
				END;
			END;

			-- changing scaling
			-- If Isnumeric = 0 and not changed Nothing happens with the value, if scale is changed, as text values dont use the scale property.
			IF (@Scale <> N'<#NV>' AND @OldScale <> @Scale) AND (@IsNumeric = N'1' OR (@IsNumeric = N'<#NV>' AND @OldIsNumeric = 1))
			BEGIN
				-- Change Scale of existing values if scale is changed (when scale is changed, e.g. from 100 to 1000 the value in the database must be multiplied by 10)
				DECLARE @k FLOAT = @Scale / CAST(@OldScale AS FLOAT);	
			
				IF NOT EXISTS(SELECT 1 FROM @vals)
				BEGIN
					INSERT INTO @vals ([ValueKey], [ValueInt], [ValueText])
					SELECT [ValueKey], [ValueInt] * @k, '' 
					FROM [dbo].[sx_pf_fValues]
					WHERE ValueSeriesKey = @ValueSeriesKey; 
				END
				ELSE
				BEGIN
					UPDATE @vals
					SET [ValueInt] = [ValueInt] * @k; 
				END;
			END;
			
			IF EXISTS(SELECT 1 FROM @vals)
			BEGIN
				UPDATE v
				SET v.[ValueInt] = newV.[ValueInt]
					,  v.[ValueText] = newV.[ValueText] 
				FROM [dbo].[sx_pf_fValues] v INNER JOIN @vals newV ON v.ValueKey = newV.ValueKey;

				SET @EffectedRows += @@ROWCOUNT;
			END;
		END;

		SET @Resultcode = 201;
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ValueSerie] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_POST_ValueSerie] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a ClusterProperty
Deletes a Cluster Property.

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the cluster => 401 Unauthorized
4. Property deleted => 200 OK
5. PropertyID not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @PropertyID AS NVARCHAR(255) = 'rre'

EXECUTE @RC = [sx_pf_DELETE_ClusterProperty] 
		@Username,
		@PropertyID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_ClusterProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_ClusterProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_ClusterProperty]
	@Username AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);
		
		IF @PropertyID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3 - Delete
		DELETE FROM [dbo].[sx_pf_gCluster] WHERE PropertyID = @PropertyID;
		
		SET @EffectedRows = @@ROWCOUNT;

		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ClusterProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ClusterProperty] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a Factory
Deletes an entire Factory (include ProductLines, Products, Values)

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. FactoryID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the cluster => 401 Unauthorized
4. Factory deleted => 200 OK
5. FactoryID not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'Test'

EXECUTE @RC = [sx_pf_DELETE_Factory] 
		@Username,
		@FactoryID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Factory]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Factory];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Factory]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryKey IS NULL SET @FactoryKey = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
		
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);	

		IF @FactoryID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID; 

		IF @FactoryKey = 0
		BEGIN
			SET @ResultCode = 204;
		END
		ELSE
		BEGIN
			-- STEP 3 - Delete Factory items from all tables
			DELETE FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_dValueSeries] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_dTime] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_fStatements] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_fValues] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_gProductLines] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_gProducts] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_dFactories] WHERE FactoryKey = @FactoryKey;
			SET @EffectedRows += @@ROWCOUNT;

			-- Last, because of Right materialization
			DELETE FROM [dbo].[sx_pf_rRights] WHERE FactoryID = @FactoryID;
			SET @EffectedRows += @@ROWCOUNT;
		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Factory] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Factory] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a FactoryProperty
Deletes an entire Factory Property

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID or FactoryID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the Factory => 401 Unauthorized
4. Property deleted => 200 OK
5. PropertyID not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @PropertyID AS NVARCHAR(255) = 'rre'

EXECUTE @RC = [sx_pf_DELETE_FactoryProperty] 
		@Username,
		@FactoryID,
		@PropertyID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_FactoryProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_FactoryProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_FactoryProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryKey IS NULL SET @FactoryKey = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	 BEGIN TRY
		BEGIN TRANSACTION ONE

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);	
		SET @PropertyID = [dbo].[sx_pf_pProtectID](@PropertyID);

		IF @FactoryID = N'' OR @PropertyID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID; 
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gFactories] WHERE FactoryKey = @FactoryKey AND PropertyID = @PropertyID;
		
		IF @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 3 - Delete		
		DELETE FROM [dbo].[sx_pf_gFactories] WHERE PropertyKey = @PropertyKey;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF(@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_FactoryProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_FactoryProperty] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a Format

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. FormatID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the cluster => 401 Unauthorized
4. Format deleted => 200 OK
5. Format not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FormatID AS NVARCHAR(255) = '510'
		
EXECUTE @RC = [sx_pf_DELETE_Format] 
		@Username,
		@FormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Format]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Format];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Format]
	@Username AS NVARCHAR(255),
	@FormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FormatID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FormatID IS NULL SET @FormatID =  N'';

	 BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FormatID = [dbo].[sx_pf_pProtectID] (@FormatID);

		IF @FormatID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3 - Delete values		
		DELETE FROM [dbo].[sx_pf_hFormats] WHERE FormatID = @FormatID;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF(@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Format] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Format] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a List
Delete a List 

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ListID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the cluster => 401 Unauthorized
4. List deleted => 200 OK
5. List not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ListID AS NVARCHAR(255) = '510'
		
EXECUTE @RC = [sx_pf_DELETE_List] 
		@Username,
		@ListID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_List]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_List];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_List]
	@Username AS NVARCHAR(255),
	@ListID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@ListID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ListID IS NULL SET @ListID =  N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @ListID = [dbo].[sx_pf_pProtectID] (@ListID);

		IF @ListID = N'' 	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3 - Delete values		
		DELETE FROM [dbo].[sx_pf_hListValues] WHERE ListID = @ListID;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_hLists] WHERE ListID = @ListID
		SET @EffectedRows += @@ROWCOUNT;
			
		SET @ResultCode = IIF(@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_List] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_List] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for one ListValue
Operates over Key, as the ListValue has no ID

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ListID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the cluster => 401 Unauthorized
4. ListValue deleted => 200 OK
5. ListValue not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @ListValueKey AS INT = 18

		
EXECUTE @RC = [sx_pf_DELETE_ListValue] 
		@Username,
		@ListValueKey

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_ListValue]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_ListValue];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_ListValue]
	@Username AS NVARCHAR(255),
	@ListValueKey AS INT
AS 
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(CAST(@ListValueKey AS NVARCHAR(255)), N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @ListValueKey IS NULL SET @ListValueKey = 0;

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_hListValues] WHERE ListValueKey = @ListValueKey;

		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF(@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ListValue] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ListValue] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a Preference

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID or empty ProductLine => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Non exists Factory / Productline => 404 Not Found
5. Product not found => 204 No Content
6. Product deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @PreferenceUserName AS NVARCHAR(255) = 'W8\admin'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'ZT'
		DECLARE @FactoryID AS NVARCHAR(255) = 'ZT'
		DECLARE @SettingName AS NVARCHAR(255) = 'Demopref'

EXECUTE @RC = [sx_pf_DELETE_Preference] 
		@Username,
		@PreferenceUsername,
		@ProductLineID,
		@FactoryID,
		@SettingName

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Preference]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Preference];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Preference]
	@Username AS NVARCHAR(255),
	@PreferenceUsername AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@SettingName AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@PreferenceUsername, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@SettingName, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @PreferenceUsername IS NULL SET @PreferenceUsername = N'';
	IF @SettingName IS NULL SET @SettingName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
		
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @PreferenceUsername = [dbo].[sx_pf_pProtectString] (@PreferenceUsername);
		SET @SettingName =[dbo].[sx_pf_pProtectString] (@SettingName);

		IF @PreferenceUsername = N'' OR @ProductLineID = N'' OR @FactoryID = N'' OR @SettingName = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		
		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		IF @SettingName = N'<#NV>'	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Invalid value of Setting Name', 16, 10);
		END;

		IF NOT EXISTS(SELECT Username FROM [dbo].[sx_pf_rUser] WHERE Username = @PreferenceUsername)
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Preferences Users don`t exists', 16, 10);
		END;

		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_rPreferences]
		WHERE FactoryID = @FactoryID 
			AND ProductLineID = @ProductLineID 
			AND Username = @PreferenceUsername 
			AND SettingName = @SettingName;

		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF(@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Preference] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Preference] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a Product
Deletes a product and all Values and Attributes

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ProductID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Product not found => 204 No Content
5. Product deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '510'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'P-CP-SE'
		DECLARE @ProductID AS NVARCHAR(255) = '10'

EXECUTE @RC = [sx_pf_DELETE_Product] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@ProductID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Product]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Product];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Product]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@ProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @ProductID = N'' OR @ProductLineID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID AND ProductLineKey = @ProductLineKey;

		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dTime] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_fStatements] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_gProducts] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @ProductKey;
		SET @EffectedRows += @@ROWCOUNT;

		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Product] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Product] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a ProductLine
Deletes an entire Product Line (Products, Values, etc.)

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ProductLineID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. ProductLine not found => 204 No Content
5. ProductLine deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '1'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'Test'

EXECUTE @RC = [sx_pf_DELETE_ProductLine] 
		@Username,
		@FactoryID,
		@ProductLineID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_ProductLine]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_ProductLine];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_ProductLine]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + '''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE
		
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);

		IF @ProductLineID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @FactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
	
		-- 4. Factory und ProductLineKey ermitteln
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		
		IF @FactoryKey = 0
 		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
				
		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dValueSeries] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dTime] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_fStatements] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_gProductLines] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_gProducts] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey;
		SET @EffectedRows += @@ROWCOUNT;

		-- last because of matrialization
		DELETE FROM [dbo].[sx_pf_rRights] WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID;
		SET @EffectedRows += @@ROWCOUNT;

		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ProductLine] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ProductLine] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a ProductLineProperty
Delete a ProductLineProperty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Property not found => 204 No Content
5. Property deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '810'
		DECLARE @ProductLineID AS NVARCHAR(255) = '10'
		DECLARE @PropertyID AS NVARCHAR(255) = 'test'

EXECUTE @RC = [sx_pf_DELETE_ProductLineProperty] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@PropertyID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_ProductLineProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_ProductLineProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_ProductLineProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@PropertyID, N'NULL') + '''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';
	
	BEGIN TRY
		BEGIN TRANSACTION ONE;
		
		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);

		IF @PropertyID = N'' OR @ProductLineID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
		
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gProductLines] WHERE ProductLineKey = @ProductLineKey AND FactoryKey = @FactoryKey AND PropertyID = @PropertyID;

		IF @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
			
		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_gProductLines] WHERE PropertyKey = @PropertyKey;

		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ProductLineProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ProductLineProperty] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a ProductProperty
Delete a ProductProperty

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. PropertyID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Property not found => 204 No Content
5. Property deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '810'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'P-RD-BI'
		DECLARE @ProductID AS NVARCHAR(255) = '10'
		DECLARE @PropertyID AS NVARCHAR(255) = 'test'

EXECUTE @RC = [sx_pf_DELETE_ProductProperty] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@ProductID,
		@PropertyID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_ProductProperty]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_ProductProperty];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_ProductProperty]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@PropertyID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @PropertyKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@PropertyID, N'NULL') + '''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @PropertyID IS NULL SET @PropertyID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @PropertyID = [dbo].[sx_pf_pProtectID] (@PropertyID);

		IF @PropertyID = N'' OR @ProductID = N'' OR @ProductLineID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID AND ProductLineKey = @ProductLineKey AND FactoryKey = @FactoryKey;
		SELECT @PropertyKey = PropertyKey FROM [dbo].[sx_pf_gProducts] WHERE ProductKey = @ProductKey AND ProductLineKey = @ProductLineKey AND FactoryKey = @FactoryKey AND PropertyID = @PropertyID;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_gProducts] WHERE PropertyKey = @PropertyKey;
			
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ProductProperty] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ProductProperty] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a Right
Deletes a Right of a user, user can therefore also delete its own cluster write and lock yourself out for yourself to! 
Must frontend intercept with security inquiry!

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. DeleteUserName is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to the cluster => 401 Unauthorized
4. Right deleted => 200 OK
5. Right not found => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @DeleteUserName AS NVARCHAR(255) = 'test2'
		DECLARE @FactoryID AS NVARCHAR(255) = '510'
        DECLARE @ProductLineID AS NVARCHAR(255)= 'P-ST-IT'
		
EXECUTE @RC = [sx_pf_DELETE_Right] 
		@Username,
		@DeleteUserName,
		@FactoryID,
        @ProductLineID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Right]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Right];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Right]
	@Username AS NVARCHAR(255),
	@DeleteUserName AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
    @ProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @DeleteUserKey AS INT = 0;
	DECLARE @RightKey AS INT = 0;

	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@DeleteUserName, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') 
		+ N''',''' + ISNULL(@ProductLineID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @DeleteUserName IS NULL SET @DeleteUserName = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @DeleteUserName = [dbo].[sx_pf_pProtectString] (@DeleteUserName);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);

		IF @DeleteUserName = N'' OR @FactoryID = N'' OR @ProductLineID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
	
		-- STEP 1.2 - Determine keys
		SELECT @DeleteUserKey = UserKey FROM [dbo].[sx_pf_rUser] WHERE UserName = @DeleteUserName;
		SELECT @RightKey = RightKey FROM [dbo].[sx_pf_rRights] WHERE UserKey = @DeleteUserKey AND ProductLineID = @ProductLineID AND FactoryID = @FactoryID;
		
		IF @DeleteUserKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;

		-- STEP 3 - Delete values		
		DELETE FROM [dbo].[sx_pf_rRights] WHERE RightKey = @RightKey;
			
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Right] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Right] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a TimeID
Deletes a TimeID

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty FactoryID / ProductLineID / ProductID / TimeID = 0 => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Value of TimeID deleted => 200 OK
5. There is none ProductID => 204 No Content

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '510'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'P-CP-SE'
		DECLARE @ProductID AS NVARCHAR(255) = '10'
		DECLARE @TimeID AS INT = '20150728'

EXECUTE @RC = [sx_pf_DELETE_TimeID] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@ProductID,
		@TimeID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_TimeID]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_TimeID];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_TimeID]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@TimeID AS INT
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@ProductID, N'NULL') + ''','+ ISNULL(CAST(@TimeID AS NVARCHAR(255)), N'NULL');
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @TimeID IS NULL SET @TimeID = 0;


	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @ProductID = N'' OR @ProductLineID = N'' OR @FactoryID = N'' OR @TimeID=0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID AND ProductLineKey = @ProductLineKey AND FactoryKey = @FactoryKey;
		

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
				
		-- STEP 3.1 - Delete values
		DELETE FROM [dbo].[sx_pf_fValues] WHERE ProductKey = @ProductKey AND TimeID = @TimeID;
		SET @EffectedRows = @@ROWCOUNT;
		-- STEP 3.2 - Delete Timeline

		DELETE FROM [dbo].[sx_pf_dTime] WHERE ProductKey = @ProductKey AND TimeID = @TimeID
		SET @EffectedRows += @@ROWCOUNT;

		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_TimeID] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_TimeID] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a User
Deletes a User with all his rights. A cluster administrator can't delete himself

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. DeleteUserName is empty => 404 Not Found
2. Delete command comes from non clusteradmin => 403 Forbidden
3. User wants to delete himself => 403 Forbidden
4. DeleteUser don`t exists => 204 No Content
5. deleted user successful => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @DeleteUserName AS NVARCHAR(255) = 'W8\admin'
		
EXECUTE @RC = [sx_pf_DELETE_User] 
		@Username,
		@DeleteUserName

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_User]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_User];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_User]
	@Username AS NVARCHAR(255),
	@DeleteUserName AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@DeleteUserName, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @DeleteUserName IS NULL SET @DeleteUserName = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- Protect Strings
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @DeleteUserName = [dbo].[sx_pf_pProtectString] (@DeleteUserName);

		IF @DeleteUserName = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
			
		-- STEP 1.2 - Stop, if Transactuser wants to delete himself
		IF @TransactUsername = @DeleteUsername
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction can`t delete himself', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 3 - delete User		
		DELETE FROM [dbo].[sx_pf_rRights] WHERE UserName = @DeleteUserName;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_rUser] WHERE UserName = @DeleteUserName;
		SET @EffectedRows += @@ROWCOUNT;

		SET @ResultCode = IIF(@@ROWCOUNT = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_User] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_User] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for a Value
Delete a Value of ValueSeries with specified TimeID

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. All IDs are empty or TimeID is 0 => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Value not found => 204 No Content
5. Value deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '510'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'P-CP-SE'
		DECLARE @ProductID AS NVARCHAR(255) = '12'
		DECLARE @ValueSerieID AS NVARCHAR(255) = 'S2'
		DECLARE @TimeID AS INT = 20160615

EXECUTE @RC = [sx_pf_DELETE_Value] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@ProductID,
		@ValueSerieID,
		@TimeID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Value]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Value];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Value]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ValueSerieID AS NVARCHAR(255),
	@TimeID INT
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSerieKey AS INT = 0;
	DECLARE @ValueKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSerieID, N'NULL') + ''','+ ISNULL(CAST(@TimeID AS NVARCHAR(255)), N'NULL');
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSerieID IS NULL SET @ValueSerieID = N'';
	IF @TimeID IS NULL SET @TimeID = 0;

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @ValueSerieID = [dbo].[sx_pf_pProtectID] (@ValueSerieID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @ValueSerieID = N'' OR @ProductID = N'' OR @ProductLineID = N'' OR @FactoryID = N'' OR @TimeID=0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
	
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);
		
		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID AND ProductLineKey = @ProductLineKey;--  AND FactoryKey = @FactoryKey;
		SELECT @ValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ValueSeriesID = @ValueSerieID AND ProductKey = @ProductKey;-- AND ProductLineKey = @ProductLineKey AND FactoryKey = @FactoryKey;
		SELECT @ValueKey = ValueKey FROM [dbo].[sx_pf_fValues] WHERE ValueSeriesKey = @ValueSerieKey AND TimeID = @TimeID;-- AND ProductLineKey = @ProductLineKey AND FactoryKey = @FactoryKey AND ValueSeriesKey = @ValueSeriesKey;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0 OR @ValueSerieKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
				
		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_fValues] WHERE ValueKey = @ValueKey;
			
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Value] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Value] TO pf_PlanningFactoryService;
GO

/*
DELETE Operation for Values
Delete all Values of Value Series of Products

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. All IDs are empty  => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. Values not found => 204 No Content
5. Values deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = '510'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'P-CP-SE'
		DECLARE @ProductID AS NVARCHAR(255) = '12'
		DECLARE @ValueSerieID AS NVARCHAR(255) = 'S2'

EXECUTE @RC = [sx_pf_DELETE_Values] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@ProductID,
		@ValueSerieID

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_Values]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_Values];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_Values]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ValueSerieID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @ValueSerieKey AS INT = 0;
	
	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSerieID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSerieID IS NULL SET @ValueSerieID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @ValueSerieID = [dbo].[sx_pf_pProtectID](@ValueSerieID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID](@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID](@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID](@ProductID);

		IF @ValueSerieID = N'' OR @ProductID = N'' OR @ProductLineID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID AND ProductLineKey = @ProductLineKey;
		SELECT @ValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ValueSeriesID = @ValueSerieID AND ProductKey = @ProductKey;

		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0 OR @ValueSerieKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 3 - Delete values
		DELETE FROM [dbo].[sx_pf_fValues] WHERE ValueSeriesKey = @ValueSerieKey;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = IIF (@EffectedRows = 0, 204, 200);

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Values] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_Values] TO pf_PlanningFactoryService;
GO
/*
DELETE Operation for one ValueSerie
Deletes a ValueSerie and changes the Numbers of the other ValueSeries. If Series No 1 is delete, Procedure creates Placeholder in a new ValueSeries 1.

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. ValueSerieID is empty => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User does not have write access to ProductLine => 401 Unauthorized
4. ValueSerie not found => 204 No Content
5. ValueSerie deleted => 200 OK

DECLARE @RC int
		DECLARE @Username AS NVARCHAR(255) = 'SQL'
		DECLARE @FactoryID AS NVARCHAR(255) = 'PP_1_WOB'
		DECLARE @ProductLineID AS NVARCHAR(255) = 'WOB_DISPO'
		DECLARE @ProductID AS NVARCHAR(255) = '99'
		DECLARE @ValueSerieID AS NVARCHAR(255) = 'E2'

EXECUTE @RC = [sx_pf_DELETE_ValueSerie] 
		@Username,
		@FactoryID,
		@ProductLineID,
		@ProductID,
		@ValueSerieID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_DELETE_ValueSerie]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_DELETE_ValueSerie];
GO

CREATE PROCEDURE [dbo].[sx_pf_DELETE_ValueSerie]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@ValueSerieID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @DelValueSerieKey AS INT = 0;
	DECLARE @DelValueSerieNo AS INT = 0;
	DECLARE @MinValueSerieNo AS INT = 0;
	DECLARE @NewFirstValueSerieKey AS INT = 0;
	DECLARE @NewFirstValueSerieID NVARCHAR(255) = N'';
	DECLARE @NewFirstValueSerieNo AS INT = 0;

	DECLARE @TransactUsername NVARCHAR(255) = N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') 
		+ N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(@ValueSerieID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N''				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @ValueSerieID IS NULL SET @ValueSerieID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @ValueSerieID = [dbo].[sx_pf_pProtectID](@ValueSerieID);
		SET @FactoryID = [dbo].[sx_pf_pProtectID](@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID](@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID](@ProductID);
	
		IF @ValueSerieID = N'' OR @ProductID = N'' OR @ProductLineID = N'' OR @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;
				 
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineID = @ProductLineID AND FactoryKey = @FactoryKey;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductID = @ProductID AND ProductLineKey = @ProductLineKey;
		SELECT @DelValueSerieKey = ValueSeriesKey, @DelValueSerieNo = ValueSeriesNo FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey AND ValueSeriesID = @ValueSerieID;
		
		IF @ProductKey = 0 OR @ProductLineKey = 0 OR @FactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;
		
		-- STEP 3 - Delete values
		IF @DelValueSerieKey = 0
		BEGIN
			SET @ResultCode = 204;
		END 
		ELSE
		BEGIN				
			
			-- STEP 3.2 - Delete ValueSerie 				
			DELETE FROM [dbo].[sx_pf_fValues] WHERE ValueSeriesKey = @DelValueSerieKey;
			SET @EffectedRows += @@ROWCOUNT;

			DELETE FROM [dbo].[sx_pf_dValueSeries] WHERE ValueSeriesKey = @DelValueSerieKey;
			SET @EffectedRows += @@ROWCOUNT;

			-- STEP 3.3 - Decrement all ValueSeriesNo which are bigger than the deleted on
			UPDATE [dbo].[sx_pf_dValueSeries]
			SET ValueSeriesNo = ValueSeriesNo - 1
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE ProductKey = @ProductKey
				AND ValueSeriesNo > @DelValueSerieNo;

			SET @EffectedRows += @@ROWCOUNT;

			-- STEP 3.4 - if the new first ValueSeries is not NO 1 (1,3..... Numbers), set it to 1
			IF @NewFirstValueSerieNo - 1 > 1 
			BEGIN
				UPDATE [dbo].[sx_pf_dValueSeries] 
				SET	ValueSeriesNo = 1
				FROM [dbo].[sx_pf_dValueSeries]
				WHERE ProductKey = @ProductKey 
					AND ValueSeriesKey = @NewFirstValueSerieKey;

				SET @EffectedRows += @@ROWCOUNT;
			END;
		END;
		
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ValueSerie] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DELETE_ValueSerie] TO pf_PlanningFactoryService;
GO
/*
COPY Operation for a Factory
Not yet existing factory is copied when Source Factory exists

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty  source or target FactoryID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists Source Factory => 404 Not Found
5. Target Factory key already exists => 403 Forbidden
6. Factory created > 201 Created

DECLARE @RC int
DECLARE  @Username AS NVARCHAR(255) 
DECLARE  @SourceFactoryID AS NVARCHAR(255)
DECLARE  @TargetFactoryID AS NVARCHAR(255)
DECLARE  @TargetFactoryNameShort AS NVARCHAR(255)

-- CASE 1
SET  @Username = 'SQL'
SET  @SourceFactoryID ='ZT'
SET  @TargetFactoryID  =''
SET  @TargetFactoryNameShort ='Neue Factory'

EXECUTE @RC = [sx_pf_COPY_Factory] 
		   @Username
		  ,@SourceFactoryID
		  ,@TargetFactoryID
		  ,@TargetFactoryNameShort
PRINT @RC

-- CASE 4
SET  @Username = 'SQL'
SET  @SourceFactoryID =''
SET  @TargetFactoryID  ='ZTKopie'
SET  @TargetFactoryNameShort ='Neue Factory'

EXECUTE @RC = [sx_pf_COPY_Factory] 
		   @Username
		  ,@SourceFactoryID
		  ,@TargetFactoryID
		  ,@TargetFactoryNameShort
PRINT @RC


-- CASE 5 
SET  @Username = 'SQL'
SET  @SourceFactoryID ='ZT'
SET  @TargetFactoryID ='ZT'
SET  @TargetFactoryNameShort ='Neue Factory'

EXECUTE @RC = [sx_pf_COPY_Factory] 
		   @Username
		  ,@SourceFactoryID
		  ,@TargetFactoryID
		  ,@TargetFactoryNameShort
PRINT @RC


--CASE 6
SET  @Username  = 'SQL'
SET  @SourceFactoryID ='ZT'
SET  @TargetFactoryID ='ZTKopie'
SET  @TargetFactoryNameShort ='Neue Factory'

EXECUTE @RC = [sx_pf_COPY_Factory] 
		   @Username
		  ,@SourceFactoryID
		  ,@TargetFactoryID
		  ,@TargetFactoryNameShort
PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_COPY_Factory]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_COPY_Factory];
GO

CREATE PROCEDURE [dbo].[sx_pf_COPY_Factory]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255),
	@TargetFactoryNameShort AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUserKey AS INT = 0;
	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @TargetFactoryKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@TargetFactoryID, N'NULL')
		+ N''',''' + ISNULL(@TargetFactoryNameShort, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';
	IF @TargetFactoryNameShort IS NULL SET @TargetFactoryNameShort = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters	
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);
		SET @TargetFactoryNameShort = [dbo].[sx_pf_pProtectString] (@TargetFactoryNameShort);
		
		IF @SourceFactoryID = N'' OR @TargetFactoryID = N''	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);	

		
		-- STEP 1.2 - Determine SourceKeys
		SELECT @SourceFactoryKey = FactoryKey, @SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		
		IF @SourceFactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		
		IF @TargetFactoryKey <> 0 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target Format key already exists', 16, 10);
		END;

		

		-- STEP 3 - Copy data
		DECLARE @Keys AS TABLE ([Key] INT);
			
		-- dFactory
		INSERT INTO [dbo].[sx_pf_dFactories]
		OUTPUT INSERTED.FactoryKey INTO @Keys([Key])
		SELECT @TargetFactoryID AS FactoryID
			, @TargetFactoryNameShort AS NameShort
			, NameLong, CommentUser, CommentDev, ResponsiblePerson, ImageName 
		FROM [dbo].[sx_pf_dFactories] 
		WHERE FactoryID = @SourceFactoryID; 

		SET @EffectedRows = @@ROWCOUNT;	
		SELECT TOP 1 @TargetFactoryKey = [Key] FROM @Keys;
		
		--dProductLine 
		INSERT INTO [dbo].[sx_pf_dProductLines]
		SELECT @TargetFactoryKey AS FactoryKey
			, ProductlineID
			, @TargetFactoryID AS FactoryID
			, NameShort, NameLong, CommentUser, CommentDev, ResponsiblePerson, ImageName, DefaultTemplate
			, GlobalAttributeSource1, GlobalAttributeAlias1, GlobalAttributeSource2, GlobalAttributeAlias2, GlobalAttributeSource3, GlobalAttributeAlias3 
			, GlobalAttributeSource4, GlobalAttributeAlias4, GlobalAttributeSource5, GlobalAttributeAlias5, GlobalAttributeSource6, GlobalAttributeAlias6 
			, GlobalAttributeSource7, GlobalAttributeAlias7, GlobalAttributeSource8, GlobalAttributeAlias8, GlobalAttributeSource9, GlobalAttributeAlias9 	
			, GlobalAttributeSource10, GlobalAttributeAlias10, GlobalAttributeSource11, GlobalAttributeAlias11, GlobalAttributeSource12, GlobalAttributeAlias12 
			, GlobalAttributeSource13, GlobalAttributeAlias13, GlobalAttributeSource14, GlobalAttributeAlias14, GlobalAttributeSource15, GlobalAttributeAlias15
			, GlobalAttributeSource16, GlobalAttributeAlias16, GlobalAttributeSource17, GlobalAttributeAlias17, GlobalAttributeSource18, GlobalAttributeAlias18 
			, GlobalAttributeSource19, GlobalAttributeAlias19, GlobalAttributeSource20, GlobalAttributeAlias20, GlobalAttributeSource21, GlobalAttributeAlias21 	
			, GlobalAttributeSource22, GlobalAttributeAlias22, GlobalAttributeSource23, GlobalAttributeAlias23, GlobalAttributeSource24, GlobalAttributeAlias24
			, GlobalAttributeSource25, GlobalAttributeAlias25	
		FROM [dbo].[sx_pf_dProductLines] 
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;	

		--dProduct 
		INSERT INTO [dbo].[sx_pf_dProducts]
		SELECT PL.ProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, ProductID, dP.ProductlineID
			, @TargetFactoryID AS FactoryID
			, TimeType, NameShort, NameLong, CommentUser, CommentDev, ResponsiblePerson, ImageName, [Status], Template, TemplateVersion
			, GlobalAttribute1, GlobalAttribute2, GlobalAttribute3, GlobalAttribute4, GlobalAttribute5, GlobalAttribute6, GlobalAttribute7
			, GlobalAttribute8, GlobalAttribute9, GlobalAttribute10, GlobalAttribute11, GlobalAttribute12, GlobalAttribute13, GlobalAttribute14
			, GlobalAttribute15, GlobalAttribute16, GlobalAttribute17, GlobalAttribute18, GlobalAttribute19, GlobalAttribute20, GlobalAttribute21
			, GlobalAttribute22, GlobalAttribute23, GlobalAttribute24, GlobalAttribute25 
		FROM [dbo].[sx_pf_dProducts] dP
				LEFT JOIN (
					SELECT ProductLineKey, ProductLineID 
					FROM [dbo].[sx_pf_dProductLines] 
					WHERE FactoryKey = @TargetFactoryKey) PL 
				ON PL.ProductLineID = dP.ProductLineID 
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		--dValueSeries
		INSERT INTO [dbo].[sx_pf_dValueSeries]  
		SELECT P.ProductKey AS ProductKey
			, P.ProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, dVS.ProductID
			, dVS.ProductLineID 
			, @TargetFactoryID AS FactoryID
			, ValueSeriesID, ValueSeriesNo, NameShort, NameLong, CommentUser, CommentDev, ImageName, [IsNumeric]
			, VisibilityLevel, ValueSource, ValueListID, ValueFormatID, Unit, Scale, Effect, EffectParameter
		FROM [dbo].[sx_pf_dValueSeries] dVS
				LEFT JOIN (
					SELECT ProductKey, ProductLineKey, ProductID, ProductLineID 
					FROM [dbo].[sx_pf_dProducts] 
					WHERE FactoryKey = @TargetFactoryKey) P 
				ON P.ProductID = dVS.ProductID AND P.ProductLineID = dVS.ProductLineID 
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		--dTime
		INSERT INTO [dbo].[sx_pf_dTime]  
		SELECT 
			 P.ProductKey AS ProductKey
			,P.ProductLineKey AS ProductLineKey
			,@TargetFactoryKey AS FactoryKey
			,dT.ProductID
			,dT.ProductLineID 
			,@TargetFactoryID AS FactoryID
			,TimeID
		FROM [dbo].[sx_pf_dTime] dT
				LEFT JOIN (
					SELECT ProductKey, ProductLineKey, ProductID, ProductLineID 
					FROM [dbo].[sx_pf_dProducts] 
					WHERE FactoryKey = @TargetFactoryKey) P 
				ON P.ProductID = dT.ProductID AND P.ProductLineID = dT.ProductLineID 
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		--fValues
		INSERT INTO [dbo].[sx_pf_fValues] 
		SELECT VS.ValueSeriesKey AS ValueSeriesKey
			, VS.ProductKey AS ProductKey
			, VS.ProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, fV.ProductID
			, fV.ProductLineID
			, @TargetFactoryID AS FactoryID
			, fV.ValueSeriesID
			, TimeID, ValueFormula, ValueInt, ValueText, ValueComment
		FROM [dbo].[sx_pf_fValues] fV
				LEFT JOIN (
					SELECT ProductKey, ValueSeriesKey, ProductLineKey, ProductID, ValueSeriesID, ProductLineID 
					FROM [dbo].[sx_pf_dValueSeries] 
					WHERE FactoryKey = @TargetFactoryKey) VS 
				ON fV.ValueSeriesID=VS.ValueSeriesID AND fV.ProductID=VS.ProductID AND fV.ProductLineID = VS.ProductLineID
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		--gFactories
		INSERT INTO [dbo].[sx_pf_gFactories] 
		SELECT @TargetFactoryKey AS FactoryKey
			, @TargetFactoryID AS FactoryID
			, PropertyID
			, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
		FROM [dbo].[sx_pf_gFactories]
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		--gProductLines
		INSERT INTO [dbo].[sx_pf_gProductLines]
				SELECT PL.ProductLineKey AS ProductLineKey , @TargetFactoryKey AS FactoryKey, gPL.ProductlineID, @TargetFactoryID AS FactoryID, 
						PropertyID, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
				FROM [dbo].[sx_pf_gProductLines] gPL
						LEFT JOIN (SELECT ProductLineKey, ProductLineID FROM sx_pf_dProductLines WHERE FactoryKey = @TargetFactoryKey) PL ON PL.ProductLineID = gPL.ProductLineID 
				WHERE FactoryKey = @SourceFactoryKey
		
		SET @EffectedRows += @@ROWCOUNT;

		--gProducts 
		INSERT INTO [dbo].[sx_pf_gProducts]
		SELECT P.ProductKey AS ProductKey
			, 0 AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, gP.ProductID
			, gP.ProductLineID
			, @TargetFactoryID AS FactoryID
			, PropertyID, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
		FROM [dbo].[sx_pf_gProducts] gP
				LEFT JOIN (
					SELECT ProductKey, ProductLineKey, ProductID, ProductLineID 
					FROM [dbo].[sx_pf_dProducts] 
					WHERE FactoryKey = @TargetFactoryKey) P 
				ON P.ProductID = gP.ProductID AND P.ProductLineID = gP.ProductLineID 
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		--rPreferences
		INSERT INTO [dbo].[sx_pf_rPreferences]
		SELECT @TransactUserKey AS UserKey 
			, @TransactUsername AS UserName 
			, @TargetFactoryID AS FactoryID
			, ProductLineID
			, SettingName 
			, ValueInt 
			, ValueText
		FROM [dbo].[sx_pf_rPreferences] 
		WHERE FactoryID = @SourceFactoryID;

		SET @EffectedRows += @@ROWCOUNT;

		--fStatements CopyInformation
		INSERT INTO [dbo].[sx_pf_fStatements]
		SELECT ProductKey
			, dp.ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, ProductID, dp.ProductLineID
			, @TargetFactoryID AS FactoryID
			, N'COPY' AS ActionType
			, N'Product produced as a copy of Factory <' + @SourceFactoryID + N'>"' + @SourceFactoryNameShort
				+ N'" / ProductLine <' + dp.ProductlineID + N'>"' + dpl.Nameshort
				+ N'" / Product <' + ProductID + N'>"' + dp.Nameshort + '"' AS [Statement]
			, @TransactUsername AS UserName 
			, N'' AS PCName
			, N'' AS ProcessorCode
			, N'' AS IPAddresses
			, CAST(CONVERT(NVARCHAR(10), GETDATE(), 112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10), GETDATE(), 108), 5), N':', N'') AS BIGINT) AS [Timestamp] 
			, 0 AS IsDeleted 
			, 0 AS IsResolved
		FROM [dbo].[sx_pf_dProducts] dp LEFT JOIN [dbo].[sx_pf_dProductLines] dpl 
			ON dp.ProductLinekey= dpl.ProductLineKey
		WHERE dp.FactoryKey = @TargetFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;

		-- Right materialization
		EXEC [dbo].[sx_pf_materialize_vUserRights];

		SET @ResultCode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_Factory] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_Factory] TO pf_PlanningFactoryService;
GO
/*
COPY Operation for a Format
Not yet existing Format is copied if source Format is available

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty  source or target FormatID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Format => 404 Not Found
5. Target target Format already exists => 403 Forbidden
6. Format created > 201 Created

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFormatID AS NVARCHAR(255)='EingabeZahl'
		DECLARE  @TargetFormatID AS NVARCHAR(255)='88C2'

EXECUTE @RC = [sx_pf_COPY_Format] 
		   @Username
		  ,@SourceFormatID
		  ,@TargetFormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_COPY_Format]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_COPY_Format]
GO

CREATE PROCEDURE [dbo].[sx_pf_COPY_Format]
	@Username AS NVARCHAR(255),
	@SourceFormatID AS NVARCHAR(255),
	@TargetFormatID AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @SourceFormatKey AS INT = 0;
	DECLARE @TargetFormatKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFormatID, N'NULL') + N''',''' + ISNULL(@TargetFormatID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFormatID IS NULL SET @SourceFormatID = N'';
	IF @TargetFormatID IS NULL SET @TargetFormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters			
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFormatID =[dbo].[sx_pf_pProtectID] (@SourceFormatID);
		SET @TargetFormatID = [dbo].[sx_pf_pProtectID] (@TargetFormatID);

		IF @SourceFormatID = N'' OR @TargetFormatID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);	

		
		-- STEP 1.2 - Determine SourceKeys
		SELECT @SourceFormatKey = FormatKey FROM [dbo].[sx_pf_hFormats] WHERE FormatID = @SourceFormatID;
		
		IF @SourceFormatKey = 0		
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @TargetFormatKey = FormatKey FROM [dbo].[sx_pf_hFormats] WHERE FormatID = @TargetFormatID;
		
		IF @TargetFormatKey <> 0		
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target Format key already exists', 16, 10);
		END;

		-- STEP 3 - Copy data
		--hFormats
		INSERT INTO [dbo].[sx_pf_hFormats]
		OUTPUT INSERTED.FormatKey 
		SELECT @TargetFormatID AS FormatID
			, BackgroundColor, FontColor, ValueFormat
		FROM [dbo].[sx_pf_hFormats]
		WHERE FormatKey = @SourceFormatKey;

		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_Format] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_Format] TO pf_PlanningFactoryService;
GO
/*
COPY Operation for a List
Not yet existing list is copied if Sources List is available

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target ListID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists SourceList => 404 Not Found
5. Target TargetList already exists => 403 Forbidden
6. List copied => 201 Created

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceListID AS NVARCHAR(255)='sxEvents'
		DECLARE  @TargetListID AS NVARCHAR(255)='88C2'

EXECUTE @RC = [sx_pf_COPY_List] 
		   @Username
		  ,@SourceListID
		  ,@TargetListID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_COPY_List]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_COPY_List];
GO

CREATE PROCEDURE [dbo].[sx_pf_COPY_List]
	@Username AS NVARCHAR(255),
	@SourceListID AS NVARCHAR(255),
	@TargetListID AS NVARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @SourceListKey AS INT = 0;
	DECLARE @TargetListKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceListID, N'NULL') + N''',''' + ISNULL(@TargetListID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceListID IS NULL SET @SourceListID = N'';
	IF @TargetListID IS NULL SET @TargetListID = N'';
	
	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters			
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceListID =[dbo].[sx_pf_pProtectID] (@SourceListID);
		SET @TargetListID = [dbo].[sx_pf_pProtectID] (@TargetListID);

		IF @SourceListID = N'' OR @TargetListID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);		

		-- STEP 1.2 - Determine SourceKeys
		SELECT @SourceListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE ListID = @SourceListID;
		
		IF @SourceListKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @TargetListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE ListID = @TargetListID;

		IF @TargetListKey <> 0		
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target List key already exists', 16, 10);
		END;

		-- STEP 3 - Copy data
		--hLists
		INSERT INTO [dbo].[sx_pf_hLists]
		OUTPUT INSERTED.ListKey 
		SELECT @TargetListID AS ListsID
			, NameShort, NameLong, CommentDev, CommentUser, Datentyp, [Source], SourceFormula, FormatID
		FROM [dbo].[sx_pf_hLists]
		WHERE ListKey = @SourceListKey;
		
		SET @EffectedRows += @@ROWCOUNT;

		--hListValues
		INSERT INTO [dbo].[sx_pf_hListValues] 
		SELECT @TargetListID AS ListsID
			, ValueInt, Scale, ValueText, ValueComment, FormatID
		FROM [dbo].[sx_pf_hListValues]
		WHERE ListID = @SourceListID;

		SET @EffectedRows += @@ROWCOUNT;
		SET @ResultCode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_List] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_List] TO pf_PlanningFactoryService;
GO
/*
COPY Operation for a Product
Not yet existing Product is copied when source product is available

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Factory / Productline / Product => 404 Not Found
5. Not exists target Factory / Productline => 404 Not Found
6. Target Product key already exists => 403 Forbidden
7. Product copied => 201 Created

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFactoryID  AS NVARCHAR(255)='230'
		DECLARE  @SourceProductLineID AS NVARCHAR(255)='I-ST-IT'
		DECLARE  @SourceProductID AS NVARCHAR(255)='888'
		DECLARE  @TargetFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductLineID AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductID AS NVARCHAR(255)='RZ888'
		DECLARE  @TargetProductNameShort  AS NVARCHAR(255)='RZ P Import'

EXECUTE @RC = [sx_pf_COPY_Product] 
		   @Username
		  ,@SourceFactoryID
		  ,@SourceProductLineID
		  ,@SourceProductID
		  ,@TargetFactoryID
		  ,@TargetProductLineID
		  ,@TargetProductID
		  ,@TargetProductNameShort

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_COPY_Product]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_COPY_Product];
GO

CREATE PROCEDURE [dbo].[sx_pf_COPY_Product]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@SourceProductLineID AS NVARCHAR(255),
	@SourceProductID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255),
	@TargetProductLineID AS NVARCHAR(255),
	@TargetProductID AS NVARCHAR(255),
	@TargetProductNameShort AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceProductKey AS INT = 0;
	DECLARE @SourceProductLineKey AS INT = 0;
	DECLARE @TargetProductKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductLineNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductNameShort AS NVARCHAR(255) = N'';
	DECLARE @TargetFactoryKey AS INT = 0;
	DECLARE @TargetProductLineKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@SourceProductLineID, N'NULL') + N''',''' + ISNULL(@SourceProductID, N'NULL') 
		 + N''',''' + ISNULL(@TargetFactoryID, N'NULL') + N''',''' + ISNULL(@TargetProductLineID, N'NULL') + N''',''' + ISNULL(@TargetProductID, N'NULL') + N''',''' + ISNULL(@TargetProductNameShort, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @SourceProductLineID IS NULL SET @SourceProductLineID = N'';
	IF @SourceProductID IS NULL SET @SourceProductID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';
	IF @TargetProductLineID IS NULL SET @TargetProductLineID = N'';
	IF @TargetProductID IS NULL SET @TargetProductID = N'';
	IF @TargetProductNameShort IS NULL SET @TargetProductNameShort = N'';
	
	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters	
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @SourceProductlineID = [dbo].[sx_pf_pProtectID] (@SourceProductlineID);
		SET @SourceProductID = [dbo].[sx_pf_pProtectID] (@SourceProductID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);
		SET @TargetProductlineID = [dbo].[sx_pf_pProtectID] (@TargetProductlineID);
		SET @TargetProductID = [dbo].[sx_pf_pProtectID] (@TargetProductID);
		SET @TargetProductNameShort = [dbo].[sx_pf_pProtectString] (@TargetProductNameShort);

		IF (@SourceFactoryID = N'' OR @SourceProductLineID = N'' OR @SourceProductID = N''
			OR @TargetFactoryID = N'' OR @TargetProductLineID = N'' OR @TargetProductID = N'')	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @TargetFactoryID, @TargetProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights on target', 16, 10);
				
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @SourceFactoryID, @SourceProductLineID;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights on source', 16, 10);

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @SourceFactoryKey = FactoryKey, @SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		SELECT @SourceProductLineKey = ProductLineKey, @SourceProductLineNameShort = Nameshort FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @SourceFactoryKey AND ProductlineID = @SourceProductlineID;
		SELECT @SourceProductKey = ProductKey, @SourceProductNameShort = NameShort FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @SourceFactoryKey AND ProductlineKey = @SourceProductlineKey AND ProductID = @SourceProductID;
		
		IF @SourceFactoryKey = 0 OR @SourceProductLineKey = 0 OR @SourceProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		SELECT @TargetProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TargetFactoryKey AND ProductlineID = @TargetProductlineID;
		SELECT @TargetProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @TargetFactoryKey AND ProductlineKey = @TargetProductlineKey AND ProductID = @TargetProductID;
		
		IF @TargetFactoryKey = 0 OR @TargetProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
		
		IF @TargetProductKey <> 0
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target Product key already exists', 16, 10);
		END;
		
		-- STEP 3 - Copy data		
		--dProduct
		DECLARE @TargetProductKeyTable AS TABLE (KeyNumber BIGINT);

		INSERT INTO [dbo].[sx_pf_dProducts]
		OUTPUT INSERTED.ProductKey INTO @TargetProductKeyTable
		SELECT @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID AS ProductID
			, @TargetProductlineID AS ProductlineID
			, @TargetFactoryID AS FactoryID
			, TimeType
			, @TargetProductNameShort AS NameShort
			, NameLong, CommentUser, CommentDev, ResponsiblePerson, ImageName, Status, Template, TemplateVersion
			, GlobalAttribute1, GlobalAttribute2, GlobalAttribute3, GlobalAttribute4, GlobalAttribute5, GlobalAttribute6, GlobalAttribute7
			, GlobalAttribute8, GlobalAttribute9, GlobalAttribute10, GlobalAttribute11, GlobalAttribute12, GlobalAttribute13, GlobalAttribute14
			, GlobalAttribute15, GlobalAttribute16, GlobalAttribute17, GlobalAttribute18, GlobalAttribute19, GlobalAttribute20, GlobalAttribute21
			, GlobalAttribute22, GlobalAttribute23, GlobalAttribute24, GlobalAttribute25 
		FROM [dbo].[sx_pf_dProducts]
		WHERE ProductKey = @SourceProductKey;

		SET @EffectedRows += @@ROWCOUNT;

		SELECT TOP 1 @TargetProductKey = KeyNumber FROM @TargetProductKeyTable;

		--gProducts Inhalt
		INSERT INTO [dbo].[sx_pf_gProducts]
		SELECT @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID AS FactoryID
			, PropertyID, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
		FROM [dbo].[sx_pf_gProducts]
		WHERE ProductKey = @SourceProductKey;

		SET @EffectedRows += @@ROWCOUNT;

		--dValueSeries
		INSERT INTO [dbo].[sx_pf_dValueSeries]
		SELECT @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID AS FactoryID
			, ValueSeriesID, ValueSeriesNo, NameShort, NameLong, CommentUser, CommentDev, ImageName, [IsNumeric]
			, VisibilityLevel, ValueSource, ValueListID, ValueFormatID, Unit, Scale, Effect, EffectParameter
		FROM [dbo].[sx_pf_dValueSeries]
		WHERE ProductKey = @SourceProductKey;

		SET @EffectedRows += @@ROWCOUNT;

		--dTime
		INSERT INTO [dbo].[sx_pf_dTime]
		SELECT
			 @TargetProductKey AS ProductKey
			,@TargetProductLineKey AS ProductLineKey
			,@TargetFactoryKey AS FactoryKey
			,@TargetProductID AS ProductID
			,@TargetProductlineID AS ProductLineID
			,@TargetFactoryID AS FactoryID
			,TimeID
		FROM [dbo].[sx_pf_dTime]
		WHERE ProductKey = @SourceProductKey;

		SET @EffectedRows += @@ROWCOUNT;

		--fValues
		INSERT INTO [dbo].[sx_pf_fValues]
		SELECT VS.ValueSeriesKey AS ValueSeriesKey
			, @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID AS FactoryID
			, fV.ValueSeriesID, TimeID
			, ValueFormula, ValueInt, ValueText, ValueComment
		FROM [dbo].[sx_pf_fValues] fV
			LEFT JOIN (
				SELECT ValueSeriesKey, ProductKey, ValueSeriesID 
				FROM [dbo].[sx_pf_dValueSeries] 
				WHERE ProductKey = @TargetProductKey) VS 
			ON VS.ValueSeriesID= fV.ValueSeriesID 
		WHERE fV.ProductKey = @SourceProductKey;

		SET @EffectedRows += @@ROWCOUNT;

		--fStatements CopyInformation speichern
		INSERT INTO [dbo].[sx_pf_fStatements]
		SELECT @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID AS FactoryID
			, N'COPY' AS ActionType
			, N'Product produced as a copy of Factory <' + @SourceFactoryID + N'>"' + @SourceFactoryNameShort 
				+ N'"/ ProductLine <' + @SourceProductlineID + N'>"' + @SourceProductLineNameShort 
				+ N'"/ Product <' + @SourceProductID + N'>"' + @SourceProductNameShort + N'"' AS [Statement]
			, @TransactUsername AS UserName
			, N'' AS PCName 
			, N'' AS ProcessorCode 
			, N'' AS IPAddresses
			, CAST(CONVERT(NVARCHAR(10), GETDATE(), 112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10), GETDATE(), 108), 5), N':', N'') AS BIGINT) AS [Timestamp]
			, 0 AS IsDeleted 
			, 0 AS IsResolved;
		
		SET @EffectedRows += @@ROWCOUNT;
		SET @ResultCode = 201;
			
		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_Product] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_Product] TO pf_PlanningFactoryService;
GO
/*
COPY Operation for a ProductLine
Not yet existing ProductLine is copied when Source ProductLine is available

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target  FactoryID / ProductLineID  => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Factory / Productline => 404 Not Found
5. Not exists target Factory => 404 Not Found
6. Target ProductLine key already exists => 403 Forbidden
7. ProductLine copied => 201 Created

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @SourceProductLineID AS NVARCHAR(255)='ZT'
		DECLARE  @TargetFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductLineID AS NVARCHAR(255)='ZT32'
		DECLARE  @TargetProductLineNameShort  AS NVARCHAR(255)='Neue ProductLine32'

EXECUTE @RC = [sx_pf_COPY_ProductLine] 
		   @Username
		  ,@SourceFactoryID
		  ,@SourceProductLineID
		  ,@TargetFactoryID
		  ,@TargetProductLineID
		  ,@TargetProductLineNameShort

PRINT @RC
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_COPY_ProductLine]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_COPY_ProductLine];
GO

CREATE PROCEDURE [dbo].[sx_pf_COPY_ProductLine]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@SourceProductLineID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255),
	@TargetProductLineID AS NVARCHAR(255),
	@TargetProductLineNameShort AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUserKey AS INT = 0;
	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceProductLineKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductLineNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductNameShort AS NVARCHAR(255) = N'';
	DECLARE @TargetFactoryKey AS INT = 0;
	DECLARE @TargetProductLineKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@SourceProductLineID, N'NULL') + N''',''' + ISNULL(@TargetFactoryID, N'NULL') 
		 + N''',''' + ISNULL(@TargetProductLineID, N'NULL') + N''',''' + ISNULL(@TargetProductLineNameShort, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @SourceProductLineID IS NULL SET @SourceProductLineID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';
	IF @TargetProductLineID IS NULL SET @TargetProductLineID = N'';
	IF @TargetProductLineNameShort IS NULL SET @TargetProductLineNameShort = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @SourceProductlineID = [dbo].[sx_pf_pProtectID] (@SourceProductlineID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);
		SET @TargetProductlineID = [dbo].[sx_pf_pProtectID] (@TargetProductlineID);
		SET @TargetProductLineNameShort = [dbo].[sx_pf_pProtectString] (@TargetProductLineNameShort);

		IF @SourceFactoryID = N'' OR @SourceProductLineID = N'' OR @TargetFactoryID = N''
			OR @TargetProductlineID = N'' OR @TargetProductLineNameShort = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @TargetFactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights on target', 16, 10);
				
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @SourceFactoryID;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights on source', 16, 10);

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @SourceFactoryKey = FactoryKey,@SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		SELECT @SourceProductLineKey = ProductLineKey,@SourceProductLineNameShort = Nameshort FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @SourceFactoryKey AND ProductlineID = @SourceProductlineID;
		
		IF @SourceFactoryKey = 0 OR @SourceProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys	
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		SELECT @TargetProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TargetFactoryKey AND ProductlineID = @TargetProductlineID;
		
		IF @TargetFactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
		
		IF @TargetProductLineKey <> 0		
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target ProductLine key already exists', 16, 10);
		END;
		
		-- STEP 3 - Copy data		
		
		DECLARE @Keys AS TABLE ([Key] INT);
		
		--dProductLine
		INSERT INTO [dbo].[sx_pf_dProductLines]
		OUTPUT INSERTED.ProductLineKey INTO @Keys([Key]) 
		SELECT @TargetFactoryKey AS FactoryKey
			, @TargetProductlineID AS ProductlineID
			, @TargetFactoryID AS FactoryID
			, @TargetProductLineNameShort AS NameShort
			, NameLong, CommentUser, CommentDev, ResponsiblePerson, ImageName, DefaultTemplate 
			, GlobalAttributeSource1, GlobalAttributeAlias1, GlobalAttributeSource2, GlobalAttributeAlias2, GlobalAttributeSource3, GlobalAttributeAlias3  
			, GlobalAttributeSource4, GlobalAttributeAlias4, GlobalAttributeSource5, GlobalAttributeAlias5, GlobalAttributeSource6, GlobalAttributeAlias6  
			, GlobalAttributeSource7, GlobalAttributeAlias7, GlobalAttributeSource8, GlobalAttributeAlias8, GlobalAttributeSource9, GlobalAttributeAlias9  	
			, GlobalAttributeSource10, GlobalAttributeAlias10, GlobalAttributeSource11, GlobalAttributeAlias11, GlobalAttributeSource12, GlobalAttributeAlias12  
			, GlobalAttributeSource13, GlobalAttributeAlias13, GlobalAttributeSource14, GlobalAttributeAlias14, GlobalAttributeSource15, GlobalAttributeAlias15 
			, GlobalAttributeSource16, GlobalAttributeAlias16, GlobalAttributeSource17, GlobalAttributeAlias17, GlobalAttributeSource18, GlobalAttributeAlias18  
			, GlobalAttributeSource19, GlobalAttributeAlias19, GlobalAttributeSource20, GlobalAttributeAlias20, GlobalAttributeSource21, GlobalAttributeAlias21  	
			, GlobalAttributeSource22, GlobalAttributeAlias22, GlobalAttributeSource23, GlobalAttributeAlias23, GlobalAttributeSource24, GlobalAttributeAlias24 
			, GlobalAttributeSource25, GlobalAttributeAlias25	
		FROM [dbo].[sx_pf_dProductLines]
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;
		SELECT TOP 1 @TargetProductLineKey = [Key] FROM @Keys;
		

		--dProduct
		INSERT INTO [dbo].[sx_pf_dProducts] 
		SELECT @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, ProductID
			, @TargetProductlineID AS ProductlineID
			, @TargetFactoryID AS FactoryID
			, TimeType, NameShort, NameLong, CommentUser, CommentDev, ResponsiblePerson, ImageName, [Status], Template, TemplateVersion 
			, GlobalAttribute1, GlobalAttribute2, GlobalAttribute3, GlobalAttribute4, GlobalAttribute5, GlobalAttribute6, GlobalAttribute7  
			, GlobalAttribute8, GlobalAttribute9, GlobalAttribute10, GlobalAttribute11, GlobalAttribute12, GlobalAttribute13, GlobalAttribute14 
			, GlobalAttribute15, GlobalAttribute16, GlobalAttribute17, GlobalAttribute18, GlobalAttribute19, GlobalAttribute20, GlobalAttribute21  
			, GlobalAttribute22, GlobalAttribute23, GlobalAttribute24, GlobalAttribute25 
		FROM [dbo].[sx_pf_dProducts] 
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		--dValueSeries
		INSERT INTO [dbo].[sx_pf_dValueSeries] 
		SELECT P.ProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, dVS.ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID AS FactoryID
			, ValueSeriesID, ValueSeriesNo, NameShort, NameLong, CommentUser, CommentDev, ImageName, [IsNumeric], VisibilityLevel, ValueSource, ValueListID 
			, ValueFormatID, Unit, Scale, Effect, EffectParameter
		FROM [dbo].[sx_pf_dValueSeries] dVS
			LEFT JOIN (
				SELECT ProductKey, ProductID 
				FROM [dbo].[sx_pf_dProducts]
				WHERE ProductLineKey = @TargetProductLineKey) P 
			ON P.ProductID = dVS.ProductID 
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		--dTime
		INSERT INTO [dbo].[sx_pf_dTime] 
		SELECT 
			 P.ProductKey AS ProductKey
			,@TargetProductLineKey AS ProductLineKey
			,@TargetFactoryKey AS FactoryKey
			,dT.ProductID
			,@TargetProductlineID AS ProductLineID
			,@TargetFactoryID AS FactoryID
			,TimeID
		FROM [dbo].[sx_pf_dTime] dT
			LEFT JOIN (
				SELECT ProductKey, ProductID 
				FROM [dbo].[sx_pf_dProducts]
				WHERE ProductLineKey = @TargetProductLineKey) P 
			ON P.ProductID = dT.ProductID 
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		--fValues
		INSERT INTO [dbo].[sx_pf_fValues]
		SELECT VS.ValueSeriesKey AS ValueSeriesKey
			, VS.ProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, fV.ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID AS FactoryID
			, fV.ValueSeriesID, TimeID, ValueFormula, ValueInt, ValueText, ValueComment
		FROM [dbo].[sx_pf_fValues] fV
			LEFT JOIN (
				SELECT ValueSeriesKey, ProductKey, ValueSeriesID, ProductID 
				FROM [dbo].[sx_pf_dValueSeries]
				WHERE ProductLineKey = @TargetProductLineKey) VS 
			ON fV.ValueSeriesID=VS.ValueSeriesID AND fV.ProductID=VS.ProductID
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;
		
		--gProductLines 
		INSERT INTO [dbo].[sx_pf_gProductLines]
		SELECT @TargetProductLineKey AS ProductLineKey 
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductlineID AS ProductlineID
			, @TargetFactoryID AS FactoryID
			, PropertyID, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
		FROM [dbo].[sx_pf_gProductLines]
		WHERE ProductLineKey = @SourceProductLineKey;
		
		SET @EffectedRows += @@ROWCOUNT;

		--gProducts 
		INSERT INTO [dbo].[sx_pf_gProducts]  
		SELECT P.ProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, gP.ProductID
			, @TargetProductlineID  AS ProductLineID
			, @TargetFactoryID  AS FactoryID
			, PropertyID, PropertyName, CommentUser, CommentDev, Unit, ValueText, ValueInt, Scale, IsROSystemProperty, FormatID
		FROM [dbo].[sx_pf_gProducts] gP
			LEFT JOIN (
				SELECT ProductKey, ProductID 
				FROM [dbo].[sx_pf_dProducts]  
				WHERE ProductLineKey = @TargetProductLineKey) P
			ON P.ProductID = gP.ProductID 
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		--rRights - no definition, write Rights on Factory will lead to implicit Write Rights for creator

		--rPreferences
		INSERT INTO [dbo].[sx_pf_rPreferences]
		SELECT @TransactUserKey AS UserKey 
			, @TransactUsername AS UserName
			, @TargetFactoryID AS FactoryID
			, @TargetProductlineID AS ProductLineID 
			, SettingName, ValueInt, ValueText
		FROM [dbo].[sx_pf_rPreferences]
		WHERE FactoryID = @SourceFactoryID 
			AND ProductlineID = @SourceProductlineID;
		
		SET @EffectedRows += @@ROWCOUNT;

		--fStatements CopyInformation
		INSERT INTO [dbo].[sx_pf_fStatements]
		SELECT ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey 
			, ProductID
			, @TargetProductlineID  AS ProductLineID
			, @TargetFactoryID  AS FactoryID
			, N'COPY' AS ActionType
			, N'Product produced as a copy of Factory <' + @SourceFactoryID + N'>"' + @SourceFactoryNameShort
				+ N'"/ ProductLine <' + @SourceProductlineID + N'>"' + @SourceProductLineNameShort
				+ N'"/ Product <' + ProductID + N'>"' + Nameshort +  N'"' AS [Statement]
			, @TransactUsername AS UserName
			, N'' AS PCName 
			, N'' AS ProcessorCode 
			, N'' AS IPAddresses
			, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5), N':', N'') AS BIGINT) AS [Timestamp]
			, 0 AS IsDeleted
			, 0 AS IsResolved
		FROM [dbo].[sx_pf_dProducts] 
		WHERE ProductLineKey = @TargetProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		-- Rights materialization 
		EXEC [dbo].[sx_pf_materialize_vUserRights];

		SET @ResultCode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_ProductLine] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_ProductLine] TO pf_PlanningFactoryService;
GO
/*
COPY Operation for one ValueSerie
The ValueSerie will be copied and inserted at last Position

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target FactoryID / ProductLineID / ProductID / ValueSerieID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3 .User has no Rights => 401 Unauthorized
4. Not exists source Factory / Productline / Product / ValueSerie => 404 Not Found
5. Not exists target Factory / Productline / Product => 404 Not Found
6. Target ValueSerie key already exists => 403 Forbidden
7. ValueSerie copied => 201 Created

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFactoryID  AS NVARCHAR(255)='230'
		DECLARE  @SourceProductLineID AS NVARCHAR(255)='I-ST-IT'
		DECLARE  @SourceProductID AS NVARCHAR(255)='888'
		DECLARE  @SourceValueSerieID AS NVARCHAR(255)='C2'
		DECLARE  @TargetFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductLineID AS NVARCHAR(255)='ZT32'
		DECLARE  @TargetProductID AS NVARCHAR(255)='1'
		DECLARE  @TargetValueSerieID AS NVARCHAR(255)='88C2'
		DECLARE  @TargetValueSerieNameShort  AS NVARCHAR(255)='Kosten Test'

EXECUTE @RC = [sx_pf_COPY_ValueSerie] 
		   @Username
		  ,@SourceFactoryID
		  ,@SourceProductLineID
		  ,@SourceProductID
		  ,@SourceValueSerieID
		  ,@TargetFactoryID
		  ,@TargetProductLineID
		  ,@TargetProductID
		  ,@TargetValueSerieID
		  ,@TargetValueSerieNameShort

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_COPY_ValueSerie]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_COPY_ValueSerie];
GO

CREATE PROCEDURE [dbo].[sx_pf_COPY_ValueSerie]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@SourceProductLineID AS NVARCHAR(255),
	@SourceProductID AS NVARCHAR(255),
	@SourceValueSerieID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255),
	@TargetProductLineID AS NVARCHAR(255),
	@TargetProductID AS NVARCHAR(255),
	@TargetValueSerieID AS NVARCHAR(255),
	@TargetValueSerieNameShort AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceProductLineKey AS INT = 0;
	DECLARE @SourceProductKey AS INT = 0;
	DECLARE @SourceValueSerieKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductLineNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceValueSerieNameShort AS NVARCHAR(255)  = N'';
	DECLARE @TargetFactoryKey AS INT = 0;
	DECLARE @TargetProductLineKey AS INT = 0;
	DECLARE @TargetProductKey AS INT = 0;
	DECLARE @TargetValueSerieKey AS INT = 0;
	DECLARE @TargetValueSerieNo AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@SourceProductLineID, N'NULL') + N''',''' + ISNULL(@SourceProductID, N'NULL') + N''',''' +
		 N''',''' + ISNULL(CAST(@SourceValueSerieID AS NVARCHAR(255)), N'NULL') + N''',''' + ISNULL(@TargetFactoryID, N'NULL') + N''',''' + ISNULL(@TargetProductLineID, N'NULL') + N''',''' + ISNULL(@TargetProductID, N'NULL') + 
		 N''',''' + ISNULL(@TargetValueSerieID, N'NULL') + N''',''' + ISNULL(@TargetValueSerieNameShort, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @SourceProductLineID IS NULL SET @SourceProductLineID = N'';
	IF @SourceProductID IS NULL SET @SourceProductID = N'';
	IF @SourceValueSerieID IS NULL SET @SourceValueSerieID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';
	IF @TargetProductLineID IS NULL SET @TargetProductLineID = N'';
	IF @TargetProductID IS NULL SET @TargetProductID = N'';
	IF @TargetValueSerieID IS NULL SET @TargetValueSerieID = N'';
	IF @TargetValueSerieNameShort IS NULL SET @TargetValueSerieNameShort = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @SourceProductlineID = [dbo].[sx_pf_pProtectID] (@SourceProductlineID);
		SET @SourceProductID = [dbo].[sx_pf_pProtectID] (@SourceProductID);
		SET @SourceValueSerieID = [dbo].[sx_pf_pProtectID] (@SourceValueSerieID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);
		SET @TargetProductlineID = [dbo].[sx_pf_pProtectID] (@TargetProductlineID);
		SET @TargetProductID = [dbo].[sx_pf_pProtectID] (@TargetProductID);
		SET @TargetValueSerieID = [dbo].[sx_pf_pProtectID] (@TargetValueSerieID);
		SET @TargetValueSerieNameShort = [dbo].[sx_pf_pProtectString] (@TargetValueSerieNameShort);

		IF @SourceFactoryID = N'' OR @SourceProductLineID = N'' OR @SourceProductID = N'' OR @SourceValueSerieID = N''
			OR @TargetFactoryID = N'' OR @TargetProductLineID = N'' OR @TargetProductID = N'' OR @TargetValueSerieID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
			
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @TargetFactoryID, @TargetProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights on target', 16, 10);
				
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername,@SourceFactoryID, @SourceProductLineID;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights on source', 16, 10);

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @SourceFactoryKey = FactoryKey, @SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		SELECT @SourceProductLineKey = ProductLineKey, @SourceProductLineNameShort = NameShort FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @SourceFactoryKey AND ProductlineID = @SourceProductlineID;
		SELECT @SourceProductKey = ProductKey, @SourceProductNameShort = NameShort FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @SourceProductlineKey AND ProductID= @SourceProductID;
		SELECT @SourceValueSerieKey = ValueSeriesKey, @SourceValueSerieNameShort = NameShort FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @SourceProductKey  AND ValueSeriesID= @SourceValueSerieID;	
		
		IF @SourceFactoryKey = 0 OR @SourceProductLineKey = 0 OR @SourceProductKey = 0 OR @SourceValueSerieKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;
		
		-- STEP 1.3 - Determine TargetKeys	
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		SELECT @TargetProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TargetFactoryKey AND ProductlineID = @TargetProductlineID;
		SELECT @TargetProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE  FactoryKey = @TargetFactoryKey  AND ProductlineKey = @TargetProductlineKey AND ProductID = @TargetProductID;
		SELECT @TargetValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @TargetProductKey  AND ValueSeriesID= @TargetValueSerieID;
				
		IF @TargetFactoryKey = 0 OR @TargetProductLineKey = 0 OR @TargetProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
		
		IF @TargetValueSerieKey <> 0
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target ValueSerie key already exists', 16, 10);
		END;

		-- STEP 3 - Copy data 
		SELECT @TargetValueSerieNo = MAX(ValueSeriesNo) + 1 FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @TargetProductKey;
		
		DECLARE @Keys AS TABLE ([Key] INT);

		INSERT INTO [dbo].[sx_pf_dValueSeries] 
		OUTPUT INSERTED.ValueSeriesKey INTO @Keys([Key])
		SELECT @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID  AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID  AS FactoryID
			, @TargetValueSerieID AS ValueSeriesID
			, @TargetValueSerieNo AS ValueSeriesNo
			, @TargetValueSerieNameShort AS NameShort
			, NameLong, CommentUser, CommentDev, ImageName, [IsNumeric], VisibilityLevel, ValueSource, ValueListID, ValueFormatID, Unit, Scale, Effect, EffectParameter
		FROM [dbo].[sx_pf_dValueSeries] 
		WHERE ValueSeriesKey = @SourceValueSerieKey;

		SET @EffectedRows += @@ROWCOUNT;
		SELECT TOP 1 @TargetValueSerieKey = [Key] FROM @Keys;
		
		--fValues
		INSERT INTO [dbo].[sx_pf_fValues]  
		SELECT @TargetValueSerieKey AS ValueSeriesKey
			, @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID  AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID  AS FactoryID
			, @TargetValueSerieID AS ValueSeriesID
			, TimeID, ValueFormula, ValueInt, ValueText, ValueComment
		FROM [dbo].[sx_pf_fValues]
		WHERE ValueSeriesKey = @SourceValueSerieKey;

		SET @EffectedRows += @@ROWCOUNT;

		--fStatements 
		INSERT INTO [dbo].[sx_pf_fStatements]
		SELECT @TargetProductKey AS ProductKey
			, @TargetProductLineKey AS ProductLineKey
			, @TargetFactoryKey AS FactoryKey
			, @TargetProductID  AS ProductID
			, @TargetProductlineID AS ProductLineID
			, @TargetFactoryID  AS FactoryID
			, N'COPY' AS ActionType
			, N'New ValueSerieID <' + @TargetValueSerieID + N'>"' + @TargetValueSerieNameShort
				+ N'" for product produced as a copy of Factory <' + @SourceFactoryID + N'>"' +  @SourceFactoryNameShort
				+ N'"/ ProductLine <' + @SourceProductlineID + N'>"' +  @SourceProductLineNameShort
				+ N'"/ Product <' + @SourceProductID + N'>"' +  @SourceProductNameShort
				+ N'"/ ValueSerie <' + @SourceValueSerieID + N'>"' +  @SourceValueSerieNameShort + N'"' AS [Statement]
			, @TransactUsername AS UserName
			, '' AS PCName 
			, '' AS ProcessorCode 
			, '' AS IPAddresses
			, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5), N':', N'') AS BIGINT) AS [Timestamp]
			, 0 AS IsDeleted 
			, 0 AS IsResolved;

		SET @EffectedRows += @@ROWCOUNT;
		SET @ResultCode = 201;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_ValueSerie] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_COPY_ValueSerie] TO pf_PlanningFactoryService;
GO
/*
MOVE Operation for a Factory
Factory moved by the update IDs without key change

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target FactoryID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Factory => 404 Not Found
5. Exists target Factory => 403 Forbidden
6. Factory moved => 200 OK
7. Don`t moved anything => 204 No content

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TargetFactoryID  AS NVARCHAR(255)='ZT'

EXECUTE @RC = [sx_pf_MOVE_Factory] 
		   @Username
		  ,@SourceFactoryID
		  ,@TargetFactoryID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_MOVE_Factory]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_MOVE_Factory];
GO

CREATE PROCEDURE [dbo].[sx_pf_MOVE_Factory]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUserKey AS INT = 0;
	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @TargetFactoryKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@TargetFactoryID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters	
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);

		IF @SourceFactoryID = N'' OR @TargetFactoryID = N''	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);	

		-- STEP 1.2 - Determine SourceKeys
		SELECT @SourceFactoryKey = FactoryKey, @SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		IF @SourceFactoryKey = 0	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		IF @TargetFactoryKey <> 0 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target Factory key already exists', 16, 10);
		END;
		
		-- STERP 3 - Move data
		--dFactory 
		UPDATE [dbo].[sx_pf_dFactories]
		SET FactoryID = @TargetFactoryID 
		WHERE FactoryKey = @SourceFactoryKey;

		SET @EffectedRows += @@ROWCOUNT;
		
		IF @EffectedRows = 0
		BEGIN 
			SET @ResultCode = 204;
		END		
		ELSE
		BEGIN
			--dProductLine  
			UPDATE [dbo].[sx_pf_dProductLines]
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dProduct 
			UPDATE [dbo].[sx_pf_dProducts]
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dValueSeries
			UPDATE [dbo].[sx_pf_dValueSeries]
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dTime
			UPDATE [dbo].[sx_pf_dValueSeries]
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			--fValues
			UPDATE [dbo].[sx_pf_fValues]
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			--gFactories
			UPDATE [dbo].[sx_pf_gFactories] 
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			--gProductLines Inhalt
			UPDATE [dbo].[sx_pf_gProductLines] 
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;
		
			--gProducts 
			UPDATE [dbo].[sx_pf_gProducts] 
			SET FactoryID  = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;
		
			SET @EffectedRows += @@ROWCOUNT;

			--rRights 
			UPDATE [dbo].[sx_pf_rRights] 
			SET FactoryID = @TargetFactoryID
			WHERE FactoryID = @SourceFactoryID;

			SET @EffectedRows += @@ROWCOUNT;

			--rPreferences
			UPDATE [dbo].[sx_pf_rPreferences] 
			SET FactoryID = @TargetFactoryID,
				UserKey = @TransactUserKey,
				UserName = @TransactUsername
			WHERE FactoryID = @SourceFactoryID;

			SET @EffectedRows += @@ROWCOUNT;

			SET @ResultCode = IIF(@EffectedRows > 0, 201, 204);

			--fStatements
			UPDATE [dbo].[sx_pf_fStatements] 
			SET FactoryID = @TargetFactoryID 
			WHERE FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			INSERT INTO [dbo].[sx_pf_fStatements]   
			SELECT ProductKey
				, dp.ProductLineKey
				, @TargetFactoryKey AS FactoryKey
				, ProductID
				, dp.ProductLineID
				, @TargetFactoryID AS FactoryID
				, N'MOVE' AS ActionType
				, N'Factory is moved from Factory <' + @SourceFactoryID + N'>"' + @SourceFactoryNameShort
					+ N'" / ProductLine <' + dp.ProductlineID + N'>"' + ISNULL(dpl.Nameshort, N'NULL') 
					+ N'" / Product <' + ProductID  + N'>"' + dp.Nameshort +  N'"' AS [Statement]
				, @TransactUsername AS UserName
				, N'' AS PCName
				, N'' AS ProcessorCode
				, N'' AS IPAddresses
				, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5), N':', N'') AS BIGINT) AS [Timestamp]
				, 0 AS IsDeleted
				, 0 AS IsResolved
			FROM [dbo].[sx_pf_dProducts] dp LEFT JOIN [dbo].[sx_pf_dProductLines] dpl
				ON dp.ProductLinekey = dpl.ProductLineKey
			WHERE dp.FactoryKey = @SourceFactoryKey;

			SET @EffectedRows += @@ROWCOUNT;

			-- Rights materialization
			EXEC [dbo].[sx_pf_materialize_vUserRights];

		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_Factory] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_Factory] TO pf_PlanningFactoryService;
GO
/*
Move Operation for a Format - all objects, which an FormatID are switched to use a new FormatID.
Replace the OldFormatID with the new FormatID in sx_pf_dValueSeries
Replace the OldFormatID with the new FormatID in sx_pf_hListValues
Delete the OldFormatID in sx_pf_hFormats

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target FormatID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Format => 404 Not Found
5. Not exists target Format => 404 Not Found
6. Format moved => 200 OK
7. Don`t moved anything => 204 No content

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @OldFormatID AS NVARCHAR(255)=''
		DECLARE  @NewFormatID AS NVARCHAR(255)=''

EXECUTE @RC = [sx_pf_MOVE_Format]
		   @Username
		  ,@OldFormatID
		  ,@NewFormatID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_MOVE_Format]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_MOVE_Format];
GO

CREATE PROCEDURE [dbo].[sx_pf_MOVE_Format]
	@Username AS NVARCHAR(255),
	@OldFormatID AS NVARCHAR(255),
	@NewFormatID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @OldFormatKey AS INT = 0;
	DECLARE @NewFormatKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@OldFormatID, N'NULL') + N''',''' + ISNULL(@NewFormatID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @OldFormatID IS NULL SET @OldFormatID = N'';
	IF @NewFormatID IS NULL SET @NewFormatID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters	
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @OldFormatID = [dbo].[sx_pf_pProtectID] (@OldFormatID);
		SET @NewFormatID = [dbo].[sx_pf_pProtectID] (@NewFormatID);

		IF (@OldFormatID = N'' OR @NewFormatID = N'')	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);		

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @OldFormatKey = FormatKey FROM [dbo].[sx_pf_hFormats] WHERE [FormatID] = @OldFormatID;
		
		IF @OldFormatKey = 0
		BEGIN															
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);							 
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @NewFormatKey = FormatKey FROM [dbo].[sx_pf_hFormats] WHERE [FormatID] = @NewFormatID;
		
		IF @NewFormatKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
			
		-- STEP 3 - Move data
		UPDATE [dbo].[sx_pf_dValueSeries]
		   SET [ValueFormatID] = @NewFormatID 
		WHERE [ValueFormatID] = @OldFormatID;
																							
		SET @EffectedRows += @@ROWCOUNT;
																						   
		UPDATE [dbo].[sx_pf_hListValues]
		   SET [FormatID] = @NewFormatID 
		WHERE [FormatID] = @OldFormatID;
		
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_hFormats] WHERE [FormatID] = @OldFormatID;
		SET @EffectedRows += @@ROWCOUNT;
		
		IF @EffectedRows = 0
		BEGIN 
			SET @ResultCode = 204;
		END;		

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_Format] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_Format] TO pf_PlanningFactoryService;
GO
/*
Move Operation for a List
The Procedure will change the OldListID into the NewListID in tables:
[sx_pf_dValueSeries], column ValueListID
[sx_pf_dProductlines], columns GlobalAttributeSource 1..25
create members from OldListID in NewListID if they don't exist there
(for Lists of Type string compare and create ValueText, for Lists of Type Integer compare and create ValueInt)
delete the OldListID in [sx_pf_hLists]
delete the Old List Values in [sx_pf_hListValues]

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ClusterWriteRight
		- sx_pf_pPOST_API_LogEntry

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target ListID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source List => 404 Not Found
5. Not exists target List => 404 Not Found
6. List moved => 200 OK
7. Don`t moved anything => 204 No content

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @OldListID AS NVARCHAR(255)='suEvents'
		DECLARE  @NewListID AS NVARCHAR(255)='suYesNo'

EXECUTE @RC = [sx_pf_MOVE_List]
		   @Username
		  ,@OldListID
		  ,@NewListID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_MOVE_List]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_MOVE_List];
GO

CREATE PROCEDURE [dbo].[sx_pf_MOVE_List]
	@Username AS NVARCHAR(255),
	@OldListID AS NVARCHAR(255),
	@NewListID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @OldListKey AS INT = 0;
	DECLARE @NewListKey AS INT = 0;
	DECLARE @NewListType AS NVARCHAR(255)= N'';

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@OldListID, N'NULL') + N''',''' + ISNULL(@NewListID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @OldListID IS NULL SET @OldListID = N'';
	IF @NewListID IS NULL SET @NewListID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters	
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @OldListID = [dbo].[sx_pf_pProtectID] (@OldListID);
		SET @NewListID = [dbo].[sx_pf_pProtectID] (@NewListID);

		IF (@OldListID = N'' OR @NewListID = N'')	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END 
		ELSE IF @OldListID IN ('sxIsNumeric', 'sxScales', 'sxValueEffects', 'sxValueLists', 'sxValueFormats', 'sxValueSources', 'sxVisibilityLevel') 
			OR @NewListID IN ('sxIsNumeric', 'sxScales', 'sxValueEffects', 'sxValueLists', 'sxValueFormats', 'sxValueSources', 'sxVisibilityLevel')
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Invalid input parameters', 16, 10);
 		END;;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ClusterWriteRight] @TransactUsername;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);		

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @OldListKey = ListKey FROM [dbo].[sx_pf_hLists] WHERE [ListID] = @OldListID;
		
		IF @OldListKey = 0
		BEGIN															
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);							 
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @NewListKey = [ListKey], @NewListType = [Datentyp] FROM [dbo].[sx_pf_hLists] WHERE [ListID] = @NewListID;
		
		IF @NewListKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
							 
		-- STEP 3 - Move data
		-- STEP 3.1 - Move not exists UNIQUE list members

		IF @NewListType = 'Integer'
		BEGIN

			;WITH vals AS (
				SELECT v1.[ListValueKey] 
					, v1.[ValueInt]
					, v1.[Scale]
					, v1.[ValueText]
					, v1.[ValueComment]
					, v1.[FormatID]
				FROM [dbo].[sx_pf_hListValues] v1 LEFT JOIN  [dbo].[sx_pf_hListValues] v2 
					ON v2.[ListID] = @NewListID AND v1.ValueInt = v2.ValueInt
				WHERE v1.[ListID] = @OldListID AND v2.ListID IS NULL 
			),
			uniq AS (
				SELECT TOP 1 WITH TIES [ListValueKey]
				FROM vals
				ORDER BY ROW_NUMBER() OVER (PARTITION BY [ValueInt] ORDER BY [ListValueKey])
			)																				   
			INSERT INTO [dbo].[sx_pf_hListValues] ([ListID], [ValueInt], [Scale], [ValueText], [ValueComment], [FormatID])
			SELECT @NewListID, [ValueInt], [Scale], [ValueText], [ValueComment], [FormatID]
			FROM vals INNER JOIN uniq ON vals.[ListValueKey] = uniq.[ListValueKey];

			SET @EffectedRows += @@ROWCOUNT;
		END
		ELSE IF @NewListType = 'String'
		BEGIN

			;WITH vals AS (
				SELECT v1.[ListValueKey] 
					, v1.[ValueInt]
					, v1.[Scale]
					, v1.[ValueText]
					, v1.[ValueComment]
					, v1.[FormatID]
				FROM [dbo].[sx_pf_hListValues] v1 LEFT JOIN  [dbo].[sx_pf_hListValues] v2 
					ON v2.[ListID] = @NewListID AND v1.[ValueText] = v2.[ValueText]
				WHERE v1.[ListID] = @OldListID AND v2.ListID IS NULL 
			),
			uniq AS (
				SELECT TOP 1 WITH TIES [ListValueKey]
				FROM vals
				ORDER BY ROW_NUMBER() OVER (PARTITION BY [ValueText] ORDER BY [ListValueKey])
			)																				   
			INSERT INTO [dbo].[sx_pf_hListValues] ([ListID], [ValueInt], [Scale], [ValueText], [ValueComment], [FormatID])
			SELECT @NewListID, [ValueInt], [Scale], [ValueText], [ValueComment], [FormatID]
			FROM vals INNER JOIN uniq ON vals.[ListValueKey] = uniq.[ListValueKey];

			SET @EffectedRows += @@ROWCOUNT;
		END;

		-- STEP 3.2 - Force all objects, which use a old list, to use a new list now
		UPDATE [dbo].[sx_pf_dValueSeries]
		   SET [ValueListID] = @NewListID 
		WHERE [ValueListID] = @OldListID;
																							
		SET @EffectedRows += @@ROWCOUNT;
		
		;WITH lines AS (
			SELECT [ProductLineKey] 
			FROM [dbo].[sx_pf_dProductLines]
			WHERE [GlobalAttributeSource1] = @OldListID OR [GlobalAttributeSource2] = @OldListID OR [GlobalAttributeSource3] = @OldListID OR
				[GlobalAttributeSource4] = @OldListID OR [GlobalAttributeSource5] = @OldListID OR [GlobalAttributeSource6] = @OldListID OR
				[GlobalAttributeSource7] = @OldListID OR [GlobalAttributeSource8] = @OldListID OR [GlobalAttributeSource9] = @OldListID OR
				[GlobalAttributeSource10] = @OldListID OR [GlobalAttributeSource11] = @OldListID OR [GlobalAttributeSource12] = @OldListID OR
				[GlobalAttributeSource13] = @OldListID OR [GlobalAttributeSource14] = @OldListID OR [GlobalAttributeSource15] = @OldListID OR
				[GlobalAttributeSource16] = @OldListID OR [GlobalAttributeSource17] = @OldListID OR [GlobalAttributeSource18] = @OldListID OR
				[GlobalAttributeSource19] = @OldListID OR [GlobalAttributeSource20] = @OldListID OR [GlobalAttributeSource21] = @OldListID OR
				[GlobalAttributeSource22] = @OldListID OR [GlobalAttributeSource23] = @OldListID OR [GlobalAttributeSource24] = @OldListID OR
				[GlobalAttributeSource25] = @OldListID 
		)
		UPDATE pl
		SET [GlobalAttributeSource1] = IIF([GlobalAttributeSource1] = @OldListID, @NewListID, [GlobalAttributeSource1])
			, [GlobalAttributeSource2] = IIF([GlobalAttributeSource2] = @OldListID, @NewListID, [GlobalAttributeSource2])
			, [GlobalAttributeSource3] = IIF([GlobalAttributeSource3] = @OldListID, @NewListID, [GlobalAttributeSource3])
			, [GlobalAttributeSource4] = IIF([GlobalAttributeSource4] = @OldListID, @NewListID, [GlobalAttributeSource4])
			, [GlobalAttributeSource5] = IIF([GlobalAttributeSource5] = @OldListID, @NewListID, [GlobalAttributeSource5])
			, [GlobalAttributeSource6] = IIF([GlobalAttributeSource6] = @OldListID, @NewListID, [GlobalAttributeSource6])
			, [GlobalAttributeSource7] = IIF([GlobalAttributeSource7] = @OldListID, @NewListID, [GlobalAttributeSource7])
			, [GlobalAttributeSource8] = IIF([GlobalAttributeSource8] = @OldListID, @NewListID, [GlobalAttributeSource8])
			, [GlobalAttributeSource9] = IIF([GlobalAttributeSource9] = @OldListID, @NewListID, [GlobalAttributeSource9])
			, [GlobalAttributeSource10] = IIF([GlobalAttributeSource10] = @OldListID, @NewListID, [GlobalAttributeSource10])
			, [GlobalAttributeSource11] = IIF([GlobalAttributeSource11] = @OldListID, @NewListID, [GlobalAttributeSource11])
			, [GlobalAttributeSource12] = IIF([GlobalAttributeSource12] = @OldListID, @NewListID, [GlobalAttributeSource12])
			, [GlobalAttributeSource13] = IIF([GlobalAttributeSource13] = @OldListID, @NewListID, [GlobalAttributeSource13])
			, [GlobalAttributeSource14] = IIF([GlobalAttributeSource14] = @OldListID, @NewListID, [GlobalAttributeSource14])
			, [GlobalAttributeSource15] = IIF([GlobalAttributeSource15] = @OldListID, @NewListID, [GlobalAttributeSource15])
			, [GlobalAttributeSource16] = IIF([GlobalAttributeSource16] = @OldListID, @NewListID, [GlobalAttributeSource16])
			, [GlobalAttributeSource17] = IIF([GlobalAttributeSource17] = @OldListID, @NewListID, [GlobalAttributeSource17])
			, [GlobalAttributeSource18] = IIF([GlobalAttributeSource18] = @OldListID, @NewListID, [GlobalAttributeSource18])
			, [GlobalAttributeSource19] = IIF([GlobalAttributeSource19] = @OldListID, @NewListID, [GlobalAttributeSource19])
			, [GlobalAttributeSource20] = IIF([GlobalAttributeSource20] = @OldListID, @NewListID, [GlobalAttributeSource20])
			, [GlobalAttributeSource21] = IIF([GlobalAttributeSource21] = @OldListID, @NewListID, [GlobalAttributeSource21])
			, [GlobalAttributeSource22] = IIF([GlobalAttributeSource22] = @OldListID, @NewListID, [GlobalAttributeSource22])
			, [GlobalAttributeSource23] = IIF([GlobalAttributeSource23] = @OldListID, @NewListID, [GlobalAttributeSource23])
			, [GlobalAttributeSource24] = IIF([GlobalAttributeSource24] = @OldListID, @NewListID, [GlobalAttributeSource24])
			, [GlobalAttributeSource25] = IIF([GlobalAttributeSource25] = @OldListID, @NewListID, [GlobalAttributeSource25])
		FROM [dbo].[sx_pf_dProductLines] pl INNER JOIN lines l ON pl.ProductLineKey = l.ProductLineKey;
		
		SET @EffectedRows += @@ROWCOUNT;

		-- STEP 3.3 - Remove old list
				
		DELETE FROM [dbo].[sx_pf_hListValues] WHERE [ListID] = @OldListID;
		SET @EffectedRows += @@ROWCOUNT;

		DELETE FROM [dbo].[sx_pf_hLists] WHERE [ListKey] = @OldListKey;
		SET @EffectedRows += @@ROWCOUNT;
		
		IF @EffectedRows = 0
		BEGIN 
			SET @ResultCode = 204;
		END;		

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_List] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_List] TO pf_PlanningFactoryService;
GO
/*
Move Operation for a Product
Product moved by ID update

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target FactoryID / ProductLineID / ProductID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Factory / Productline / Product => 404 Not Found
5. Not exists target Factory / Productline => 404
6. Exists TargetProduct => 403 Forbidden 
7. Product moved => 200 OK
8. Don`t moved anything => 204 No content

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFactoryID  AS NVARCHAR(255)='230'
		DECLARE  @SourceProductLineID AS NVARCHAR(255)='I-ST-IT'
		DECLARE  @SourceProductID AS NVARCHAR(255)='888'
		DECLARE  @TargetFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductLineID AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductID AS NVARCHAR(255)='RZ888'

EXECUTE @RC = [sx_pf_MOVE_Product] 
		   @Username
		  ,@SourceFactoryID
		  ,@SourceProductLineID
		  ,@SourceProductID
		  ,@TargetFactoryID
		  ,@TargetProductLineID
		  ,@TargetProductID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_MOVE_Product]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_MOVE_Product];
GO

CREATE PROCEDURE [dbo].[sx_pf_MOVE_Product]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@SourceProductLineID AS NVARCHAR(255),
	@SourceProductID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255),
	@TargetProductLineID AS NVARCHAR(255),
	@TargetProductID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceProductKey AS INT = 0;
	DECLARE @SourceProductLineKey AS INT = 0;
	DECLARE @TargetProductKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductLineNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductNameShort AS NVARCHAR(255) = N'';
	DECLARE @TargetFactoryKey AS INT = 0;
	DECLARE @TargetProductLineKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@SourceProductLineID, N'NULL') + N''',''' + ISNULL(@SourceProductID, N'NULL') 
			+ N''',''' + ISNULL(@TargetFactoryID, N'NULL') + N''',''' + ISNULL(@TargetProductLineID, N'NULL') + N''',''' + ISNULL(@TargetProductID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @SourceProductLineID IS NULL SET @SourceProductLineID = N'';
	IF @SourceProductID IS NULL SET @SourceProductID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';
	IF @TargetProductLineID IS NULL SET @TargetProductLineID = N'';
	IF @TargetProductID IS NULL SET @TargetProductID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;
				
		-- STEP 0.2 - Protect input parameters	
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @SourceProductlineID = [dbo].[sx_pf_pProtectID] (@SourceProductlineID);
		SET @SourceProductID = [dbo].[sx_pf_pProtectID] (@SourceProductID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);
		SET @TargetProductlineID = [dbo].[sx_pf_pProtectID] (@TargetProductlineID);
		SET @TargetProductID = [dbo].[sx_pf_pProtectID] (@TargetProductID);

		IF (@SourceFactoryID = N'' OR @SourceProductLineID = N'' OR @SourceProductID = N''
			OR @TargetFactoryID = N'' OR @TargetProductLineID = N'' OR @TargetProductID = N'')	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @TargetFactoryID, @TargetProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights on target', 16, 10);
				
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @SourceFactoryID, @SourceProductLineID;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights on source', 16, 10);

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @SourceFactoryKey = FactoryKey, @SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		SELECT @SourceProductLineKey = ProductLineKey, @SourceProductLineNameShort = Nameshort FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @SourceFactoryKey AND ProductlineID = @SourceProductlineID;
		SELECT @SourceProductKey = ProductKey, @SourceProductNameShort = NameShort FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @SourceFactoryKey AND ProductlineKey = @SourceProductlineKey AND ProductID = @SourceProductID;
		
		IF @SourceFactoryKey = 0 OR @SourceProductLineKey = 0 OR @SourceProductKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		SELECT @TargetProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TargetFactoryKey AND ProductlineID = @TargetProductlineID;
		SELECT @TargetProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @TargetFactoryKey AND ProductlineKey = @TargetProductlineKey AND ProductID = @TargetProductID;
		
		IF @TargetFactoryKey = 0 OR @TargetProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
		
		IF @TargetProductKey <> 0
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target Product key already exists', 16, 10);
		END;
			
		-- STEP 3 - Move data
		--dProduct 
		UPDATE [dbo].[sx_pf_dProducts] 
		SET FactoryKey = @TargetFactoryKey
			, ProductLineKey = @TargetProductLineKey
			, FactoryID = @TargetFactoryID
			, ProductLineID = @TargetProductLineID
			, ProductID = @TargetProductID 
		WHERE ProductKey = @SourceProductKey;
					 
		SET @EffectedRows += @@ROWCOUNT;

		IF @EffectedRows = 0
		BEGIN 
			SET @ResultCode = 204;
		END		
		ELSE
		BEGIN
			--gProducts 
			UPDATE [dbo].[sx_pf_gProducts] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineKey = @TargetProductLineKey
				, FactoryID = @TargetFactoryID
				, ProductLineID = @TargetProductLineID
				, ProductID = @TargetProductID 
			WHERE ProductKey = @SourceProductKey;

			SET @EffectedRows += @@ROWCOUNT;
		
			--dValueSeries
			UPDATE [dbo].[sx_pf_dValueSeries] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineKey = @TargetProductLineKey
				, FactoryID = @TargetFactoryID
				, ProductLineID = @TargetProductLineID
				, ProductID = @TargetProductID 
			WHERE ProductKey = @SourceProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dTime
			UPDATE [dbo].[sx_pf_dTime] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineKey = @TargetProductLineKey
				, FactoryID = @TargetFactoryID
				, ProductLineID = @TargetProductLineID
				, ProductID = @TargetProductID 
			WHERE ProductKey = @SourceProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--fValues
			UPDATE [dbo].[sx_pf_fValues] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineKey = @TargetProductLineKey
				, FactoryID = @TargetFactoryID
				, ProductLineID = @TargetProductLineID
				, ProductID = @TargetProductID 
			WHERE ProductKey = @SourceProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			--fStatements 
			UPDATE [dbo].[sx_pf_fStatements] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineKey = @TargetProductLineKey
				, FactoryID = @TargetFactoryID
				, ProductLineID = @TargetProductLineID
				, ProductID = @TargetProductID 
			WHERE ProductKey = @SourceProductKey;

			SET @EffectedRows += @@ROWCOUNT;

			INSERT INTO [dbo].[sx_pf_fStatements] 
			SELECT @SourceProductKey AS ProductKey
				, @TargetProductLineKey AS ProductLineKey
				, @TargetFactoryKey AS FactoryKey
				, @TargetProductID  AS ProductID
				, @TargetProductlineID AS ProductLineID
				, @TargetFactoryID AS FactoryID
				, N'MOVE' AS ActionType
				, N'Product is moved from Factory <' + @SourceFactoryID + N'>"' + @SourceFactoryNameShort 
					+ N'"/ ProductLine <' + @SourceProductlineID + N'>"' + @SourceProductLineNameShort 
					+ N'"/ Product <' + @SourceProductID + N'>"' + @SourceProductNameShort + N'"' AS [Statement]
				, @TransactUsername AS UserName
				, N'' AS PCName
				, N'' AS ProcessorCode
				, N'' AS IPAddresses
				, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5), N':', N'') AS BIGINT) AS [Timestamp]
				, 0 AS IsDeleted
				, 0 AS IsResolved;

			SET @EffectedRows += @@ROWCOUNT;
		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_Product] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_Product] TO pf_PlanningFactoryService;
GO
/*
MOVE Operation for a ProductLine
Productline moved by the update IDs without key change

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pGET_FactoryWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty source or target  FactoryID / ProductLineID  => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists source Factory / Productline => 404 Not Found
5. Not exists target  Factory und existierende Target Productline => 404  Not Found
6. Target ValueSerie key already exists => 403 Forbidden
7. ProductLine moved => 200 OK
8. Don`t moved anything => 204 No content

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @SourceFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @SourceProductLineID AS NVARCHAR(255)='ZT'
		DECLARE  @TargetFactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @TargetProductLineID AS NVARCHAR(255)='ZT32'

EXECUTE @RC = [sx_pf_MOVE_ProductLine] 
		   @Username
		  ,@SourceFactoryID
		  ,@SourceProductLineID
		  ,@TargetFactoryID
		  ,@TargetProductLineID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_MOVE_ProductLine]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_MOVE_ProductLine];
GO

CREATE PROCEDURE [dbo].[sx_pf_MOVE_ProductLine]
	@Username AS NVARCHAR(255),
	@SourceFactoryID AS NVARCHAR(255),
	@SourceProductLineID AS NVARCHAR(255),
	@TargetFactoryID AS NVARCHAR(255),
	@TargetProductLineID AS NVARCHAR(255)
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUserKey AS INT = 0;
	DECLARE @SourceFactoryKey AS INT = 0;
	DECLARE @SourceProductLineKey AS INT = 0;
	DECLARE @SourceFactoryNameShort AS NVARCHAR(255) = N'';
	DECLARE @SourceProductLineNameShort AS NVARCHAR(255) = N'';
	DECLARE @TargetFactoryKey AS INT = 0;
	DECLARE @TargetProductLineKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@SourceFactoryID, N'NULL') + N''',''' + ISNULL(@SourceProductLineID, N'NULL') + N''',''' + ISNULL(@TargetFactoryID, N'NULL') 
		 + N''',''' + ISNULL(@TargetProductLineID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @SourceFactoryID IS NULL SET @SourceFactoryID = N'';
	IF @SourceProductLineID IS NULL SET @SourceProductLineID = N'';
	IF @TargetFactoryID IS NULL SET @TargetFactoryID = N'';
	IF @TargetProductLineID IS NULL SET @TargetProductLineID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @SourceFactoryID = [dbo].[sx_pf_pProtectID] (@SourceFactoryID);
		SET @SourceProductlineID = [dbo].[sx_pf_pProtectID] (@SourceProductlineID);
		SET @TargetFactoryID = [dbo].[sx_pf_pProtectID] (@TargetFactoryID);
		SET @TargetProductlineID = [dbo].[sx_pf_pProtectID] (@TargetProductlineID);

		IF @SourceFactoryID = N'' OR @SourceProductLineID = N'' OR @TargetFactoryID = N''
			OR @TargetProductlineID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryWriteRight] @TransactUsername, @TargetFactoryID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights on target', 16, 10);
				
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @SourceFactoryID;
		
		IF @ResultCode <> 200
			RAISERROR('Invalid rights on source', 16, 10);
		
		-- STEP 1.2 - Determine SourceKeys	
		SELECT @SourceFactoryKey = FactoryKey, @SourceFactoryNameShort = NameShort FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @SourceFactoryID;
		SELECT @SourceProductLineKey = ProductLineKey, @SourceProductLineNameShort = Nameshort FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @SourceFactoryKey AND ProductlineID = @SourceProductlineID;
		
		IF @SourceFactoryKey = 0 OR @SourceProductLineKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys	
		SELECT @TargetFactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @TargetFactoryID;
		SELECT @TargetProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @TargetFactoryKey AND ProductlineID = @TargetProductlineID;
		
		IF @TargetFactoryKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Target keys don`t exists', 16, 10);
		END;
		
		IF @TargetProductLineKey <> 0		
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target ProductLine key already exists', 16, 10);
		END;
		
		-- STEP 3 - Move data		
		--dProductLine 
		UPDATE [dbo].[sx_pf_dProductLines] 
		SET FactoryKey = @TargetFactoryKey
			, ProductLineID = @TargetProductLineID
			, FactoryID = @TargetFactoryID 
		WHERE ProductLineKey = @SourceProductLineKey;

		SET @EffectedRows += @@ROWCOUNT;

		IF @EffectedRows = 0
		BEGIN 
			SET @ResultCode = 204;
		END		
		ELSE
		BEGIN
			--dProduct
			UPDATE [dbo].[sx_pf_dProducts] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dValueSeries
			UPDATE [dbo].[sx_pf_dValueSeries] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			--dTime
			UPDATE [dbo].[sx_pf_dTime] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			--fValues
			UPDATE [dbo].[sx_pf_fValues] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			--gProductLines
			UPDATE [dbo].[sx_pf_gProductLines] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;
		
			--gProducts 
			UPDATE [dbo].[sx_pf_gProducts] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			--rRights
			UPDATE [dbo].[sx_pf_rRights] 
			SET FactoryID = @TargetFactoryID
				, ProductLineID = @TargetProductLineID
			WHERE FactoryID = @SourceFactoryID 
				AND ProductLineID = @SourceProductLineID;

			SET @EffectedRows += @@ROWCOUNT;

			--rPreferences
			UPDATE [dbo].[sx_pf_rPreferences] 
			SET ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID
				, UserKey = @TransactUserKey
				, UserName = @TransactUsername
			WHERE FactoryID = @SourceFactoryID 
				AND ProductlineID = @SourceProductlineID;

			SET @EffectedRows += @@ROWCOUNT;

			--fStatements
			UPDATE [dbo].[sx_pf_fStatements] 
			SET FactoryKey = @TargetFactoryKey
				, ProductLineID = @TargetProductLineID
				, FactoryID = @TargetFactoryID 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			INSERT INTO [dbo].[sx_pf_fStatements]
			SELECT ProductKey
				, @SourceProductLineKey AS ProductLineKey
				, @TargetFactoryKey AS FactoryKey
				, ProductID
				, @TargetProductlineID AS ProductLineID
				, @TargetFactoryID AS FactoryID
				, N'MOVE' AS ActionType
				, N'ProductLine is moved from Factory <' + @SourceFactoryID + N'>"' + @SourceFactoryNameShort 
					+ N'"/ ProductLine <' + @SourceProductlineID + N'>"' + @SourceProductLineNameShort 
					+ N'"/ Product <' + ProductID + N'>"' + Nameshort +  N'"' AS [Statement]
				, @TransactUsername AS UserName
				, N'' AS PCName
				, N'' AS ProcessorCode
				, N'' AS IPAddresses
				, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5), N':', N'') AS BIGINT) AS [Timestamp]
				, 0 AS IsDeleted
				, 0 AS IsResolved
			FROM [dbo].[sx_pf_dProducts] 
			WHERE ProductLineKey = @SourceProductLineKey;

			SET @EffectedRows += @@ROWCOUNT;

			-- Rights materialization
			EXEC [dbo].[sx_pf_materialize_vUserRights];

		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_ProductLine] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_ProductLine] TO pf_PlanningFactoryService;
GO
/*
Move Operation for one ValueSeries
The ValueSeries will be moved to a new ID, only if this ID is free
Works only inside one Product

Dependencies:
	- Functions: 
		- sx_pf_pProtectID
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineWriteRight
		- sx_pf_pPOST_API_LogEntry

09/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard

Test call
1. Empty  Source or Target  FactoryID / ProductLineID / ProductID / ValueSerieID => 404 Not Found
2. TransactionUsername not determined for User => 403 Forbidden
3. User has no Rights => 401 Unauthorized
4. Not exists Source Factory / Productline / Product / ValueSerie => 404 Not Found
5. Not exists Target  Factory / Productline / Product => 404 Not Found
6. Target ValueSerie key already exists => 403 Forbidden
7. ValueSerie moved => 200 OK
8. Don`t moved anything => 204 No content

DECLARE @RC int
		DECLARE  @Username AS NVARCHAR(255) = 'SQL'
		DECLARE  @FactoryID  AS NVARCHAR(255)='ZT'
		DECLARE  @ProductLineID AS NVARCHAR(255)='U'
		DECLARE  @ProductID AS NVARCHAR(255)='2'
		DECLARE  @SourceValueSerieID  AS NVARCHAR(255)='K1'
		DECLARE  @TargetValueSerieID AS NVARCHAR(255)='K1'

EXECUTE @RC = [sx_pf_MOVE_ValueSerie] 
		   @Username
		  ,@FactoryID
		  ,@ProductLineID
		  ,@ProductID
		  ,@SourceValueSerieID
		  ,@TargetValueSerieID

PRINT @RC
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_MOVE_ValueSerie]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_MOVE_ValueSerie];
GO

CREATE PROCEDURE [dbo].[sx_pf_MOVE_ValueSerie]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@ProductID AS NVARCHAR(255),
	@SourceValueSerieID AS NVARCHAR(255),
	@TargetValueSerieID AS NVARCHAR(255)
AS 

BEGIN
	SET NOCOUNT ON;

	DECLARE @FactoryKey AS INT = 0;
	DECLARE @ProductLineKey AS INT = 0;
	DECLARE @ProductKey AS INT = 0;
	DECLARE @SourceValueSerieKey AS INT = 0;
	DECLARE @TargetValueSerieKey AS INT = 0;

	DECLARE @TransactUsername AS NVARCHAR(255)= N'';
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' +
		 N''',''' + ISNULL(CAST(@SourceValueSerieID AS NVARCHAR(255)), N'NULL') + N''',''' + ISNULL(@TargetValueSerieID, N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = N'';
	IF @FactoryID IS NULL SET @FactoryID = N'';
	IF @ProductLineID IS NULL SET @ProductLineID = N'';
	IF @ProductID IS NULL SET @ProductID = N'';
	IF @SourceValueSerieID IS NULL SET @SourceValueSerieID = N'';
	IF @TargetValueSerieID IS NULL SET @TargetValueSerieID = N'';

	BEGIN TRY
		BEGIN TRANSACTION ONE;

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);
		SET @SourceValueSerieID = [dbo].[sx_pf_pProtectID] (@SourceValueSerieID);
		SET @TargetValueSerieID = [dbo].[sx_pf_pProtectID] (@TargetValueSerieID);

		IF @FactoryID = N'' OR @ProductLineID = N'' OR @ProductID = N'' OR  @SourceValueSerieID = N'' OR  @TargetValueSerieID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		
		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineWriteRight] @TransactUsername, @FactoryID, @ProductLineID;

		IF @ResultCode <> 200
			RAISERROR('Invalid rights', 16, 10);

		-- STEP 1.2 - Determine SourceKeys	
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;
		SELECT @ProductLineKey = ProductLineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey AND ProductlineID = @ProductlineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @ProductlineKey AND ProductID = @ProductID;
		SELECT @SourceValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey  AND ValueSeriesID = @SourceValueSerieID;	
		
		IF @FactoryKey = 0 OR @ProductLineKey = 0 OR @ProductKey = 0 OR  @SourceValueSerieKey = 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Source keys don`t exists', 16, 10);
		END;

		-- STEP 1.3 - Determine TargetKeys	
		SELECT @TargetValueSerieKey = ValueSeriesKey FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey AND ValueSeriesID = @TargetValueSerieID;

		IF @TargetValueSerieKey <> 0
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Target ValueSerie key already exists', 16, 10);
		END;

		-- STEP 3 - Move data
		--dValueSeries 
		UPDATE [dbo].[sx_pf_dValueSeries]
		SET ValueSeriesID = @TargetValueSerieID
		WHERE ValueSeriesKey = @SourceValueSerieKey;
		
		SET @EffectedRows += @@ROWCOUNT;

		IF @EffectedRows = 0
		BEGIN 
			SET @ResultCode = 204;
		END		
		ELSE
		BEGIN			  
			--fValues
			UPDATE [dbo].[sx_pf_fValues] 
			SET ValueSeriesID = @TargetValueSerieID
			WHERE ValueSeriesKey = @SourceValueSerieKey;

			SET @EffectedRows += @@ROWCOUNT;
			SET @ResultCode = IIF(@EffectedRows = 0, 204, 200);
				
			INSERT INTO [dbo].[sx_pf_fStatements]  
			SELECT @ProductKey AS ProductKey
				, @ProductLineKey AS ProductLineKey
				, @FactoryKey AS FactoryKey
				, @ProductID  AS ProductID
				, @ProductlineID  AS ProductLineID
				, @FactoryID  AS FactoryID
				, N'MOVE' AS ActionType
				, N'ValueSeries ' + @SourceValueSerieID + N' was moved to new ID ' + @TargetValueSerieID AS [Statement]
				, @TransactUsername AS UserName
				, N'' AS PCName
				, N'' AS ProcessorCode
				, N'' AS IPAddresses
				, CAST(CONVERT(NVARCHAR(10),GETDATE(),112) AS BIGINT)*10000 + CAST(REPLACE(LEFT(CONVERT(NVARCHAR(10),GETDATE(),108), 5), N':', N'') AS BIGINT) AS [Timestamp]
				, 0 AS IsDeleted
				, 0 AS IsResolved;

			SET @EffectedRows += @@ROWCOUNT;
		END;

		COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_ValueSerie] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_MOVE_ValueSerie] TO pf_PlanningFactoryService;
GO
/*
Determines the User for the Transaction

This function returns:
	A: An active username from the internal DataFactory Usermanagement
	B: The string '403' if no authorized user was found

The function does it by
	1. checking the SQL connected User
	2. checking for FactoryService Action
	3. checking for action over public user 

Don't use the function IS_ROLEMEMBER, its buggy

02/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
NO HTTP Standard - no public call
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_Determine_TransactionUsername]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [sx_pf_Determine_TransactionUsername]
GO

CREATE FUNCTION dbo.sx_pf_Determine_TransactionUsername (@Username AS NVARCHAR(255)='')
RETURNS NVARCHAR (255) 
AS
BEGIN 
	DECLARE @TransactionUsername AS NVARCHAR (255) = '403'; --Default Value

	-- clean and declare
		SET @Username = LTRIM(RTRIM(@Username));
		DECLARE @IsFactoryService INT = 0;
		DECLARE @UserBlocked INT = 0;

	-- 1. Determine if Factory Service is acting (this means a DatabaseUser with the role "pf_PlanningFactoryService")
		IF EXISTS
		(
			SELECT r.name from sys.database_role_members rm 
			INNER JOIN sys.database_principals r on rm.role_principal_id = r.principal_id
			INNER JOIN sys.database_principals m on rm.member_principal_id = m.principal_id
			WHERE r.name = 'pf_PlanningFactoryService' AND m.name = ORIGINAL_LOGIN()
		)
		BEGIN
			SET @IsFactoryService = 1;
		END;

	-- 2. If FactoryService is acting, every Username is accepted, else only the Original_Login()
		IF  @IsFactoryService = 1 
			SET @TransactionUsername = @Username;
		ELSE
			SET @TransactionUsername = ORIGINAL_LOGIN()

	-- 3. Block the user if this user don't exists a an active User
		IF NOT (SELECT Count(Userkey) FROM sx_pf_rUser WHERE Username = @TransactionUsername AND Status = 'Active') = 1
			BEGIN
				SET @TransactionUsername = '403'
				SET	@UserBlocked = 1
			END
	
	-- 4. If the user was blocked, check if a public user exists, which can be used for the transaction
		IF @UserBlocked = 1
			BEGIN
				IF (SELECT Count(Userkey) FROM sx_pf_rUser WHERE Username = 'public' AND Status = 'Active') = 1
					SET @TransactionUsername = 'public'
			END

	RETURN @TransactionUsername
END

GO

/*Testing
Assumtion:
- Database has three SQL User ('W10\admin', 'FactoryService' and 'sx')
- DFU has user 'W10\admin', 'sx' and user 'public'
- User public is Active\Inactive depending of test
- User 'W10\admin' has role db_owner
- User sx has role pf_PlanningFactoryUser
- User FactoryService has role pf_PlanningFactoryService



A: Test as User with role pf_PlanningFactoryUser (SQL User sx)
	A1: User exists in DFU, no public user
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')		-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return 'sx'

	A2: User exists in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')		-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return 'sx'

	A3: User exists not in DFU, no public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')		-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return '403'

	A4: User exists not in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')		-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return 'public'

B: Test as User with role db_owner (SQL User W10\admin)
	B1: User exists in DFU, no public user
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return 'W10\admin'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('W10\admin')-> must return 'W10\admin'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return 'W10\admin'
																					
	B2: User exists in DFU, a public user exists									
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return 'W10\admin'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('W10\admin')		-> must return 'W10\admin'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return 'W10\admin'

	B3: User exists not in DFU, no public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('W10\admin')-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return '403'

	B4: User exists not in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')			-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('W10\admin')-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything') -> must return 'public'


C: Test as User with role pf_PlanningFactoryService (SQL User 'FactoryService') - the User FactoryService don't exits in DFU
	C1: Requested User exists in DFU, no public user
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return '403'

	C2: Requested User exists in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return 'public'

	C3: Requested User exists not in DFU, no public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('FactoryService')	-> must return '403'

	C4: Requested User exists not in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('FactoryService')	-> must return 'public'

D: Test as User with role pf_PlanningFactoryService (SQL User 'FactoryService') - the User FactoryService exits in DFU
	D1: Requested User exists in DFU, no public user
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('FactoryService')	-> must return 'FactoryService'

	D2: Requested User exists in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return 'sx'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('FactoryService')	-> must return 'FactoryService'

	D3: Requested User exists not in DFU, no public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return '403'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return '403'

	D4: Requested User exists not in DFU, a public user exists
		SELECT dbo.sx_pf_Determine_TransactionUsername ('')					-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('sx')				-> must return 'public'
		SELECT dbo.sx_pf_Determine_TransactionUsername ('anything')			-> must return 'public'


*/

-- Procedure for materialization of UserRights
-- Gerd Tautenhahn for saxess software gmbh
-- PlanningFactory 4.0 
-- 12/2016

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_materialize_vUserRights]') AND type in (N'P', N'PC'))
DROP PROCEDURE sx_pf_materialize_vUserRights

GO

CREATE PROCEDURE sx_pf_materialize_vUserRights 
AS 

BEGIN
	BEGIN TRY
		BEGIN TRANSACTION

		
		CREATE TABLE #RightsTemp (
			UserKey INT NOT NULL,
			Username NVARCHAR (255) COLLATE database_default NOT NULL,
			FactoryID  NVARCHAR (255) COLLATE database_default ,
			ProductLineID NVARCHAR (255) COLLATE database_default, 
			[RightExplicit]  NVARCHAR (255) COLLATE database_default,
			[RightImplicit]  NVARCHAR (255) COLLATE database_default,
			ReadCommentMandatory INT,
			WriteCommentMandatory INT
		)

		-- Create all Right combinations and set initial Deny
		INSERT INTO #RightsTemp

			-- ClusterRights
			SELECT  rU.UserKey, rU.UserName, '' AS FactoryID,'' AS ProductlineID,'-' AS [RightExplicit],'Deny' AS [RightImplizit], 0 AS ReadCommentMandatory, 1 AS WriteCommentMandatory FROM sx_pf_rUser rU
			WHERE rU.Status = 'Active'
	
			UNION ALL
			-- FactoryRights
			SELECT  rU.UserKey, rU.UserName, dF.FactoryID, '','-','Deny', 0, 1 FROM sx_pf_rUser rU CROSS JOIN sx_pf_dFactories dF
			WHERE rU.Status = 'Active'

			UNION ALL
			-- ProductLineRights
			SELECT  rU.UserKey, rU.UserName, dPL.FactoryID, dPL.ProductlineID,'-','Deny', 0, 1 FROM sx_pf_rUser rU CROSS JOIN sx_pf_dProductLines dPL
			WHERE rU.Status = 'Active'
	
		--  Set all explicit Rights

		UPDATE rTmp SET rTmp.RightExplicit = rR.[Right], rTmp.WriteCommentMandatory = rR.WriteCommentMandatory, rTmp.ReadCommentMandatory = rR.ReadCommentMandatory 
			FROM #RightsTemp rTmp, sx_pf_rRights rR WHERE 
				rTmp.UserKey = rR.UserKey AND
				rTmp.FactoryID = rR.FactoryID AND
				rTmp.ProductLineID = rR.ProductLineID


		--1. EVALUATE CLUSTERRIGHTS #####################################################################################################################

		-- 1a. CLUSTERWRITE - Implicit downwards Rights on all Elements 
		UPDATE #RightsTemp SET [RightImplicit] = 'Write' 
				WHERE UserKey IN (SELECT UserKey FROM #RightsTemp WHERE FactoryID = '' AND ProductlineID ='' AND [RightExplicit] = 'Write')
		

		-- 1b. CLUSTERREAD - All User with Read Right on a Cluster get Red Rights on all Elements
		UPDATE #RightsTemp SET [RightImplicit] = 'Read' 
				WHERE UserKey IN (SELECT UserKey FROM #RightsTemp WHERE FactoryID = '' AND ProductlineID ='' AND [RightExplicit] = 'Read')


		----2. EVALUATE FACTORY RIGHTS #####################################################################################################################

		-- 2a. Downward Inheritence - All User with Write Rights on a Factory get Write Rights on all Productlines
		UPDATE rTmp1 SET [RightImplicit] = 'Write' FROM #RightsTemp rTmp1, #RightsTemp rTmp2 
				WHERE
					rTmp1.FactoryID = rTmp2.FactoryID AND 
					rTmp1.UserKey = rTmp2.UserKey AND
					rTmp2.RightExplicit = 'Write' AND
					rTmp2.ProductLineID = ''

		-- 2b. Downward Inheritence - All User with Read Rights on a Factory get Read Rights on all Productlines
		UPDATE rTmp1 SET [RightImplicit] = 'Read' FROM #RightsTemp rTmp1, #RightsTemp rTmp2 
				WHERE
					rTmp1.FactoryID = rTmp2.FactoryID AND 
					rTmp1.UserKey = rTmp2.UserKey AND
					rTmp2.RightExplicit = 'Read' AND
					rTmp2.ProductLineID = ''

		-- 2c. Upward Transit - All User with Read/Write Rights on a Factory get Read Rights on cluster
		UPDATE #RightsTemp SET [RightImplicit] = 'Read'
				WHERE
					UserKey IN (SELECT UserKey FROM #RightsTemp WHERE ProductLineID = '' AND [RightExplicit] IN ('Read','Write') GROUP BY UserKey) AND
					FactoryID = '' AND
					ProductLineID = ''
		
		------ EVALUATE PRODUCTLINE RIGHTS #####################################################################################################################
		---- Only Upward Transit

		-- 3a. Upward Transit for Cluster
		UPDATE #RightsTemp SET [RightImplicit] = 'Read'
			WHERE
				UserKey IN (SELECT UserKey FROM #RightsTemp WHERE ProductLineID <> '' AND [RightExplicit] IN ('Read','Write') GROUP BY UserKey) AND
				FactoryID = '' AND
				ProductLineID = ''

		-- 3a. Upward Transit for Factories
		UPDATE rTmp1 SET rTmp1.[RightImplicit] = 'Read' FROM #RightsTemp rTmp1, #RightsTemp rTmp2
			WHERE
				rTmp1.UserKey = rTmp2.UserKey AND
				rTmp1.FactoryID = rTmp2.FactoryID AND
				rTmp2.ProductLineID <>'' AND
				rTmp2.RightExplicit IN ('Read','Write') AND
				rTmp1.ProductLineID = ''

		------ Inherit Mandatory Flags #####################################################################################################################
		-- 4a. Productlines AND Factories inherit from explicit ClusterRights
		UPDATE rTmp1 SET rTmp1.ReadCommentMandatory=rTmp2.ReadCommentMandatory, rTmp1.WriteCommentMandatory = rTmp2.WriteCommentMandatory  FROM #RightsTemp rTmp1, #RightsTemp rTmp2 
			WHERE 
				rTmp1.UserKey = rTmp2.UserKey AND
				rTmp2.ProductLineID = '' AND
				rTmp2.FactoryID = '' AND
				rTmp1.RightExplicit = '-'
	
		-- 4a. Productlines inherit from their Factories
		UPDATE rTmp1 SET rTmp1.ReadCommentMandatory=rTmp2.ReadCommentMandatory, rTmp1.WriteCommentMandatory = rTmp2.WriteCommentMandatory  FROM #RightsTemp rTmp1, #RightsTemp rTmp2 
			WHERE 
				rTmp1.UserKey = rTmp2.UserKey AND
				rTmp1.FactoryID = rTmp2.FactoryID AND
				rTmp2.ProductLineID = '' AND
				rTmp1.RightExplicit = '-'
			
			-- OUTPUT
			-- TRUNCATE TABLE sx_pf_vUserRights -- deactivated, because a 
			/*	The minimum permission required is ALTER on table_name. TRUNCATE TABLE permissions default to the table owner,
				members of the sysadmin fixed server role, and the db_owner and db_ddladmin fixed database roles, 
				and are not transferable. However, you can incorporate the TRUNCATE TABLE statement within a module,
				such as a stored procedure, and grant appropriate permissions to the module using the EXECUTE AS clause.
			
				The EXECUTE AS Clause I did not master till now in foreign environments. 
			 */
			DELETE FROM sx_pf_vUserRights 
			INSERT INTO sx_pf_vUserRights 
			SELECT 
				 UserKey
				,Username
				,FactoryID
				,ProductLineID
				,IIF(RightExplicit ='-',RightImplicit,RightExplicit) AS [Right]
				--,RightExplicit
				--,RightImplicit
				,ReadCommentMandatory
				,WriteCommentMandatory

			FROM #RightsTemp

			COMMIT TRANSACTION
		END TRY
		BEGIN CATCH
			Print 'Da ging was schief'
			ROLLBACK TRANSACTION
		END CATCH
	END
GO

-- Testaufruf
-- EXEC sx_pf_materialize_vUserRights


/*
GET Operation für Read Rechte auf die Clusterproperties
Benötigt schon Transaktionsuser, daher PRIVATE !
Gibt bei positivem Test auf Read Rechte für den angefragten Transaktionsuser Status 200 zurück
Abhängigkeiten:
	- keine
05/2015 für PlanningFactory 4.0
Gerd Tautenhahn für saxess-software gmbh
Rückgabewerte gemäß HTTP Standard
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pGET_ClusterPropertiesReadRight]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_pGET_ClusterPropertiesReadRight]
GO

CREATE PROCEDURE sx_pf_pGET_ClusterPropertiesReadRight @TransactionUsername AS NVARCHAR(255)
AS
		DECLARE @RightCode AS INT = 501 --Im Default not implemented, darf nie zurückgegeben werden
		DECLARE @Right as NVARCHAR (255) = 'none'

		-- 2. testen ob der User auf Active gesetzt ist, jeder User darf die Properties lesen
		SELECT @RightCode=IIF ([Status] = 'Active',0, 401)FROM sx_pf_rUser WHERE Username = @TransactionUsername
			-- falls keine Schreibrechte wird Prozedur abgebrochen
			IF @RightCode <> 0 RETURN 401 
			RETURN 200
GO

		/*Testaufruf
		DECLARE @RESULT AS NVARCHAR(255)
		EXEC @RESULT = sx_pf_pGET_ClusterPropertiesReadRight 'W8\admin'
		PRINT @RESULT
		*/

/*
GET Operation for Write Rights on Cluster
Needs already a Transactionsuser, thats why PRIVATE
Returns for Clusteradmins 200
Dependencies:
	- none
08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pGET_ClusterWriteRight]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_pGET_ClusterWriteRight]
GO

CREATE PROCEDURE sx_pf_pGET_ClusterWriteRight @TransactionUsername AS NVARCHAR(255)
AS
		DECLARE @RightCode AS INT = 501 --not implemented, must be never returned
		DECLARE @Right AS NVARCHAR (255) ='none'

		-- Check for Write Line on cluster
		SELECT @Right=Coalesce([Right],'no') FROM sx_pf_vUserRights WHERE FactoryID = '' AND Username = @TransactionUsername
			-- return 200 only for Clusteradmin
			IF @Right <>'Write' SET @RightCode = 401 
			IF @Right = 'Write' SET @RightCode = 200
			RETURN @RightCode
GO

/*Testcall

-- Clusteradmin must return 200
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pGET_ClusterWriteRight 'W8\admin'
PRINT @RESULT

-- User which exists, but is no Cluster Admin must return 401
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pGET_ClusterWriteRight 'GUEBAU\wenzel'
PRINT @RESULT

-- User which not exists, must return 401
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pGET_ClusterWriteRight 'Dummy\Dummy'
PRINT @RESULT
*/




/*
GET Operation für Read Rechte auf einer Factory
Benötigt schon Transaktionsuser, daher PRIVATE !
Gibt bei positivem Test auf Read Rechte für den angefragten User Status 200 zurück
Abhängigkeiten:
	- keine
07/2015 für PlanningFactory 4.0
Gerd Tautenhahn für saxess-software gmbh
Rückgabewerte gemäß HTTP Standard
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pGET_FactoryReadRight]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_pGET_FactoryReadRight]
GO

CREATE PROCEDURE sx_pf_pGET_FactoryReadRight @TransactionUsername AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)
AS
		DECLARE @RightCode AS INT = 501 --Im Default not implemented, darf nie zurückgegeben werden
		DECLARE @Right as NVARCHAR (255) = 'none'

		-- 1. testen ob der User Schreibrechte für die  Factory besitzt
		SELECT @RightCode=IIF ([Right] = 'Write' OR [Right] = 'Read',0, 401)FROM sx_pf_vUserRights WHERE FactoryID = @FactoryID AND ProductlineID = '' AND Username = @TransactionUsername
			-- falls keine Schreibrechte wird Prozedur abgebrochen
			IF @RightCode <> 0 RETURN 401 
			RETURN 200
GO

		/*Testaufruf
		DECLARE @RESULT AS NVARCHAR(255)
		EXEC @RESULT = sx_pf_pGET_FactoryReadRight 'W8\admin','ZT'
		PRINT @RESULT
		*/

/*
GET Operation für Write Rechte auf einer Factory
Benötigt schon Transaktionsuser
Gibt bei positivem Test auf Write Rechte für den angefragten User Status 200 zurück
Abhängigkeiten:
	- keine
04/2015 für PlanningFactory 4.0
Gerd Tautenhahn für saxess-software gmbh
Rückgabewerte gemäß HTTP Standard
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pGET_FactoryWriteRight]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_pGET_FactoryWriteRight]
GO

CREATE PROCEDURE sx_pf_pGET_FactoryWriteRight @TransactionUsername AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)
AS
		DECLARE @RightCode AS INT = 501 --Im Default not implemented, darf nie zurückgegeben werden
		DECLARE @Right as NVARCHAR (255) = 'none'

		-- 1. testen ob der User Schreibrechte für die  Factory besitzt
		SELECT @RightCode=IIF ([Right] = 'Write',0, 401)FROM sx_pf_vUserRights WHERE FactoryID = @FactoryID AND ProductlineID = '' AND Username = @TransactionUsername
			-- falls keine Schreibrechte wird Prozedur abgebrochen
			IF @RightCode <> 0 RETURN 401 
			RETURN 200

GO

		/*Testaufruf
		DECLARE @RESULT AS NVARCHAR(255)
		EXEC @RESULT = sx_pf_pGET_FactoryWriteRight 'W8\admin','ZT'
		PRINT @RESULT
		*/

/*
GET Operation für Read Rechte auf einer Productline
Benötigt schon Transaktionsuser
Gibt bei positivem Test auf Read Rechte für den angefragten User Status 200 zurück
Abhängigkeiten:
	- keine
04/2015 für PlanningFactory 4.0
Gerd Tautenhahn für saxess-software gmbh
Rückgabewerte gemäß HTTP Standard
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pGET_ProductLineReadRight]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_pGET_ProductLineReadRight]
GO

CREATE PROCEDURE sx_pf_pGET_ProductLineReadRight @TransactionUsername AS NVARCHAR(255), @FactoryID AS NVARCHAR(255), @ProductlineID AS NVARCHAR(255)

AS

		DECLARE @RightCode AS INT = 501 --Im Default not implemented, darf nie zurückgegeben werden
		DECLARE @Right as NVARCHAR (255) = 'none'

		-- 1. testen ob der User Schreibrechte für die  Productline besitzt
		SELECT @RightCode=IIF ([Right] = 'Write' OR [Right] = 'Read',0, 401)FROM sx_pf_vUserRights WHERE FactoryID = @FactoryID AND ProductlineID = @ProductLineID AND Username = @TransactionUsername
			-- falls keine Schreibrechte wird Prozedur abgebrochen
			IF @RightCode <> 0 RETURN 401 
			RETURN 200

GO

		/*Testaufruf
		DECLARE @RESULT AS NVARCHAR(255)
		EXEC @RESULT = sx_pf_pGET_ProductLineReadRight 'W8\adminr','ZT','ZT'
		PRINT @RESULT
		*/

/*
GET Operation for Write Rights on Productline
Needs already a Transactionsuser, thats why PRIVATE
Returns for User with Write Rights 200
Dependencies:
	- none
08/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return Value according to HTTP Standard
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pGET_ProductLineWriteRight]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_pGET_ProductLineWriteRight]
GO

CREATE PROCEDURE sx_pf_pGET_ProductLineWriteRight @TransactionUsername AS NVARCHAR(255), @FactoryID AS NVARCHAR(255), @ProductlineID AS NVARCHAR(255)

AS
		DECLARE @RightCode AS INT = 501 --Im Default not implemented, darf nie zurückgegeben werden
		DECLARE @Right as NVARCHAR (255) = 'none'

		-- 1. testen ob der User Schreibrechte für die  Productline besitzt
		SELECT @Right=Coalesce([Right],'none')FROM sx_pf_vUserRights WHERE FactoryID = @FactoryID AND ProductlineID = @ProductLineID AND Username = @TransactionUsername
			-- falls keine Schreibrechte wird Prozedur abgebrochen
			IF @Right = 'Write' SET @RightCode = 200
			IF @Right <>'Write' SET @RightCode = 401 
			RETURN @RightCode

GO

/*Testcall
-- Clusteradmin must return 200
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pGET_ProductLineWriteRight 'W8\admin','ZT','U'
PRINT @RESULT


-- User which exists, but is no Cluster Admin must return 401
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pGET_ProductLineWriteRight 'GUEBAU\wenzel','ZT','U'
PRINT @RESULT


-- User which not exists, must return 401
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pGET_ProductLineWriteRight 'Dummy\Dummy','ZT','U'
PRINT @RESULT
*/
/*
MOVE rows older than 7 days from [dbo].[sx_pf_API_Log] to [dbo].[sx_pf_API_Log_History] table

Dependencies: No															

12/2016 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return No Value

Test call
EXEC  [dbo].[sx_pf_pPOST_LogArchive]
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pPOST_Archive_Historic_LogEntrys]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_pPOST_Archive_Historic_LogEntrys];
GO

CREATE PROCEDURE [dbo].[sx_pf_pPOST_Archive_Historic_LogEntrys]
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @logKeys AS TABLE ([LogKey] [bigint] NOT NULL);
	DECLARE @Date DATETIME = GETDATE();

	INSERT TOP (500) INTO [dbo].[sx_pf_API_Log_History] (
		[LogKey]
        , [SQLSystemUser]
        , [UserName]
        , [TransactUsername]
        , [ProcedureName]
        , [ParameterString]
        , [EffectedRows]
        , [ReturnCode]
        , [TimestampCall]
        , [TimestampReturn]
        , [Comment]
        , [ProcessCode] 
	)
	OUTPUT inserted.[LogKey] INTO @logKeys([LogKey])
   	SELECT [LogKey]
        , [SQLSystemUser]
        , [UserName]
        , [TransactUsername]
        , [ProcedureName]
        , [ParameterString]
        , [EffectedRows]
        , [ReturnCode]
        , [TimestampCall]
        , [TimestampReturn]
        , [Comment]
        , [ProcessCode]
	FROM [dbo].[sx_pf_API_Log]
	WHERE DATEDIFF(DAY, [TimestampCall], @Date) > 7
	ORDER BY [LogKey]; 
											 
    WHILE @@ROWCOUNT > 0
	BEGIN
		DELETE FROM [dbo].[sx_pf_API_Log] WHERE [LogKey] IN (SELECT [LogKey] FROM @logKeys);
		DELETE FROM @logKeys;

		INSERT TOP (500) INTO [dbo].[sx_pf_API_Log_History] (
			[LogKey]
			, [SQLSystemUser]
			, [UserName]
			, [TransactUsername]
			, [ProcedureName]
			, [ParameterString]
			, [EffectedRows]
			, [ReturnCode]
			, [TimestampCall]
			, [TimestampReturn]
			, [Comment]
			, [ProcessCode] 
		)
		OUTPUT inserted.[LogKey] INTO @logKeys([LogKey])
   		SELECT [LogKey]
			, [SQLSystemUser]
			, [UserName]
			, [TransactUsername]
			, [ProcedureName]
			, [ParameterString]
			, [EffectedRows]
			, [ReturnCode]
			, [TimestampCall]
			, [TimestampReturn]
			, [Comment]
			, [ProcessCode]
		FROM [dbo].[sx_pf_API_Log]
		WHERE DATEDIFF(DAY, [TimestampCall], @Date) > 7
		ORDER BY [LogKey];

	END;
END
GO

/*
Internal POST Operation for one API LogEntry, always caused, when a public procedure is called
Dependencies:
	- none
10/2015 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
ReturnCode according to http standard
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_pPOST_API_LogEntry]') AND type in (N'P', N'PC'))
DROP PROCEDURE sx_pf_pPOST_API_LogEntry
GO

CREATE PROCEDURE sx_pf_pPOST_API_LogEntry 
	 @Username AS NVARCHAR(255)
	,@TransactUsername AS NVARCHAR(255)
	,@ProcedureName AS NVARCHAR(255)
	,@ParameterString AS NVARCHAR (MAX)
	,@EffectedRows AS INT
	,@ReturnCode AS INT
	,@TimestampCall AS Datetime
	,@Comment AS NVARCHAR (2000)

AS

		DECLARE @TimestampReturn AS Datetime = CURRENT_TIMESTAMP
		DECLARE @ProcessCode AS NVARCHAR(255) = ''
		DECLARE @DatabaseIsReadOnly AS INTEGER
	
		SELECT @DatabaseIsReadOnly = is_read_only FROM sys.databases WHERE Name = DB_NAME()
		
		IF NOT @DatabaseIsReadOnly = 1
			BEGIN
				INSERT INTO sx_pf_API_Log VALUES (SYSTEM_USER,@Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ReturnCode,@TimestampCall,@TimestampReturn,@Comment,@ProcessCode)
			END
GO

/*Testaufruf
DECLARE @RESULT AS NVARCHAR(255)
EXEC @RESULT = sx_pf_pPOST_API_LogEntry 'SQL','W8\admin','TestProcedure','ThisAreTheParameter',1,200,'20150731','Comment'
PRINT @RESULT
*/
/* 
EXPORT operation of a single Factory, including
- its properties in gtables
- its global attributes
- its Productline
- its products
- it values
- its dependend lists, which have to be merged in the existing lists during import
- in two styles, one for import as sql script, one for Import over the GUI Import

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pMaskSQL
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_FactoryReadRight
		- sx_pf_pPOST_API_LogEntry

04/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return values according to HTTP standard

Test Call:
Results must be stored in table, as column width is to big for SSMS or SQLCMD

0a. Activate Stepnumber for output in Line 624 around and execute prodecedure
0b. Its difficult to send commands with german Umlaute over cmd, thats why name the database without Umlaute

1. Execute this to store the results in the table
	IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[tmpout_Export]') AND type in (N'U'))
	DROP TABLE [dbo].[tmpout_Export]
	GO
	CREATE TABLE tmpout_Export (
		StepNumber INT,
		Command NVARCHAR(MAX)
		)
	INSERT INTO tmpout_Export
		EXEC sx_pf_EXPORT_Factory 'SQL','AT',1

2. Copy this table Content in a file over a .bat file with this command
	bcp.exe "SELECT Command FROM PlanningFactoryCars.dbo.tmpout_Export ORDER BY StepNumber" queryout import.sql -T -S localhost -n  -e error.log -c -C65001 
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_EXPORT_Factory]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_EXPORT_Factory];
GO

CREATE PROCEDURE [dbo].[sx_pf_EXPORT_Factory]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@OutputForSQLServer INT
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(CAST(@OutputForSQLServer AS NVARCHAR(255)), N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution
	
	-- STEP 0.1 - NULL Protection
	IF @Username			IS NULL SET @Username = N'';
	IF @FactoryID			IS NULL SET @FactoryID = N'';
	IF @OutputForSQLServer	IS NULL SET @OutputForSQLServer = 0;

	BEGIN TRY

		DECLARE @FactoryKey BIGINT = 0;

		-- STEP 0.2 - Protect input parameters
		SET @Username = dbo.sx_pf_pProtectString(@Username);
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID);

		IF @FactoryID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'  
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;		

		-- STEP 1.2 - Determine keys
		SELECT @FactoryKey = FactoryKey FROM [dbo].[sx_pf_dFactories] WHERE FactoryID = @FactoryID;

		IF @FactoryKey = 0 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;	
	
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_FactoryReadRight] @TransactUsername, @FactoryID;
		IF @ResultCode <> 200	
		BEGIN
			SET @ResultCode = 401;
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3.1 - Determine dependend objects
		-- Determine dependend Lists and store in temporary table
		DECLARE @DependendListIDs AS TABLE (ListID NVARCHAR(255));
		
		;WITH lists AS (
			-- MERGE dependend Lists, used in ProductDataTable
			SELECT ValueListID FROM [dbo].[sx_pf_dValueSeries] WHERE FactoryKey = @FactoryKey
			-- MERGE dependend Lists, used in Globalattributes
			UNION ALL SELECT GlobalAttributeSource1 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource2 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource3 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource4 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource5 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource6 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource7 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource8 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource9 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource10 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource11 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource12 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource13 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource14 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource15 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource16 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource17 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource18 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource19 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource20 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource21 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource22 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource23 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource24 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
			UNION ALL SELECT GlobalAttributeSource25 FROM [dbo].[sx_pf_dProductLines] WHERE FactoryKey = @FactoryKey
		)									
		INSERT INTO @DependendListIDs (ListID)
		SELECT DISTINCT ValueListID
		FROM lists;
		 
		-- Declare temporary Table for export results
		DECLARE @ExportTable AS TABLE (StepNumber INT NOT NULL, Command NVARCHAR(MAX));
		
		-- STEP 3.2 - OUTPUT Type for SQL Server ##################################################################################################

		IF @OutputForSQLServer = 1
		BEGIN
			INSERT INTO @ExportTable 
			VALUES (0, N'--CONFIG: Adjust variable names manually to fit your needs !')
			, (0, N'DECLARE @Username NVARCHAR(255) = ''SQL''')
			, (0, N'DECLARE @FactoryID NVARCHAR(255) = ''' + @FactoryID + N'''')
			, (0, N'--This FactoryID will be deleted during import, if it exists. You should be sure !');

			-- DELETE FactoryID if exists
			INSERT INTO @ExportTable 
			VALUES (1000, N'EXEC sx_pf_DELETE_Factory @Username, @FactoryID');
			
			-- POST Factory
			INSERT INTO @ExportTable
				SELECT 1001, N'EXEC sx_pf_POST_Factory @Username, @FactoryID,'''
					+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
					+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''','''
					+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
					+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
					+ [dbo].[sx_pf_pMaskSQL](ResponsiblePerson) + N''',''' 
					+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''''
				 FROM dbo.sx_pf_dFactories dF WHERE dF.FactoryKey = @FactoryKey

			-- POST Productlines
			INSERT INTO @ExportTable 
			SELECT 1002, N'EXEC sx_pf_POST_Productline @Username,''' + ProductLineID + N''', @FactoryID,'''
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ResponsiblePerson) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](DefaultTemplate) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource3) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias3) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource4) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias4) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource5) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias5) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource6) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias6) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource7) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias7) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource8) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias8) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource9) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias9) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource10) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias10) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource13) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias13) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource14) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias14) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource15) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias15) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource16) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias16) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource17) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias17) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource18) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias18) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource19) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias19) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource20) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias20) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource23) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias23) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource24) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias24) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource25) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias25) + N''''
			FROM [dbo].[sx_pf_dProductlines] WHERE FactoryKey = @FactoryKey;
					
			-- POST Products
			INSERT INTO @ExportTable
			SELECT 2000, N'EXEC sx_pf_POST_ProductEmpty @Username,''' + ProductID + N''',''' + ProductLineID + N''', @FactoryID,''' 
				+ TimeType + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ResponsiblePerson) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL]([Status]) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](Template) + N''',''' 
				+ TemplateVersion + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute3) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute4) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute5) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute6) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute7) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute8) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute9) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute10) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute13) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute14) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute15) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute16) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute17) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute18) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute19) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute20) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute23) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute24) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute25) + N''''
			FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey;
					
			-- POST Statements -- statements are not exported

			-- POST all ValueSeries as NewValueSeries
			INSERT INTO @ExportTable 
			SELECT 3000 + ValueSeriesNo
				, 'EXEC sx_pf_POST_ValueSerie @Username,''' + ProductID + ''', ''' + ProductLineID +''', @FactoryID,''' +
				+ ValueSeriesID + N''','''
				+ CAST(ValueSeriesNo AS NVARCHAR (255)) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''','''
				+ CAST([IsNumeric] AS NVARCHAR (255)) + N''','''
				+ CAST(VisibilityLevel AS NVARCHAR (255)) + N''','''
				+ ValueSource + N''','''
				+ ValueListID + N''','''
				+ ValueFormatID + N''','''
				+ Unit + N''','''
				+ CAST(Scale AS NVARCHAR (255)) + N''','''
				+ Effect + N''','''
				+ EffectParameter + N''''
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE  FactoryKey = @FactoryKey; 
				
			-- POST dTime 
			;WITH tms AS (
				SELECT dP.ProductID,dP.ProductLineID
					,(SELECT N'[(' + CAST(t.TimeID AS NVARCHAR(10)) + ',0,0,'''''''')],' -- with DeleteFlag, AddValue,AliasName 
					FROM [dbo].[sx_pf_dTime] t
					WHERE t.ProductKey = dP.ProductKey
					GROUP BY t.TimeID
					ORDER BY t.TimeID
					FOR XML PATH('')) AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.FactoryKey = @FactoryKey 
			)
			INSERT INTO @ExportTable
			SELECT 4000, N'EXEC sx_pf_POST_Timeline @Username, ''' + ProductID + N''',''' + ProductLineID +''', @FactoryID,1,''' + LEFT(vals, LEN(vals) - 1) + N''''
			FROM tms
			WHERE NOT vals IS NULL;

			-- POST ProductDataTableValues
			;WITH tms AS (
				SELECT dP.ProductID,dP.ProductLineID
					,(SELECT N'[(''''' + ValueSeriesID 
							+ N''''',' + CAST(TimeID AS NVARCHAR(255)) 
							+ N',''''' + ValueFormula 
							+ N''''',''''' + CAST(ValueInt AS NVARCHAR(255)) 
							+ N''''',''''' + [dbo].[sx_pf_pMaskSQL](ValueText) 
							+ N''''',''''' + [dbo].[sx_pf_pMaskSQL](ValueComment) + ''''')],' 
					FROM [dbo].[sx_pf_fValues] t
					WHERE t.ProductKey = dP.ProductKey
					FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)') AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.FactoryKey = @FactoryKey 
			)
			INSERT INTO @ExportTable
			SELECT 5000, N'EXEC sx_pf_POST_ProductDataTableValues @Username,''' + ProductID + N''',''' + ProductLineID +''', @FactoryID,0,''' + LEFT(vals, LEN(vals) - 1) + N''''
			FROM tms
			WHERE NOT vals IS NULL;

			-- POST Factory Properties
			INSERT INTO @ExportTable 
			SELECT 6000, N'EXEC sx_pf_POST_FactoryProperty @Username, @FactoryID,''' 
					+ PropertyID + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](PropertyName) + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''', '''
					+ Unit + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''', '''
					+ CAST(ValueInt AS NVARCHAR(255)) + N''', '''
					+ CAST(Scale AS NVARCHAR(255)) + N''', '''
					+ CAST(IsROSystemProperty AS NVARCHAR(255)) + N''', '''
					+ FormatID + N''''
			FROM [dbo].[sx_pf_gFactories]
			WHERE FactoryKey = @FactoryKey; 

			-- POST Productline Properties
			INSERT INTO @ExportTable 
			SELECT 6001, N'EXEC sx_pf_POST_ProductlineProperty @Username,''' + ProductLineID +''', @FactoryID,''' 
					+ PropertyID + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](PropertyName) + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''', '''
					+ Unit + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''', '''
					+ CAST(ValueInt AS NVARCHAR(255)) + N''', '''
					+ CAST(Scale AS NVARCHAR(255)) + N''', '''
					+ CAST(IsROSystemProperty AS NVARCHAR(255)) + N''', '''
					+ FormatID + N''''
			FROM [dbo].[sx_pf_gProductLines]
			WHERE FactoryKey = @FactoryKey; 

							
			-- POST Product Properties
			INSERT INTO @ExportTable 
			SELECT 6002, N'EXEC sx_pf_POST_ProductProperty @Username,''' + ProductID + N''',''' + ProductLineID +''', @FactoryID,''' 
				+ PropertyID + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](PropertyName) + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''', '''
				+ Unit + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''', '''
				+ CAST(ValueInt AS NVARCHAR(255)) + N''', '''
				+ CAST(Scale AS NVARCHAR(255)) + N''', '''
				+ CAST(IsROSystemProperty AS NVARCHAR(255)) + N''', '''
				+ FormatID + N''''
			FROM [dbo].[sx_pf_gProducts]
			WHERE  FactoryKey = @FactoryKey; 
		
			-- Create the lists
			INSERT INTO @ExportTable 
			SELECT 7001, N'EXEC sx_pf_POST_List @Username,'''
				+ ListID + ''','''
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
				+ Datentyp + N''',''' 
				+ Source + N''',''' 
				+ SourceFormula + N''',''' 
				+ FormatID + N''''
			FROM [dbo].[sx_pf_hLists]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
					
			-- Create List Values
			INSERT INTO @ExportTable 
			SELECT 7002, N'EXEC sx_pf_POST_ListValue @Username,0,'''
				+ ListID + N''',' 
				+ CAST(ValueInt AS NVARCHAR(255)) + N',' 
				+ CAST(Scale AS NVARCHAR(255)) + N',''' 
				+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ValueComment) + N''',''' 
				+ FormatID + N''''
			FROM [dbo].[sx_pf_hListValues]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
						   
			-- Create Formats
			;WITH DependendFormats AS (
				SELECT FormatID
				FROM [dbo].[sx_pf_hListValues] 
				WHERE ListID IN (SELECT ListID FROM @DependendListIDs)
				UNION ALL SELECT ValueFormatID FROM [dbo].[sx_pf_dValueSeries] WHERE FactoryKey = @FactoryKey
			) 
			INSERT INTO @ExportTable 
			SELECT 7003, N'EXEC sx_pf_POST_Format @Username,'''
				+ FormatID + N''','''
				+ BackgroundColor + N''',''' 
				+ FontColor + N''',''' 
				+ ValueFormat + N''''
			FROM [dbo].[sx_pf_hFormats]
			WHERE FormatID IN (SELECT DISTINCT FormatID FROM DependendFormats);
					
			INSERT INTO @ExportTable
			VALUES (8000, N'GO');

		END -- of Output for SQL Server
		
	-- STEP 3.3 - OUTPUT Type for PF Client Execution ##################################################################################################
		ELSE IF @OutputForSQLServer = 0
		BEGIN
			DECLARE @spr CHAR = CHAR(31); 

			INSERT INTO @ExportTable 
			VALUES (0, N'--CONFIG: Adjust variable names manually to fit your needs !')
			, (0, N'--DECLARE #Username NVARCHAR(255) = ''SQL''')
			, (0, N'--DECLARE #FactoryID NVARCHAR(255) = ''' + @FactoryID + N'''')
			, (0, N'--This FactoryID will be deleted during import, if it exists. You should be sure !');

		
			-- DELETE Factory if exists
			INSERT INTO @ExportTable 
			VALUES (1000, N'sx_pf_DELETE_Factory' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@FactoryID' + @spr + N'#FactoryID');

			-- POST Factory
			INSERT INTO @ExportTable 
			SELECT 1001, N'sx_pf_POST_Factory' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@FactoryID' + @spr + N'#FactoryID'
				+ N'' + @spr + N'@NameShort' + @spr + N'' + NameShort 
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong  
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser  
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev  
				+ N'' + @spr + N'@ResponsiblePerson' + @spr + N'' + ResponsiblePerson  
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName  
			FROM dbo.sx_pf_dFactories dF WHERE dF.FactoryKey = @FactoryKey
						
			-- POST Productlines
			INSERT INTO @ExportTable 
			SELECT 1002, N'sx_pf_POST_Productline' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@ProductlineID' + @spr + N'' + ProductlineID + @spr + N'@FactoryID' + @spr + N'#FactoryID'
				+ N'' + @spr + N'@NameShort' + @spr + N'' + NameShort 
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong  
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser  
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev  
				+ N'' + @spr + N'@ResponsiblePerson' + @spr + N'' + ResponsiblePerson  
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName  
				+ N'' + @spr + N'@DefaultTemplate' + @spr + N'' + DefaultTemplate  
				+ N'' + @spr + N'@GlobalAttributeSource1' + @spr + N'' + GlobalAttributeSource1  
				+ N'' + @spr + N'@GlobalAttributeAlias1' + @spr + N'' + GlobalAttributeAlias1  
				+ N'' + @spr + N'@GlobalAttributeSource2' + @spr + N'' + GlobalAttributeSource2  
				+ N'' + @spr + N'@GlobalAttributeAlias2' + @spr + N'' + GlobalAttributeAlias2  
				+ N'' + @spr + N'@GlobalAttributeSource3' + @spr + N'' + GlobalAttributeSource3  
				+ N'' + @spr + N'@GlobalAttributeAlias3' + @spr + N'' + GlobalAttributeAlias3 
				+ N'' + @spr + N'@GlobalAttributeSource4' + @spr + N'' + GlobalAttributeSource4  
				+ N'' + @spr + N'@GlobalAttributeAlias4' + @spr + N'' + GlobalAttributeAlias4 
				+ N'' + @spr + N'@GlobalAttributeSource5' + @spr + N'' + GlobalAttributeSource5  
				+ N'' + @spr + N'@GlobalAttributeAlias5' + @spr + N'' + GlobalAttributeAlias5 
				+ N'' + @spr + N'@GlobalAttributeSource6' + @spr + N'' + GlobalAttributeSource6  
				+ N'' + @spr + N'@GlobalAttributeAlias6' + @spr + N'' + GlobalAttributeAlias6 
				+ N'' + @spr + N'@GlobalAttributeSource7' + @spr + N'' + GlobalAttributeSource7  
				+ N'' + @spr + N'@GlobalAttributeAlias7' + @spr + N'' + GlobalAttributeAlias7 
				+ N'' + @spr + N'@GlobalAttributeSource8' + @spr + N'' + GlobalAttributeSource8  
				+ N'' + @spr + N'@GlobalAttributeAlias8' + @spr + N'' + GlobalAttributeAlias8 
				+ N'' + @spr + N'@GlobalAttributeSource9' + @spr + N'' + GlobalAttributeSource9  
				+ N'' + @spr + N'@GlobalAttributeAlias9' + @spr + N'' + GlobalAttributeAlias9 
				+ N'' + @spr + N'@GlobalAttributeSource10' + @spr + N'' + GlobalAttributeSource10  
				+ N'' + @spr + N'@GlobalAttributeAlias10' + @spr + N'' + GlobalAttributeAlias10 
				+ N'' + @spr + N'@GlobalAttributeSource11' + @spr + N'' + GlobalAttributeSource11  
				+ N'' + @spr + N'@GlobalAttributeAlias11' + @spr + N'' + GlobalAttributeAlias11  
				+ N'' + @spr + N'@GlobalAttributeSource12' + @spr + N'' + GlobalAttributeSource12  
				+ N'' + @spr + N'@GlobalAttributeAlias12' + @spr + N'' + GlobalAttributeAlias12  
				+ N'' + @spr + N'@GlobalAttributeSource13' + @spr + N'' + GlobalAttributeSource13  
				+ N'' + @spr + N'@GlobalAttributeAlias13' + @spr + N'' + GlobalAttributeAlias13 
				+ N'' + @spr + N'@GlobalAttributeSource14' + @spr + N'' + GlobalAttributeSource14  
				+ N'' + @spr + N'@GlobalAttributeAlias14' + @spr + N'' + GlobalAttributeAlias14 
				+ N'' + @spr + N'@GlobalAttributeSource15' + @spr + N'' + GlobalAttributeSource15  
				+ N'' + @spr + N'@GlobalAttributeAlias15' + @spr + N'' + GlobalAttributeAlias15 
				+ N'' + @spr + N'@GlobalAttributeSource16' + @spr + N'' + GlobalAttributeSource16  
				+ N'' + @spr + N'@GlobalAttributeAlias16' + @spr + N'' + GlobalAttributeAlias16 
				+ N'' + @spr + N'@GlobalAttributeSource17' + @spr + N'' + GlobalAttributeSource17  
				+ N'' + @spr + N'@GlobalAttributeAlias17' + @spr + N'' + GlobalAttributeAlias17 
				+ N'' + @spr + N'@GlobalAttributeSource18' + @spr + N'' + GlobalAttributeSource18  
				+ N'' + @spr + N'@GlobalAttributeAlias18' + @spr + N'' + GlobalAttributeAlias18 
				+ N'' + @spr + N'@GlobalAttributeSource19' + @spr + N'' + GlobalAttributeSource19  
				+ N'' + @spr + N'@GlobalAttributeAlias19' + @spr + N'' + GlobalAttributeAlias19 
				+ N'' + @spr + N'@GlobalAttributeSource20' + @spr + N'' + GlobalAttributeSource20  
				+ N'' + @spr + N'@GlobalAttributeAlias20' + @spr + N'' + GlobalAttributeAlias20 
				+ N'' + @spr + N'@GlobalAttributeSource21' + @spr + N'' + GlobalAttributeSource21  
				+ N'' + @spr + N'@GlobalAttributeAlias21' + @spr + N'' + GlobalAttributeAlias21  
				+ N'' + @spr + N'@GlobalAttributeSource22' + @spr + N'' + GlobalAttributeSource22  
				+ N'' + @spr + N'@GlobalAttributeAlias22' + @spr + N'' + GlobalAttributeAlias22  
				+ N'' + @spr + N'@GlobalAttributeSource23' + @spr + N'' + GlobalAttributeSource23  
				+ N'' + @spr + N'@GlobalAttributeAlias23' + @spr + N'' + GlobalAttributeAlias23 
				+ N'' + @spr + N'@GlobalAttributeSource24' + @spr + N'' + GlobalAttributeSource24  
				+ N'' + @spr + N'@GlobalAttributeAlias24' + @spr + N'' + GlobalAttributeAlias24 
				+ N'' + @spr + N'@GlobalAttributeSource25' + @spr + N'' + GlobalAttributeSource25  
				+ N'' + @spr + N'@GlobalAttributeAlias25' + @spr + N'' + GlobalAttributeAlias25 + N''
			FROM [dbo].[sx_pf_dProductlines] WHERE FactoryKey = @FactoryKey;
					
			-- POST Products
			INSERT INTO @ExportTable
			SELECT 2000, N'sx_pf_POST_ProductEmpty' 
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ @spr + N'@ProductLineID' + @spr + N'' + ProductLineID
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@TimeType' + @spr + N'' + TimeType
				+ N'' + @spr + N'@NameShort' + @spr + N'' +	NameShort
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@ResponsiblePerson' + @spr + N'' + ResponsiblePerson
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName
				+ N'' + @spr + N'@Status' + @spr + N'' + [Status] 
				+ N'' + @spr + N'@Template' + @spr + N'' + Template 
				+ N'' + @spr + N'@TemplateVersion' + @spr + N'' + TemplateVersion
				+ N'' + @spr + N'@GA1' + @spr + N'' + GlobalAttribute1
				+ N'' + @spr + N'@GA2' + @spr + N'' + GlobalAttribute2
				+ N'' + @spr + N'@GA3' + @spr + N'' + GlobalAttribute3
				+ N'' + @spr + N'@GA4' + @spr + N'' + GlobalAttribute4
				+ N'' + @spr + N'@GA5' + @spr + N'' + GlobalAttribute5
				+ N'' + @spr + N'@GA6' + @spr + N'' + GlobalAttribute6
				+ N'' + @spr + N'@GA7' + @spr + N'' + GlobalAttribute7
				+ N'' + @spr + N'@GA8' + @spr + N'' + GlobalAttribute8
				+ N'' + @spr + N'@GA9' + @spr + N'' + GlobalAttribute9
				+ N'' + @spr + N'@GA10' + @spr + N'' + GlobalAttribute10 
				+ N'' + @spr + N'@GA11' + @spr + N'' + GlobalAttribute11
				+ N'' + @spr + N'@GA12' + @spr + N'' + GlobalAttribute12
				+ N'' + @spr + N'@GA13' + @spr + N'' + GlobalAttribute13
				+ N'' + @spr + N'@GA14' + @spr + N'' + GlobalAttribute14
				+ N'' + @spr + N'@GA15' + @spr + N'' + GlobalAttribute15
				+ N'' + @spr + N'@GA16' + @spr + N'' + GlobalAttribute16
				+ N'' + @spr + N'@GA17' + @spr + N'' + GlobalAttribute17
				+ N'' + @spr + N'@GA18' + @spr + N'' + GlobalAttribute18
				+ N'' + @spr + N'@GA19' + @spr + N'' + GlobalAttribute19
				+ N'' + @spr + N'@GA20' + @spr + N'' + GlobalAttribute20
				+ N'' + @spr + N'@GA21' + @spr + N'' + GlobalAttribute21
				+ N'' + @spr + N'@GA22' + @spr + N'' + GlobalAttribute22
				+ N'' + @spr + N'@GA23' + @spr + N'' + GlobalAttribute23
				+ N'' + @spr + N'@GA24' + @spr + N'' + GlobalAttribute24
				+ N'' + @spr + N'@GA25' + @spr + N'' + GlobalAttribute25 + N''
			FROM [dbo].[sx_pf_dProducts] WHERE FactoryKey = @FactoryKey; 
									
			-- POST Statements -- statements are not exported

			-- POST all ValueSeries as NewValueSeries
			INSERT INTO @ExportTable 
			SELECT 3000 + ValueSeriesNo
				, 'sx_pf_POST_ValueSerie'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ @spr + N'@ProductLineID' + @spr + N'' + ProductLineID
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@ValueSeriesID' + @spr + N'' + ValueSeriesID 
				+ N'' + @spr + N'@RequestedValueSeriesNo' + @spr + N'' + CAST(ValueSeriesNo AS NVARCHAR (255))
				+ N'' + @spr + N'@NameShort' + @spr + N'' + NameShort
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName
				+ N'' + @spr + N'@IsNumeric' + @spr + N'' + CAST([IsNumeric] AS NVARCHAR (255))
				+ N'' + @spr + N'@VisibilityLevel' + @spr + N'' + CAST(VisibilityLevel AS NVARCHAR (255))
				+ N'' + @spr + N'@ValueSource' + @spr + N'' + ValueSource
				+ N'' + @spr + N'@ValueListID' + @spr + N'' + ValueListID
				+ N'' + @spr + N'@ValueFormatID' + @spr + N'' + ValueFormatID
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR (255))
				+ N'' + @spr + N'@Effect' + @spr + N'' + Effect
				+ N'' + @spr + N'@EffectParameter' + @spr + N'' + EffectParameter + N''
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE  FactoryKey = @FactoryKey; 

			-- POST dTime 
			;WITH tms AS (
				SELECT dP.ProductID,dP.ProductLineID
					,(SELECT N'[(' + CAST(t.TimeID AS NVARCHAR(10))+',0,0,'''')],' -- with DeleteFlag, AddValue,AliasName 
					FROM [dbo].[sx_pf_dTime] t
					WHERE t.ProductKey = dP.ProductKey
					GROUP BY t.TimeID
					ORDER BY t.TimeID
					FOR XML PATH('')) AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.FactoryKey = @FactoryKey 
			)
			INSERT INTO @ExportTable
			SELECT 4000, N'sx_pf_POST_Timeline'
				+ N'' + @spr + N'@Username' + @spr + N'#Username' 
				+ N'' + @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ N'' + @spr + N'@ProductLineID' + @spr + N'' + ProductLineID
				+ N'' + @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@IsIncrementalValuesFlag' + @spr + N'1' + N''
				+ N'' + @spr + N'@TimeIDsInBracketsCommaSeparated' + @spr + N'' + LEFT(vals, LEN(vals) - 1) + N''
			FROM tms
			WHERE NOT vals IS NULL;		
			
			-- POST ProductDataTableValues
			;WITH tms AS (
				SELECT dP.ProductID, dP.ProductLineID
					,(SELECT N'[(''' + ValueSeriesID 
							+ N''',' + CAST(TimeID AS NVARCHAR(255)) 
							+ N',''' + ValueFormula 
							+ N''',''' + CAST(ValueInt AS NVARCHAR(255)) 
							+ N''',''' + ValueText 
							+ N''',''' + ValueComment + ''')],' 
					FROM [dbo].[sx_pf_fValues] t
					WHERE t.ProductKey = dP.ProductKey
					ORDER BY t.ValueSeriesID, t.TimeID
					FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)') AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.FactoryKey = @FactoryKey 
			)
			INSERT INTO @ExportTable
			SELECT 5000, N'sx_pf_POST_ProductDataTableValues'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ N'' + @spr + N'@ProductLineID' + @spr + N'' + ProductLineID 
				+ N'' + @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@IsIncrementalValuesFlag' + @spr + N'0' + N''
				+ N'' + @spr + N'@ValuesInBracketsCommaSeparated' + @spr + N'' + LEFT(vals, LEN(vals) - 1) + N''
			FROM tms
			WHERE NOT vals IS NULL;
			
			-- POST Factory Properties
			INSERT INTO @ExportTable 
			SELECT 6000, N'sx_pf_POST_FactoryProperty'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID'  
				+ N'' + @spr + N'@PropertyID' + @spr + N'' + PropertyID 
				+ N'' + @spr + N'@PropertyName' + @spr + N'' + PropertyName
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@ValueText' + @spr + N'' + ValueText
				+ N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255))
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@IsROSystemProperty' + @spr + N'' + CAST(IsROSystemProperty AS NVARCHAR(255))
				+ N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_gFactories] 
			WHERE FactoryKey = @FactoryKey; 

			-- POST Productline Properties
			INSERT INTO @ExportTable 
			SELECT 6001, N'sx_pf_POST_ProductlineProperty'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductLineID' + @spr + N'' + ProductLineID 
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID'  
				+ N'' + @spr + N'@PropertyID' + @spr + N'' + PropertyID 
				+ N'' + @spr + N'@PropertyName' + @spr + N'' + PropertyName
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@ValueText' + @spr + N'' + ValueText
				+ N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255))
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@IsROSystemProperty' + @spr + N'' + CAST(IsROSystemProperty AS NVARCHAR(255))
				+ N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_gProductLines]
			WHERE FactoryKey = @FactoryKey; 

			-- POST Product Properties
			INSERT INTO @ExportTable 
			SELECT 6003, N'sx_pf_POST_ProductProperty'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ @spr + N'@ProductLineID' + @spr + N'' + ProductLineID
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@PropertyID' + @spr + N'' + PropertyID
				+ N'' + @spr + N'@PropertyName' + @spr + N'' + PropertyName
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@ValueText' + @spr + N'' + ValueText
				+ N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255)) 
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@IsROSystemProperty' + @spr + N'' + CAST(IsROSystemProperty AS NVARCHAR(255)) 
				+ N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_gProducts]
			WHERE  FactoryKey = @FactoryKey;
		
			-- Create the lists
			INSERT INTO @ExportTable 
			SELECT 7001, N'sx_pf_POST_List'
				+ @spr + N'@Username' + @spr + N'#Username'
				+ N'' + @spr + N'@ListID' + @spr + ListID 
				+ N'' + @spr + N'@NameShort' + @spr + NameShort
				+ N'' + @spr + N'@NameLong' + @spr + NameLong
				+ N'' + @spr + N'@CommentDev' + @spr + CommentDev
				+ N'' + @spr + N'@CommentUser' + @spr + CommentUser
				+ N'' + @spr + N'@Datentyp' + @spr + Datentyp
				+ N'' + @spr + N'@Source' + @spr + [Source]
				+ N'' + @spr + N'@SourceFormula' + @spr + SourceFormula
				+ N'' + @spr + N'@FormatID' + @spr + FormatID + N''
			FROM [dbo].[sx_pf_hLists]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
					
			-- Create List Values
			INSERT INTO @ExportTable 
			SELECT 7002, N'sx_pf_POST_ListValue'
				+ @spr + N'@Username' + @spr + N'#Username'
				+ @spr + N'@ListValuekey' + @spr + N'' + N'0'
				+ N'' + @spr + N'@ListID' + @spr + ListID
				+ N'' + @spr + N'@ValueInt' + @spr + CAST(ValueInt AS NVARCHAR(255))
				+ N'' + @spr + N'@Scale' + @spr + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@ValueText' + @spr + ValueText
				+ N'' + @spr + N'@ValueComment' + @spr + ValueComment
				+ N'' + @spr + N'@FormatID' + @spr + FormatID + N''
			FROM [dbo].[sx_pf_hListValues]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
						   
			-- Create Formats
			;WITH DependendFormats AS (
				SELECT FormatID
				FROM [dbo].[sx_pf_hListValues] 
				WHERE ListID IN (SELECT ListID FROM @DependendListIDs)
				UNION ALL SELECT ValueFormatID FROM [dbo].[sx_pf_dValueSeries] WHERE FactoryKey = @FactoryKey
			) 
			INSERT INTO @ExportTable 
			SELECT 7003, N'sx_pf_POST_Format'
				+ @spr + N'@Username' + @spr + N'#Username'
				+ N'' + @spr + N'@FormatID' + @spr + FormatID
				+ N'' + @spr + N'@BackgroundColor' + @spr + BackgroundColor
				+ N'' + @spr + N'@FontColor' + @spr + FontColor
				+ N'' + @spr + N'@ValueFormat' + @spr + ValueFormat + N''
			FROM [dbo].[sx_pf_hFormats]
			WHERE FormatID IN (SELECT DISTINCT FormatID FROM DependendFormats);

		END; -- Output for PF Client	
	
		-- STEP 3.4 - Final Value Output ###################################################################################################################
		SELECT 
			--StepNumber, --activate only for bcp test output
			Command 
		FROM @ExportTable 
		ORDER BY StepNumber;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = 200;

	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_EXPORT_Factory] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_EXPORT_Factory] TO pf_PlanningFactoryService;
GO



	
/* Procedure to export one single product, including
- it values
- its dependend lists, which have to be merged in the existing lists during import
- in two styles, one for import as sql script, one for Import over the GUI Import

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pMaskSQL
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

04/2017 for DataFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return values according to HTTP standard

TestCall
DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = 'ZT'
DECLARE @ProductLineID nvarchar(255) = 'BFW'
DECLARE @ProductID nvarchar(255) = '10'
DECLARE @OutputForSQLServer INT = 0

EXECUTE @RC = [dbo].[sx_pf_EXPORT_Product] 
   @Username
  ,@FactoryID
  ,@ProductLineID
  ,@ProductID
  ,@OutputForSQLServer

 PRINT @RC
 */

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_EXPORT_Product]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_EXPORT_Product]
GO

CREATE  PROCEDURE [sx_pf_EXPORT_Product]
		@Username AS NVARCHAR(255),
		@FactoryID AS NVARCHAR(255),
		@ProductLineID AS NVARCHAR(255),
		@ProductID AS NVARCHAR(255),
		@OutputForSQLServer INT
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(@ProductID, N'NULL') + N''',''' + ISNULL(CAST(@OutputForSQLServer AS NVARCHAR(255)), N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution
	
	-- STEP 0.1 - NULL Protection
	IF @Username			IS NULL SET @Username = N'';
	IF @FactoryID			IS NULL SET @FactoryID = N'';
	IF @ProductLineID		IS NULL SET @ProductLineID = N'';
	IF @ProductID			IS NULL SET @ProductID = N'';
	IF @OutputForSQLServer	IS NULL SET @OutputForSQLServer = 0;

	BEGIN TRY

		DECLARE @ProductKey BIGINT = 0;
		DECLARE @ProductLineKey BIGINT = 0;
		DECLARE @Template NVARCHAR (255) = '';

		-- STEP 0.2 - Protect input parameters
		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);
		SET @FactoryID = [dbo].[sx_pf_pProtectID] (@FactoryID);
		SET @ProductLineID = [dbo].[sx_pf_pProtectID] (@ProductLineID);
		SET @ProductID = [dbo].[sx_pf_pProtectID] (@ProductID);

		IF @FactoryID = N'' OR @ProductLineID = N''  OR @ProductID = N''	
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'  
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;		

		-- STEP 1.2 - Determine keys
		SELECT @ProductlineKey = ProductlineKey FROM [dbo].[sx_pf_dProductLines] dPL WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID;
		SELECT @ProductKey = ProductKey FROM [dbo].[sx_pf_dProducts] WHERE ProductLineKey = @ProductLineKey AND ProductID = @ProductID;

		IF @ProductKey = 0 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;	
	 
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;
		IF @ResultCode <> 200	
		BEGIN
			SET @ResultCode = 401;
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3.1 - Determine dependend objects
		-- Determine Template
		SELECT @Template = Template FROM sx_pf_dProducts WHERE ProductKey = @ProductKey;

		-- Deterime all Productlines using this Template
		DECLARE @DependendProductLinesIDs AS TABLE (ProductlineKey BIGINT);
		INSERT INTO @DependendProductLinesIDs (ProductlineKey)
			SELECT DISTINCT ProductlineKey FROM sx_pf_dProducts WHERE Template = @Template;

		-- Determine dependend Lists and store in temporary table
		DECLARE @DependendListIDs AS TABLE (ListID NVARCHAR(255));
		
		;WITH lists AS (
			-- MERGE dependend Lists, used in ProductDataTable
			SELECT ValueListID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey
			-- MERGE dependend Lists, used in Globalattributes
			UNION ALL SELECT DISTINCT GlobalAttributeSource1 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource2 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource3 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource4 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource5 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource6 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource7 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource8 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource9 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource10 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource11 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource12 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource13 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource14 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource15 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource16 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource17 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource18 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource19 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource20 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource21 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource22 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource23 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource24 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
			UNION ALL SELECT DISTINCT GlobalAttributeSource25 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey IN (SELECT ProductLineKey FROM @DependendProductLinesIDs)
		)									
		INSERT INTO @DependendListIDs (ListID)
			SELECT DISTINCT ValueListID
			FROM lists
			WHERE ValueListID != '';
		 
		-- Declare temporary Table for export results
		DECLARE @ExportTable AS TABLE (StepNumber INT NOT NULL, Command NVARCHAR(MAX));
		
		-- STEP 3.2 - OUTPUT Type for SQL Server ##################################################################################################
	   	IF @OutputForSQLServer = 1
		BEGIN
			INSERT INTO @ExportTable 
			VALUES (0, N'--CONFIG: Adjust variable names manually to fit your needs !')
			, (0, N'DECLARE @Username NVARCHAR(255) = ''SQL''')
			, (0, N'DECLARE @FactoryID NVARCHAR(255) = ''' + @FactoryID + N'''')
			, (0, N'DECLARE @ProductLineID  NVARCHAR(255) = ''' + @ProductLineID + N'''')
			, (0, N'DECLARE @ProductID  NVARCHAR(255) = ''' + @ProductID + N'''')
			, (0, N'--This ProductID will be deleted during import, if it exists. You should be sure !');

			-- DELETE Product if exists
			INSERT INTO @ExportTable 
			VALUES (1000, N'EXEC sx_pf_DELETE_Product @Username, @FactoryID, @ProductLineID, @ProductID');
			
			-- POST Product
			INSERT INTO @ExportTable 
			SELECT 2000, N'EXEC sx_pf_POST_ProductEmpty @Username, @ProductID, @ProductLineID, @FactoryID,''' + 
				+ TimeType + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (NameShort) + ''','''
				+ [dbo].[sx_pf_pMaskSQL] (NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (CommentDev) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (ResponsiblePerson) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (ImageName) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] ([Status]) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (Template) + N''',''' 
				+ TemplateVersion + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute3) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute4) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute5) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute6) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute7) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute8) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute9) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute10) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute13) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute14) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute15) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute16) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute17) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute18) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute19) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute20) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute23) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute24) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (GlobalAttribute25) + N''''
			FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @ProductKey;

			-- POST Product Properties
			INSERT INTO @ExportTable 
			SELECT 3000, N'EXEC sx_pf_POST_ProductProperty @Username, @ProductID, @ProductLineID, @FactoryID,''' +
				+ PropertyID + N''', '''
				+ [dbo].[sx_pf_pMaskSQL] (PropertyName) + N''', '''
				+ [dbo].[sx_pf_pMaskSQL] (CommentUser) + N''', '''
				+ [dbo].[sx_pf_pMaskSQL] (CommentDev) + N''', '''
				+ Unit + N''', '''
				+ [dbo].[sx_pf_pMaskSQL] (ValueText) + N''', '''
				+ CAST(ValueInt AS NVARCHAR(255)) + N''', '''
				+ CAST(Scale AS NVARCHAR(255)) + N''', '''
				+ CAST(IsROSystemProperty AS NVARCHAR(255)) + N''', '''
				+ FormatID + N''''
			FROM [dbo].[sx_pf_gProducts]
			WHERE  ProductKey = @ProductKey; 

			-- POST Statements -- statements are not exported

			-- POST all ValueSeries as NewValueSeries
			INSERT INTO @ExportTable
			SELECT 4000 + ValueSeriesNo, N'EXEC sx_pf_POST_ValueSerie @Username, @ProductID, @ProductLineID, @FactoryID,''' +
				+ ValueSeriesID + N''',''' 
				+ CAST(ValueSeriesNo AS NVARCHAR (255)) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (NameShort) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (CommentDev) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (ImageName) + N''',''' 
				+ CAST([IsNumeric] AS NVARCHAR (255)) + N''',''' 
				+ CAST(VisibilityLevel AS NVARCHAR (255)) + N''',''' 
				+ ValueSource + N''',''' 
				+ ValueListID + N''',''' 
				+ ValueFormatID + N''',''' 
				+ Unit + N''',''' 
				+ CAST(Scale AS NVARCHAR (255)) + N''',''' 
				+ Effect + N''',''' 
				+ EffectParameter + N''''
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE ProductKey = @ProductKey; 
		   
			;WITH tms AS (
				SELECT (SELECT N'[(' + CAST(TimeID AS NVARCHAR(10)) + ',0,0,'''''''')],'
				FROM [dbo].[sx_pf_dTime]
				WHERE  ProductKey = @ProductKey
				GROUP BY TimeID
				ORDER BY TimeID
				FOR XML PATH('')) AS val 
			)
			INSERT INTO @ExportTable
			SELECT 5000, N'EXEC sx_pf_POST_Timeline @Username, @ProductID, @ProductLineID, @FactoryID,1,''' + LEFT(val, LEN(val) - 1) + N''''
			FROM tms
			WHERE NOT val IS NULL;
				  
			-- POST ProductDataTableValues
			;WITH vals AS (
				SELECT (SELECT  N'[(''''' 
					+ fV.ValueSeriesID + N''''','  
					+ CAST(fV.TimeID AS NVARCHAR(255))+ N',''''' 
					+ fV.ValueFormula + N''''',''''' 
					+ CAST(fV.ValueInt AS NVARCHAR(255)) + N''''',''''' 
					+ [dbo].[sx_pf_pMaskSQL] (fV.ValueText) + N''''',''''' 
					+ [dbo].[sx_pf_pMaskSQL] (fV.ValueComment) + N''''')],'
				FROM [dbo].[sx_pf_fValues] fV LEFT JOIN [dbo].[sx_pf_dValueSeries] dVS 
					ON fV.ValueSeriesKey = dVS.ValueSeriesKey
				WHERE fV.ProductKey = @ProductKey 
				ORDER BY dVS.ValueSeriesNo
				FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)') AS val 
			)
			INSERT INTO @ExportTable
			SELECT 6000, N'EXEC sx_pf_POST_ProductDataTableValues @Username, @ProductID, @ProductLineID, @FactoryID,0,'''
					+ LEFT(val, LEN(val) - 1) + N'''' 
			FROM vals
			WHERE NOT val IS NULL;		

			-- Create the lists
			INSERT INTO @ExportTable 
			SELECT 7001, N'EXECUTE sx_pf_POST_List @Username,'''
				+ ListID + N''','''
				+ [dbo].[sx_pf_pMaskSQL] (NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL] (NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (CommentDev) + N''',''' 
				+ Datentyp + N''',''' 
				+ Source + N''',''' 
				+ SourceFormula + N''',''' 
				+ FormatID + N''''
			FROM [dbo].[sx_pf_hLists]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);

			-- Create List Values
			INSERT INTO @ExportTable 
			SELECT 7002, N'EXECUTE sx_pf_POST_ListValue @Username,0,'''
				+ ListID + N''',' 
				+ CAST(ValueInt AS NVARCHAR(255)) + N',' 
				+ CAST(Scale AS NVARCHAR(255)) + N',''' 
				+ [dbo].[sx_pf_pMaskSQL] (ValueText) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL] (ValueComment) + N''',''' 
				+ FormatID + N''''
		   	FROM [dbo].[sx_pf_hListValues]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
			
			;WITH DependendFormats AS (
				SELECT FormatID
				FROM [dbo].[sx_pf_hListValues] 
				WHERE ListID IN (SELECT ListID FROM @DependendListIDs)
				UNION ALL SELECT ValueFormatID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey
			) 
			INSERT INTO @ExportTable 
			SELECT 8001, N'EXEC sx_pf_POST_Format @Username,'''
				+ FormatID + N''','''
				+ BackgroundColor + N''',''' 
				+ FontColor + N''',''' 
				+ ValueFormat + N''''
			FROM [dbo].[sx_pf_hFormats]
			WHERE FormatID IN (SELECT DISTINCT FormatID FROM DependendFormats);
					
			INSERT INTO @ExportTable
			VALUES (9000, N'GO');

		END -- of Output for SQL Server

		 -- STEP 3.3 - OUTPUT Type for PF Client Execution ##################################################################################################
		ELSE IF @OutputForSQLServer = 0
		BEGIN
			DECLARE @spr CHAR = CHAR(31); 

			INSERT INTO @ExportTable 
			VALUES (0, N'--CONFIG: Adjust variable names manually to fit your needs !')
			, (0, N'--DECLARE #Username NVARCHAR(255) = ''SQL''')
			, (0, N'--DECLARE #FactoryID NVARCHAR(255) = ''' + @FactoryID + N'''')
			, (0, N'--DECLARE #ProductLineID  NVARCHAR(255) = ''' + @ProductLineID + N'''')
			, (0, N'--DECLARE #ProductID  NVARCHAR(255) = ''' + @ProductID + N'''')
			, (0, N'--This ProductID will be deleted during import, if it exists. You should be sure !');

			-- DELETE Product if exists
			INSERT INTO @ExportTable 
			VALUES (1000, N'sx_pf_DELETE_Product' + @spr + '@Username' + @spr + '#Username' + @spr + '@FactoryID' + @spr + '#FactoryID' + @spr + '@ProductlineID' + @spr + '#ProductLineID' + @spr + '@ProductID' + @spr + '#ProductID');

			-- POST Product
			INSERT INTO @ExportTable 
			SELECT 2000, N'sx_pf_POST_ProductEmpty' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@ProductID' + @spr + N'#ProductID' + @spr + N'@ProductlineID' + @spr + N'#ProductLineID' + @spr + N'@FactoryID' + @spr + N'#FactoryID' +
				N'' + @spr + N'@TimeType' + @spr + N'' + TimeType + 
				N'' + @spr + N'@NameShort' + @spr + N'' + NameShort + 
				N'' + @spr + N'@NameLong' + @spr + N'' + NameLong + 
				N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser + 
				N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev + 
				N'' + @spr + N'@ResponsiblePerson' + @spr + N'' + ResponsiblePerson + 
				N'' + @spr + N'@ImageName' + @spr + N'' + ImageName + 
				N'' + @spr + N'@Status' + @spr + N'' + [Status] + 
				N'' + @spr + N'@Template' + @spr + N'' + Template + 
				N'' + @spr + N'@TemplateVersion' + @spr + N'' + TemplateVersion + 
				N'' + @spr + N'@GA1' + @spr + N'' + GlobalAttribute1 + 
				N'' + @spr + N'@GA2' + @spr + N'' + GlobalAttribute2 + 
				N'' + @spr + N'@GA3' + @spr + N'' + GlobalAttribute3 + 
				N'' + @spr + N'@GA4' + @spr + N'' + GlobalAttribute4 + 
				N'' + @spr + N'@GA5' + @spr + N'' + GlobalAttribute5 + 
				N'' + @spr + N'@GA6' + @spr + N'' + GlobalAttribute6 + 
				N'' + @spr + N'@GA7' + @spr + N'' + GlobalAttribute7 + 
				N'' + @spr + N'@GA8' + @spr + N'' + GlobalAttribute8 + 
				N'' + @spr + N'@GA9' + @spr + N'' + GlobalAttribute9 + 
				N'' + @spr + N'@GA10' + @spr + N'' + GlobalAttribute10 + 
				N'' + @spr + N'@GA11' + @spr + N'' + GlobalAttribute11 + 
				N'' + @spr + N'@GA12' + @spr + N'' + GlobalAttribute12 + 
				N'' + @spr + N'@GA13' + @spr + N'' + GlobalAttribute13 + 
				N'' + @spr + N'@GA14' + @spr + N'' + GlobalAttribute14 + 
				N'' + @spr + N'@GA15' + @spr + N'' + GlobalAttribute15 + 
				N'' + @spr + N'@GA16' + @spr + N'' + GlobalAttribute16 + 
				N'' + @spr + N'@GA17' + @spr + N'' + GlobalAttribute17 + 
				N'' + @spr + N'@GA18' + @spr + N'' + GlobalAttribute18 + 
				N'' + @spr + N'@GA19' + @spr + N'' + GlobalAttribute19 + 
				N'' + @spr + N'@GA20' + @spr + N'' + GlobalAttribute20 + 
				N'' + @spr + N'@GA21' + @spr + N'' + GlobalAttribute21 + 
				N'' + @spr + N'@GA22' + @spr + N'' + GlobalAttribute22 + 
				N'' + @spr + N'@GA23' + @spr + N'' + GlobalAttribute23 + 
				N'' + @spr + N'@GA24' + @spr + N'' + GlobalAttribute24 + 
				N'' + @spr + N'@GA25' + @spr + N'' + GlobalAttribute25 + N''
			FROM [dbo].[sx_pf_dProducts] WHERE ProductKey = @ProductKey;

			-- POST Product Properties
			INSERT INTO @ExportTable 
			SELECT 3000, N'sx_pf_POST_ProductProperty' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@ProductID' + @spr + N'#ProductID' + @spr + N'@ProductLineID' + @spr + N'#ProductlineID' + @spr + N'@FactoryID' + @spr + N'#FactoryID' + 
				N'' + @spr + N'@PropertyID' + @spr + N'' + PropertyID + 
				N'' + @spr + N'@PropertyName' + @spr + N'' + PropertyName + 
				N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser + 
				N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev + 
				N'' + @spr + N'@Unit' + @spr + N'' + Unit + 
				N'' + @spr + N'@ValueText' + @spr + N'' + ValueText + 
				N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255)) + 
				N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255)) + 
				N'' + @spr + N'@IsROSystemProperty' + @spr + N'' + CAST(IsROSystemProperty AS NVARCHAR(255)) + 
				N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_gProducts]
			WHERE ProductKey = @ProductKey; 
			
			-- POST Statements -- statements are not exported

			-- POST all ValueSeries as NewValueSeries
			INSERT INTO @ExportTable 
			SELECT 4000 + ValueSeriesNo AS Step , N'sx_pf_POST_ValueSerie' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@ProductID' + @spr + N'#ProductID' + @spr + N'@ProductLineID' + @spr + N'#ProductLineID' + @spr + N'@FactoryID' + @spr + N'#FactoryID' + 
				N'' + @spr + N'@ValueSeriesID' + @spr + N'' + ValueSeriesID + 
				N'' + @spr + N'@RequestedValueSeriesNo' + @spr + N'' + CAST(ValueSeriesNo AS NVARCHAR (255)) + 
				N'' + @spr + N'@NameShort' + @spr + N'' + NameShort + 
				N'' + @spr + N'@NameLong' + @spr + N'' + NameLong + 
				N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser + 
				N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev + 
				N'' + @spr + N'@ImageName' + @spr + N'' + ImageName + 
				N'' + @spr + N'@IsNumeric' + @spr + N'' + CAST([IsNumeric] AS NVARCHAR (255)) + 
				N'' + @spr + N'@VisibilityLevel' + @spr + N'' + CAST(VisibilityLevel AS NVARCHAR (255)) + 
				N'' + @spr + N'@ValueSource' + @spr + N'' + ValueSource + 
				N'' + @spr + N'@ValueListID' + @spr + N'' + ValueListID + 
				N'' + @spr + N'@ValueFormatID' + @spr + N'' + ValueFormatID + 
				N'' + @spr + N'@Unit' + @spr + N'' + Unit + 
				N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR (255)) + 
				N'' + @spr + N'@Effect' + @spr + N'' + Effect + 
				N'' + @spr + N'@EffectParameter' + @spr + N'' + EffectParameter + N''
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE ProductKey = @ProductKey ;

			-- POST Timeline
			;WITH tms AS (
				SELECT (SELECT N'[(' + CAST(TimeID AS NVARCHAR(10)) + ',0,0,'''''''')],'
				FROM [dbo].[sx_pf_dTime]
				WHERE  ProductKey = @ProductKey
				GROUP BY TimeID
				ORDER BY TimeID
				FOR XML PATH('')) AS val 
			)
			INSERT INTO @ExportTable
			SELECT 5000, N'sx_pf_POST_Timeline' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@ProductID'
				+ @spr + N'#ProductID' + @spr + N'@ProductLineID' + @spr + N'#ProductLineID' + @spr + N'@FactoryID' + @spr + N'#FactoryID'
				+ @spr + N'@IsIncrementalValuesFlag' + @spr + N'0' + N'' 
				+ @spr + N'@TimeIDsInBracketsCommaSeparated' + @spr + N'' + LEFT(val, LEN(val) - 1) + N''
			FROM tms
			WHERE NOT val IS NULL;
			
			-- POST Product DataTable
			;WITH vals AS (
				SELECT (SELECT  N'[(''' + fV.ValueSeriesID 
					+ N''',' + CAST(fV.TimeID AS NVARCHAR(255)) + N',''' 
					+ fV.ValueFormula + ''',''' 
					+ CAST(fV.ValueInt AS NVARCHAR(255)) + ''',''' 
					+ fV.ValueText + ''',''' 
					+ fV.ValueComment + ''')],'
				FROM [dbo].[sx_pf_fValues] fV LEFT JOIN [dbo].[sx_pf_dValueSeries] dVS 
					ON fV.ValueSeriesKey = dVS.ValueSeriesKey
				WHERE fV.ProductKey = @ProductKey 
				ORDER BY dVS.ValueSeriesNo
				FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)') AS val 
			)
			INSERT INTO @ExportTable 
			SELECT 6000, N'sx_pf_POST_ProductDataTableValues' + @spr + N'@Username' + @spr 
				+ N'#Username' + @spr + N'@ProductID' + @spr + N'#ProductID' + @spr + N'@ProductLineID' + @spr
				+ N'#ProductLineID' + @spr + N'@FactoryID' + @spr + N'#FactoryID' + @spr + N'@IsIncrementalValuesFlag' + @spr + N'1' 
				+ N'' + @spr + N'@ValuesInBracketsCommaSeparated' + @spr + N''
				+ LEFT(val, LEN(val) - 1) + N''
			FROM vals
			WHERE NOT val IS NULL;

			-- Create the lists
			INSERT INTO @ExportTable 
			SELECT 7001, N'sx_pf_POST_List' + @spr + N'@Username' + @spr + N'#Username' + 
				N'' + @spr + N'@ListID'	+ @spr + N'' + ListID + 
				N'' + @spr + N'@NameShort'	+ @spr + N'' + NameShort + 
				N'' + @spr + N'@NameLong' + @spr + N'' + NameLong + 
				N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser + 
				N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev + 
				N'' + @spr + N'@Datentyp' + @spr + N'' + Datentyp + 
				N'' + @spr + N'@Source' + @spr + N'' + Source + 
				N'' + @spr + N'@SourceFormula' + @spr + N'' + SourceFormula + 
				N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_hLists]
			WHERE ListID IN	(SELECT ListID FROM @DependendListIDs);

			--Create the List Values
			INSERT INTO @ExportTable 
			SELECT 8001, N'sx_pf_POST_ListValue' + @spr + N'@Username' + @spr + N'#Username' + 
				N'' + @spr + N'@ListValueKey' + @spr + N'' + N'0' + 
				N'' + @spr + N'@ListID' + @spr + N'' + ListID + 
				N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255)) + 
				N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255)) + 
				N'' + @spr + N'@ValueText' + @spr + N'' + ValueText + 
				N'' + @spr + N'@ValueComment' + @spr + N'' + ValueComment + 
				N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_hListValues] 
			WHERE ListID IN	(SELECT ListID FROM @DependendListIDs);

			-- Create Formats
			;WITH DependendFormats AS (
				SELECT FormatID
				FROM [dbo].[sx_pf_hListValues] 
				WHERE ListID IN (SELECT ListID FROM @DependendListIDs)
				UNION ALL SELECT ValueFormatID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductKey = @ProductKey
			) 
			INSERT INTO @ExportTable
			SELECT 8001, N'sx_pf_POST_Format' + @spr + N'@Username' + @spr + N'#Username' + 
				N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + 
				N'' + @spr + N'@BackgroundColor' + @spr + N'' + BackgroundColor + 
				N'' + @spr + N'@FontColor' + @spr + N'' + FontColor + 
				N'' + @spr + N'@ValueFormat' + @spr + N'' + ValueFormat + N''
			FROM [dbo].[sx_pf_hFormats]
			WHERE FormatID IN (SELECT DISTINCT FormatID FROM DependendFormats);

		END; -- Output for PF Client
		
		-- STEP 3.4 - Final Value Output ###################################################################################################################
		SELECT Command 
		FROM @ExportTable 
		ORDER BY StepNumber;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = 200;

	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_EXPORT_Product] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_EXPORT_Product] TO pf_PlanningFactoryService;
GO
/* 
EXPORT operation of a single productline, including
- its properties in gtables
- its global attributes
- its products
- it values
- its dependend lists, which have to be merged in the existing lists during import
- in two styles, one for import as sql script, one for Import over the GUI Import

Dependencies:
	 - Functions:
		- sx_pf_pProtectString
		- sx_pf_pProtectID
		- sx_pf_pMaskSQL
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pGET_ProductLineReadRight
		- sx_pf_pPOST_API_LogEntry

03/2017 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
Return values according to HTTP standard

Test Call:
Results must be stored in table, as column width is to big for SSMS or SQLCMD

0a. Activate Stepnumber for output in Line 624 around and execute prodecedure
0b. Its difficult to send commands with german Umlaute over cmd, thats why name the database without Umlaute

1. Execute this to store the results in the table
	IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[tmpout_Export]') AND type in (N'U'))
	DROP TABLE [dbo].[tmpout_Export]
	GO
	CREATE TABLE tmpout_Export (
		StepNumber INT,
		Command NVARCHAR(MAX)
		)
	INSERT INTO tmpout_Export
		EXEC sx_pf_EXPORT_Productline 'SQL','AT','1',0

2. Copy this table Content in a file over a .bat file with this command
	bcp.exe "SELECT Command FROM PlanningFactoryCars.dbo.tmpout_Export ORDER BY StepNumber" queryout import.sql -T -S localhost -n  -e error.log -c -C65001 
*/

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_EXPORT_Productline]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[sx_pf_EXPORT_Productline];
GO

CREATE PROCEDURE [dbo].[sx_pf_EXPORT_Productline]
	@Username AS NVARCHAR(255),
	@FactoryID AS NVARCHAR(255),
	@ProductLineID AS NVARCHAR(255),
	@OutputForSQLServer INT
AS
BEGIN
	SET NOCOUNT ON;
	
	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@FactoryID, N'NULL') + N''',''' + ISNULL(@ProductLineID, N'NULL') + N''',''' + ISNULL(CAST(@OutputForSQLServer AS NVARCHAR(255)), N'NULL') + N'''';
	DECLARE @EffectedRows AS INTEGER = 0;						-- SET during Execution
	DECLARE @ResultCode AS INTEGER = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';					-- SET during Execution
	
	-- STEP 0.1 - NULL Protection
	IF @Username			IS NULL SET @Username = N'';
	IF @FactoryID			IS NULL SET @FactoryID = N'';
	IF @ProductLineID		IS NULL SET @ProductLineID = N'';
	IF @OutputForSQLServer	IS NULL SET @OutputForSQLServer = 0;

	BEGIN TRY

		DECLARE @ProductLineKey BIGINT = 0;

		-- STEP 0.2 - Protect input parameters
		SET @Username = dbo.sx_pf_pProtectString(@Username);
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID);
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID);

		IF @FactoryID = N'' OR @ProductLineID = N''
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;

		-- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403'  
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;		

		-- STEP 1.2 - Determine keys
		SELECT @ProductLineKey = ProductlineKey FROM [dbo].[sx_pf_dProductLines] WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID;

		IF @ProductLineKey = 0 
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Keys don`t exists', 16, 10);
		END;	
	
		-- STEP 2 - Check rights
		EXEC @ResultCode = [dbo].[sx_pf_pGET_ProductLineReadRight] @TransactUsername, @FactoryID, @ProductLineID;
		IF @ResultCode <> 200	
		BEGIN
			SET @ResultCode = 401;
			RAISERROR('Invalid rights', 16, 10);
		END;

		-- STEP 3.1 - Determine dependend objects
		-- Determine dependend Lists and store in temporary table
		DECLARE @DependendListIDs AS TABLE (ListID NVARCHAR(255));
		
		;WITH lists AS (
			-- MERGE dependend Lists, used in ProductDataTable
			SELECT ValueListID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductlineKey = @ProductLineKey
			-- MERGE dependend Lists, used in Globalattributes
			UNION ALL SELECT GlobalAttributeSource1 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource2 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource3 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource4 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource5 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource6 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource7 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource8 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource9 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource10 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource11 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource12 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource13 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource14 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource15 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource16 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource17 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource18 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource19 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource20 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource21 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource22 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource23 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource24 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
			UNION ALL SELECT GlobalAttributeSource25 FROM [dbo].[sx_pf_dProductLines] WHERE ProductLineKey = @ProductLineKey
		)									
		INSERT INTO @DependendListIDs (ListID)
		SELECT DISTINCT ValueListID
		FROM lists;
		 
		-- Declare temporary Table for export results
		DECLARE @ExportTable AS TABLE (StepNumber INT NOT NULL, Command NVARCHAR(MAX));
		
		-- STEP 3.2 - OUTPUT Type for SQL Server ##################################################################################################

		IF @OutputForSQLServer = 1
		BEGIN
			INSERT INTO @ExportTable 
			VALUES (0, N'--CONFIG: Adjust variable names manually to fit your needs !')
			, (0, N'DECLARE @Username NVARCHAR(255) = ''SQL''')
			, (0, N'DECLARE @FactoryID NVARCHAR(255) = ''' + @FactoryID + N'''')
			, (0, N'DECLARE @ProductLineID  NVARCHAR(255) = ''' + @ProductLineID + N'''')
			, (0, N'--This ProductlineID will be deleted during import, if it exists. You should be sure !');

			-- DELETE Productline if exists
			INSERT INTO @ExportTable 
			VALUES (1000, N'EXEC sx_pf_DELETE_Productline @Username, @FactoryID, @ProductLineID');
				
			-- POST Productline
			INSERT INTO @ExportTable 
			SELECT 1001, N'EXEC sx_pf_POST_Productline @Username, @ProductLineID, @FactoryID,'''
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ResponsiblePerson) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](DefaultTemplate) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource3) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias3) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource4) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias4) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource5) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias5) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource6) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias6) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource7) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias7) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource8) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias8) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource9) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias9) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource10) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias10) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource13) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias13) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource14) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias14) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource15) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias15) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource16) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias16) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource17) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias17) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource18) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias18) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource19) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias19) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource20) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias20) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource23) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias23) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource24) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias24) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeSource25) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttributeAlias25) + N''''
			FROM [dbo].[sx_pf_dProductlines] WHERE ProductlineKey = @ProductLineKey;
					
			-- POST Products
			INSERT INTO @ExportTable
			SELECT 2000, N'EXEC sx_pf_POST_ProductEmpty @Username,''' + ProductID + N''', @ProductLineID, @FactoryID,''' 
				+ TimeType + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ResponsiblePerson) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL]([Status]) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](Template) + N''',''' 
				+ TemplateVersion + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute1) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute2) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute3) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute4) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute5) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute6) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute7) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute8) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute9) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute10) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute11) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute12) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute13) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute14) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute15) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute16) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute17) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute18) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute19) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute20) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute21) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute22) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute23) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute24) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](GlobalAttribute25) + N''''
			FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @ProductLineKey;
							
			-- POST Statements -- statements are not exported

			-- POST all ValueSeries as NewValueSeries
			INSERT INTO @ExportTable 
			SELECT 3000 + ValueSeriesNo
				, 'EXEC sx_pf_POST_ValueSerie @Username,''' + ProductID + ''', @ProductLineID, @FactoryID,''' +
				+ ValueSeriesID + N''','''
				+ CAST(ValueSeriesNo AS NVARCHAR (255)) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](ImageName) + N''','''
				+ CAST([IsNumeric] AS NVARCHAR (255)) + N''','''
				+ CAST(VisibilityLevel AS NVARCHAR (255)) + N''','''
				+ ValueSource + N''','''
				+ ValueListID + N''','''
				+ ValueFormatID + N''','''
				+ Unit + N''','''
				+ CAST(Scale AS NVARCHAR (255)) + N''','''
				+ Effect + N''','''
				+ EffectParameter + N''''
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE  ProductlineKey = @ProductLineKey; 
				
			-- POST dTime 
			;WITH tms AS (
				SELECT dP.ProductID
					,(SELECT N'[(' + CAST(t.TimeID AS NVARCHAR(10)) + ',0,0,'''''''')],' -- with DeleteFlag, AddValue,AliasName 
					FROM [dbo].[sx_pf_dTime] t
					WHERE t.ProductKey = dP.ProductKey
					GROUP BY t.TimeID
					ORDER BY t.TimeID
					FOR XML PATH('')) AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.ProductLineKey = @ProductLineKey 
			)
			INSERT INTO @ExportTable
			SELECT 4000, N'EXEC sx_pf_POST_Timeline @Username, ''' + ProductID + N''', @ProductLineID, @FactoryID,1,''' + LEFT(vals, LEN(vals) - 1) + N''''
			FROM tms
			WHERE NOT vals IS NULL;

			-- POST ProductDataTableValues
			;WITH tms AS (
				SELECT dP.ProductID
					,(SELECT N'[(''''' + ValueSeriesID 
							+ N''''',' + CAST(TimeID AS NVARCHAR(255)) 
							+ N',''''' + ValueFormula 
							+ N''''',''''' + CAST(ValueInt AS NVARCHAR(255)) 
							+ N''''',''''' + [dbo].[sx_pf_pMaskSQL](ValueText) 
							+ N''''',''''' + [dbo].[sx_pf_pMaskSQL](ValueComment) + ''''')],' 
					FROM [dbo].[sx_pf_fValues] t
					WHERE t.ProductKey = dP.ProductKey
					FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)') AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.ProductLineKey = @ProductLineKey 
			)
			INSERT INTO @ExportTable
			SELECT 5000, N'EXEC sx_pf_POST_ProductDataTableValues @Username,''' + ProductID + N''', @ProductLineID, @FactoryID,0,''' + LEFT(vals, LEN(vals) - 1) + N''''
			FROM tms
			WHERE NOT vals IS NULL;

			-- POST Productline Properties
			INSERT INTO @ExportTable 
			SELECT 6000, N'EXEC sx_pf_POST_ProductlineProperty @Username, @ProductLineID, @FactoryID,''' 
					+ PropertyID + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](PropertyName) + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''', '''
					+ Unit + N''', '''
					+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''', '''
					+ CAST(ValueInt AS NVARCHAR(255)) + N''', '''
					+ CAST(Scale AS NVARCHAR(255)) + N''', '''
					+ CAST(IsROSystemProperty AS NVARCHAR(255)) + N''', '''
					+ FormatID + N''''
			FROM [dbo].[sx_pf_gProductLines]
			WHERE ProductlineKey = @ProductLineKey; 

			-- POST Product Properties
			INSERT INTO @ExportTable 
			SELECT 6001, N'EXEC sx_pf_POST_ProductProperty @Username,''' + ProductID + N''', @ProductLineID, @FactoryID,''' 
				+ PropertyID + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](PropertyName) + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''', '''
				+ Unit + N''', '''
				+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''', '''
				+ CAST(ValueInt AS NVARCHAR(255)) + N''', '''
				+ CAST(Scale AS NVARCHAR(255)) + N''', '''
				+ CAST(IsROSystemProperty AS NVARCHAR(255)) + N''', '''
				+ FormatID + N''''
			FROM [dbo].[sx_pf_gProducts]
			WHERE  ProductlineKey = @ProductLineKey; 
						
			-- Create the lists
			INSERT INTO @ExportTable 
			SELECT 7001, N'EXEC sx_pf_POST_List @Username,'''
				+ ListID + ''','''
				+ [dbo].[sx_pf_pMaskSQL](NameShort) + N''','''
				+ [dbo].[sx_pf_pMaskSQL](NameLong) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentUser) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](CommentDev) + N''',''' 
				+ Datentyp + N''',''' 
				+ Source + N''',''' 
				+ SourceFormula + N''',''' 
				+ FormatID + N''''
			FROM [dbo].[sx_pf_hLists]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
					
			-- Create List Values
			INSERT INTO @ExportTable 
			SELECT 7002, N'EXEC sx_pf_POST_ListValue @Username,0,'''
				+ ListID + N''',' 
				+ CAST(ValueInt AS NVARCHAR(255)) + N',' 
				+ CAST(Scale AS NVARCHAR(255)) + N',''' 
				+ [dbo].[sx_pf_pMaskSQL](ValueText) + N''',''' 
				+ [dbo].[sx_pf_pMaskSQL](ValueComment) + N''',''' 
				+ FormatID + N''''
			FROM [dbo].[sx_pf_hListValues]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
						   
			-- Create Formats
			;WITH DependendFormats AS (
				SELECT FormatID
				FROM [dbo].[sx_pf_hListValues] 
				WHERE ListID IN (SELECT ListID FROM @DependendListIDs)
				UNION ALL SELECT ValueFormatID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductlineKey = @ProductLineKey
			) 
			INSERT INTO @ExportTable 
			SELECT 7003, N'EXEC sx_pf_POST_Format @Username,'''
				+ FormatID + N''','''
				+ BackgroundColor + N''',''' 
				+ FontColor + N''',''' 
				+ ValueFormat + N''''
			FROM [dbo].[sx_pf_hFormats]
			WHERE FormatID IN (SELECT DISTINCT FormatID FROM DependendFormats);
					
			INSERT INTO @ExportTable
			VALUES (8000, N'GO');

		END -- of Output for SQL Server
		
	-- STEP 3.3 - OUTPUT Type for PF Client Execution ##################################################################################################
		ELSE IF @OutputForSQLServer = 0
		BEGIN
			DECLARE @spr CHAR = CHAR(31); 

			INSERT INTO @ExportTable 
			VALUES (0, N'--CONFIG: Adjust variable names manually to fit your needs !')
			, (0, N'--DECLARE #Username NVARCHAR(255) = ''SQL''')
			, (0, N'--DECLARE #FactoryID NVARCHAR(255) = ''' + @FactoryID + N'''')
			, (0, N'--DECLARE #ProductLineID  NVARCHAR(255) = ''' + @ProductLineID + N'''')
			, (0, N'--This ProductlineID will be deleted during import, if it exists. You should be sure !');

		
			-- DELETE Productline if exists
			INSERT INTO @ExportTable 
			VALUES (1000, N'sx_pf_DELETE_Productline' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@FactoryID' + @spr + N'#FactoryID' + @spr + N'@ProductLineID' + @spr + N'#ProductLineID');
						
			-- POST Productline
			INSERT INTO @ExportTable 
			SELECT 1001, N'sx_pf_POST_Productline' + @spr + N'@Username' + @spr + N'#Username' + @spr + N'@ProductlineID' + @spr + N'#ProductlineID' + @spr + N'@FactoryID' + @spr + N'#FactoryID'
				+ N'' + @spr + N'@NameShort' + @spr + N'' + NameShort 
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong  
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser  
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev  
				+ N'' + @spr + N'@ResponsiblePerson' + @spr + N'' + ResponsiblePerson  
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName  
				+ N'' + @spr + N'@DefaultTemplate' + @spr + N'' + DefaultTemplate  
				+ N'' + @spr + N'@GlobalAttributeSource1' + @spr + N'' + GlobalAttributeSource1  
				+ N'' + @spr + N'@GlobalAttributeAlias1' + @spr + N'' + GlobalAttributeAlias1  
				+ N'' + @spr + N'@GlobalAttributeSource2' + @spr + N'' + GlobalAttributeSource2  
				+ N'' + @spr + N'@GlobalAttributeAlias2' + @spr + N'' + GlobalAttributeAlias2  
				+ N'' + @spr + N'@GlobalAttributeSource3' + @spr + N'' + GlobalAttributeSource3  
				+ N'' + @spr + N'@GlobalAttributeAlias3' + @spr + N'' + GlobalAttributeAlias3 
				+ N'' + @spr + N'@GlobalAttributeSource4' + @spr + N'' + GlobalAttributeSource4  
				+ N'' + @spr + N'@GlobalAttributeAlias4' + @spr + N'' + GlobalAttributeAlias4 
				+ N'' + @spr + N'@GlobalAttributeSource5' + @spr + N'' + GlobalAttributeSource5  
				+ N'' + @spr + N'@GlobalAttributeAlias5' + @spr + N'' + GlobalAttributeAlias5 
				+ N'' + @spr + N'@GlobalAttributeSource6' + @spr + N'' + GlobalAttributeSource6  
				+ N'' + @spr + N'@GlobalAttributeAlias6' + @spr + N'' + GlobalAttributeAlias6 
				+ N'' + @spr + N'@GlobalAttributeSource7' + @spr + N'' + GlobalAttributeSource7  
				+ N'' + @spr + N'@GlobalAttributeAlias7' + @spr + N'' + GlobalAttributeAlias7 
				+ N'' + @spr + N'@GlobalAttributeSource8' + @spr + N'' + GlobalAttributeSource8  
				+ N'' + @spr + N'@GlobalAttributeAlias8' + @spr + N'' + GlobalAttributeAlias8 
				+ N'' + @spr + N'@GlobalAttributeSource9' + @spr + N'' + GlobalAttributeSource9  
				+ N'' + @spr + N'@GlobalAttributeAlias9' + @spr + N'' + GlobalAttributeAlias9 
				+ N'' + @spr + N'@GlobalAttributeSource10' + @spr + N'' + GlobalAttributeSource10  
				+ N'' + @spr + N'@GlobalAttributeAlias10' + @spr + N'' + GlobalAttributeAlias10 
				+ N'' + @spr + N'@GlobalAttributeSource11' + @spr + N'' + GlobalAttributeSource11  
				+ N'' + @spr + N'@GlobalAttributeAlias11' + @spr + N'' + GlobalAttributeAlias11  
				+ N'' + @spr + N'@GlobalAttributeSource12' + @spr + N'' + GlobalAttributeSource12  
				+ N'' + @spr + N'@GlobalAttributeAlias12' + @spr + N'' + GlobalAttributeAlias12  
				+ N'' + @spr + N'@GlobalAttributeSource13' + @spr + N'' + GlobalAttributeSource13  
				+ N'' + @spr + N'@GlobalAttributeAlias13' + @spr + N'' + GlobalAttributeAlias13 
				+ N'' + @spr + N'@GlobalAttributeSource14' + @spr + N'' + GlobalAttributeSource14  
				+ N'' + @spr + N'@GlobalAttributeAlias14' + @spr + N'' + GlobalAttributeAlias14 
				+ N'' + @spr + N'@GlobalAttributeSource15' + @spr + N'' + GlobalAttributeSource15  
				+ N'' + @spr + N'@GlobalAttributeAlias15' + @spr + N'' + GlobalAttributeAlias15 
				+ N'' + @spr + N'@GlobalAttributeSource16' + @spr + N'' + GlobalAttributeSource16  
				+ N'' + @spr + N'@GlobalAttributeAlias16' + @spr + N'' + GlobalAttributeAlias16 
				+ N'' + @spr + N'@GlobalAttributeSource17' + @spr + N'' + GlobalAttributeSource17  
				+ N'' + @spr + N'@GlobalAttributeAlias17' + @spr + N'' + GlobalAttributeAlias17 
				+ N'' + @spr + N'@GlobalAttributeSource18' + @spr + N'' + GlobalAttributeSource18  
				+ N'' + @spr + N'@GlobalAttributeAlias18' + @spr + N'' + GlobalAttributeAlias18 
				+ N'' + @spr + N'@GlobalAttributeSource19' + @spr + N'' + GlobalAttributeSource19  
				+ N'' + @spr + N'@GlobalAttributeAlias19' + @spr + N'' + GlobalAttributeAlias19 
				+ N'' + @spr + N'@GlobalAttributeSource20' + @spr + N'' + GlobalAttributeSource20  
				+ N'' + @spr + N'@GlobalAttributeAlias20' + @spr + N'' + GlobalAttributeAlias20 
				+ N'' + @spr + N'@GlobalAttributeSource21' + @spr + N'' + GlobalAttributeSource21  
				+ N'' + @spr + N'@GlobalAttributeAlias21' + @spr + N'' + GlobalAttributeAlias21  
				+ N'' + @spr + N'@GlobalAttributeSource22' + @spr + N'' + GlobalAttributeSource22  
				+ N'' + @spr + N'@GlobalAttributeAlias22' + @spr + N'' + GlobalAttributeAlias22  
				+ N'' + @spr + N'@GlobalAttributeSource23' + @spr + N'' + GlobalAttributeSource23  
				+ N'' + @spr + N'@GlobalAttributeAlias23' + @spr + N'' + GlobalAttributeAlias23 
				+ N'' + @spr + N'@GlobalAttributeSource24' + @spr + N'' + GlobalAttributeSource24  
				+ N'' + @spr + N'@GlobalAttributeAlias24' + @spr + N'' + GlobalAttributeAlias24 
				+ N'' + @spr + N'@GlobalAttributeSource25' + @spr + N'' + GlobalAttributeSource25  
				+ N'' + @spr + N'@GlobalAttributeAlias25' + @spr + N'' + GlobalAttributeAlias25 + N''
			FROM [dbo].[sx_pf_dProductlines] WHERE ProductlineKey = @ProductLineKey;
					
			-- POST Products
			INSERT INTO @ExportTable
			SELECT 2000, N'sx_pf_POST_ProductEmpty' 
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ @spr + N'@ProductLineID' + @spr + N'#ProductLineID' 
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@TimeType' + @spr + N'' + TimeType
				+ N'' + @spr + N'@NameShort' + @spr + N'' +	NameShort
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@ResponsiblePerson' + @spr + N'' + ResponsiblePerson
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName
				+ N'' + @spr + N'@Status' + @spr + N'' + [Status] 
				+ N'' + @spr + N'@Template' + @spr + N'' + Template 
				+ N'' + @spr + N'@TemplateVersion' + @spr + N'' + TemplateVersion
				+ N'' + @spr + N'@GA1' + @spr + N'' + GlobalAttribute1
				+ N'' + @spr + N'@GA2' + @spr + N'' + GlobalAttribute2
				+ N'' + @spr + N'@GA3' + @spr + N'' + GlobalAttribute3
				+ N'' + @spr + N'@GA4' + @spr + N'' + GlobalAttribute4
				+ N'' + @spr + N'@GA5' + @spr + N'' + GlobalAttribute5
				+ N'' + @spr + N'@GA6' + @spr + N'' + GlobalAttribute6
				+ N'' + @spr + N'@GA7' + @spr + N'' + GlobalAttribute7
				+ N'' + @spr + N'@GA8' + @spr + N'' + GlobalAttribute8
				+ N'' + @spr + N'@GA9' + @spr + N'' + GlobalAttribute9
				+ N'' + @spr + N'@GA10' + @spr + N'' + GlobalAttribute10 
				+ N'' + @spr + N'@GA11' + @spr + N'' + GlobalAttribute11
				+ N'' + @spr + N'@GA12' + @spr + N'' + GlobalAttribute12
				+ N'' + @spr + N'@GA13' + @spr + N'' + GlobalAttribute13
				+ N'' + @spr + N'@GA14' + @spr + N'' + GlobalAttribute14
				+ N'' + @spr + N'@GA15' + @spr + N'' + GlobalAttribute15
				+ N'' + @spr + N'@GA16' + @spr + N'' + GlobalAttribute16
				+ N'' + @spr + N'@GA17' + @spr + N'' + GlobalAttribute17
				+ N'' + @spr + N'@GA18' + @spr + N'' + GlobalAttribute18
				+ N'' + @spr + N'@GA19' + @spr + N'' + GlobalAttribute19
				+ N'' + @spr + N'@GA20' + @spr + N'' + GlobalAttribute20
				+ N'' + @spr + N'@GA21' + @spr + N'' + GlobalAttribute21
				+ N'' + @spr + N'@GA22' + @spr + N'' + GlobalAttribute22
				+ N'' + @spr + N'@GA23' + @spr + N'' + GlobalAttribute23
				+ N'' + @spr + N'@GA24' + @spr + N'' + GlobalAttribute24
				+ N'' + @spr + N'@GA25' + @spr + N'' + GlobalAttribute25 + N''
			FROM [dbo].[sx_pf_dProducts] WHERE ProductlineKey = @ProductLineKey; 
									
			-- POST Statements -- statements are not exported

			-- POST all ValueSeries as NewValueSeries
			INSERT INTO @ExportTable 
			SELECT 3000 + ValueSeriesNo
				, 'sx_pf_POST_ValueSerie'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ @spr + N'@ProductLineID' + @spr + N'#ProductLineID' 
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@ValueSeriesID' + @spr + N'' + ValueSeriesID 
				+ N'' + @spr + N'@RequestedValueSeriesNo' + @spr + N'' + CAST(ValueSeriesNo AS NVARCHAR (255))
				+ N'' + @spr + N'@NameShort' + @spr + N'' + NameShort
				+ N'' + @spr + N'@NameLong' + @spr + N'' + NameLong
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@ImageName' + @spr + N'' + ImageName
				+ N'' + @spr + N'@IsNumeric' + @spr + N'' + CAST([IsNumeric] AS NVARCHAR (255))
				+ N'' + @spr + N'@VisibilityLevel' + @spr + N'' + CAST(VisibilityLevel AS NVARCHAR (255))
				+ N'' + @spr + N'@ValueSource' + @spr + N'' + ValueSource
				+ N'' + @spr + N'@ValueListID' + @spr + N'' + ValueListID
				+ N'' + @spr + N'@ValueFormatID' + @spr + N'' + ValueFormatID
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR (255))
				+ N'' + @spr + N'@Effect' + @spr + N'' + Effect
				+ N'' + @spr + N'@EffectParameter' + @spr + N'' + EffectParameter + N''
			FROM [dbo].[sx_pf_dValueSeries]
			WHERE  ProductlineKey = @ProductLineKey; 

			-- POST dTime 
			;WITH tms AS (
				SELECT dP.ProductID
					,(SELECT N'[(' + CAST(t.TimeID AS NVARCHAR(10))+',0,0,'''')],' -- with DeleteFlag, AddValue,AliasName 
					FROM [dbo].[sx_pf_dTime] t
					WHERE t.ProductKey = dP.ProductKey
					GROUP BY t.TimeID
					ORDER BY t.TimeID
					FOR XML PATH('')) AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.ProductLineKey = @ProductLineKey 
			)
			INSERT INTO @ExportTable
			SELECT 4000, N'sx_pf_POST_Timeline'
				+ N'' + @spr + N'@Username' + @spr + N'#Username' 
				+ N'' + @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ N'' + @spr + N'@ProductLineID' + @spr + N'#ProductLineID' 
				+ N'' + @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@IsIncrementalValuesFlag' + @spr + N'1' + N''
				+ N'' + @spr + N'@TimeIDsInBracketsCommaSeparated' + @spr + N'' + LEFT(vals, LEN(vals) - 1) + N''
			FROM tms
			WHERE NOT vals IS NULL;		
			
			-- POST ProductDataTableValues
			;WITH tms AS (
				SELECT dP.ProductID
					,(SELECT N'[(''' + ValueSeriesID 
							+ N''',' + CAST(TimeID AS NVARCHAR(255)) 
							+ N',''' + ValueFormula 
							+ N''',''' + CAST(ValueInt AS NVARCHAR(255)) 
							+ N''',''' + ValueText 
							+ N''',''' + ValueComment + ''')],' 
					FROM [dbo].[sx_pf_fValues] t
					WHERE t.ProductKey = dP.ProductKey
					ORDER BY t.ValueSeriesID, t.TimeID
					FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)') AS vals
				FROM [dbo].[sx_pf_dProducts] dP 
				WHERE dP.ProductLineKey = @ProductLineKey 
			)
			INSERT INTO @ExportTable
			SELECT 5000, N'sx_pf_POST_ProductDataTableValues'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ N'' + @spr + N'@ProductLineID' + @spr + N'#ProductLineID' 
				+ N'' + @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@IsIncrementalValuesFlag' + @spr + N'0' + N''
				+ N'' + @spr + N'@ValuesInBracketsCommaSeparated' + @spr + N'' + LEFT(vals, LEN(vals) - 1) + N''
			FROM tms
			WHERE NOT vals IS NULL;

			-- POST Productline Properties
			INSERT INTO @ExportTable 
			SELECT 6000, N'sx_pf_POST_ProductlineProperty'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductLineID' + @spr + N'#ProductLineID' 
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID'  
				+ N'' + @spr + N'@PropertyID' + @spr + N'' + PropertyID 
				+ N'' + @spr + N'@PropertyName' + @spr + N'' + PropertyName
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@ValueText' + @spr + N'' + ValueText
				+ N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255))
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@IsROSystemProperty' + @spr + N'' + CAST(IsROSystemProperty AS NVARCHAR(255))
				+ N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_gProductLines]
			WHERE ProductlineKey = @ProductLineKey; 

			-- POST Product Properties
			INSERT INTO @ExportTable 
			SELECT 2001, N'sx_pf_POST_ProductProperty'
				+ @spr + N'@Username' + @spr + N'#Username' 
				+ @spr + N'@ProductID' + @spr + N'' + ProductID + N'' 
				+ @spr + N'@ProductLineID' + @spr + N'#ProductLineID' 
				+ @spr + N'@FactoryID' + @spr + N'#FactoryID' 
				+ N'' + @spr + N'@PropertyID' + @spr + N'' + PropertyID
				+ N'' + @spr + N'@PropertyName' + @spr + N'' + PropertyName
				+ N'' + @spr + N'@CommentUser' + @spr + N'' + CommentUser
				+ N'' + @spr + N'@CommentDev' + @spr + N'' + CommentDev
				+ N'' + @spr + N'@Unit' + @spr + N'' + Unit
				+ N'' + @spr + N'@ValueText' + @spr + N'' + ValueText
				+ N'' + @spr + N'@ValueInt' + @spr + N'' + CAST(ValueInt AS NVARCHAR(255)) 
				+ N'' + @spr + N'@Scale' + @spr + N'' + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@IsROSystemProperty' + @spr + N'' + CAST(IsROSystemProperty AS NVARCHAR(255)) 
				+ N'' + @spr + N'@FormatID' + @spr + N'' + FormatID + N''
			FROM [dbo].[sx_pf_gProducts]
			WHERE  ProductlineKey = @ProductLineKey;
		
			-- Create the lists
			INSERT INTO @ExportTable 
			SELECT 7001, N'sx_pf_POST_List'
				+ @spr + N'@Username' + @spr + N'#Username'
				+ N'' + @spr + N'@ListID' + @spr + ListID 
				+ N'' + @spr + N'@NameShort' + @spr + NameShort
				+ N'' + @spr + N'@NameLong' + @spr + NameLong
				+ N'' + @spr + N'@CommentDev' + @spr + CommentDev
				+ N'' + @spr + N'@CommentUser' + @spr + CommentUser
				+ N'' + @spr + N'@Datentyp' + @spr + Datentyp
				+ N'' + @spr + N'@Source' + @spr + [Source]
				+ N'' + @spr + N'@SourceFormula' + @spr + SourceFormula
				+ N'' + @spr + N'@FormatID' + @spr + FormatID + N''
			FROM [dbo].[sx_pf_hLists]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
					
			-- Create List Values
			INSERT INTO @ExportTable 
			SELECT 7002, N'sx_pf_POST_ListValue'
				+ @spr + N'@Username' + @spr + N'#Username'
				+ @spr + N'@ListValuekey' + @spr + N'' + N'0'
				+ N'' + @spr + N'@ListID' + @spr + ListID
				+ N'' + @spr + N'@ValueInt' + @spr + CAST(ValueInt AS NVARCHAR(255))
				+ N'' + @spr + N'@Scale' + @spr + CAST(Scale AS NVARCHAR(255))
				+ N'' + @spr + N'@ValueText' + @spr + ValueText
				+ N'' + @spr + N'@ValueComment' + @spr + ValueComment
				+ N'' + @spr + N'@FormatID' + @spr + FormatID + N''
			FROM [dbo].[sx_pf_hListValues]
			WHERE ListID IN (SELECT ListID FROM @DependendListIDs);
						   
			-- Create Formats
			;WITH DependendFormats AS (
				SELECT FormatID
				FROM [dbo].[sx_pf_hListValues] 
				WHERE ListID IN (SELECT ListID FROM @DependendListIDs)
				UNION ALL SELECT ValueFormatID FROM [dbo].[sx_pf_dValueSeries] WHERE ProductlineKey = @ProductLineKey
			) 
			INSERT INTO @ExportTable 
			SELECT 7003, N'sx_pf_POST_Format'
				+ @spr + N'@Username' + @spr + N'#Username'
				+ N'' + @spr + N'@FormatID' + @spr + FormatID
				+ N'' + @spr + N'@BackgroundColor' + @spr + BackgroundColor
				+ N'' + @spr + N'@FontColor' + @spr + FontColor
				+ N'' + @spr + N'@ValueFormat' + @spr + ValueFormat + N''
			FROM [dbo].[sx_pf_hFormats]
			WHERE FormatID IN (SELECT DISTINCT FormatID FROM DependendFormats);

		END; -- Output for PF Client	
	
		-- STEP 3.4 - Final Value Output ###################################################################################################################
		SELECT 
			--StepNumber, --activate only for bcp test output
			Command 
		FROM @ExportTable 
		ORDER BY StepNumber;
		
		SET @EffectedRows = @@ROWCOUNT;
		SET @ResultCode = 200;

	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;		
			PRINT 'Rollback due to not executable command.';
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_EXPORT_ProductLine] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_EXPORT_ProductLine] TO pf_PlanningFactoryService;
GO



	
/* Procedure to export all products 
by call [sx_pf_Export_Product] for each

This Procedure has no transaction, as it calls an other public procedure

Dependencies:
	- Functions: 
		- sx_pf_pProtectString
		- sx_pf_Determine_TransactionUsername
	 - Stored Procedures:
		- sx_pf_pPOST_API_LogEntry
	 - System 
		- sp_executesql
		- xp_cmdshell (be sure that server configurated correctly https://msdn.microsoft.com/en-US/library/ms175046.aspx) 
		- sp_configure
		- bcp utility

Planning Factory 4.0
02/2017 Gerd Tautenhahn for saxess-software gmbh

Test Call:
EXEC sx_pf_Export_Product_All 'SQL','d:\tmp\exportall', 1
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_EXPORT_Product_All]') AND type in (N'P', N'PC'))
DROP PROCEDURE [sx_pf_EXPORT_Product_All]
GO
 
CREATE  PROCEDURE [sx_pf_EXPORT_Product_All]
		@Username AS NVARCHAR(255),
		@LocalPath AS NVARCHAR(MAX),
		@OutputForSQLServer INT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TransactUsername AS NVARCHAR(255);
	DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID);
	DECLARE @ParameterString AS NVARCHAR (MAX) = N'''' + ISNULL(@Username, N'NULL') + N''',''' + ISNULL(@LocalPath, N'NULL') 
		+ N''',''' + ISNULL(CAST(@OutputForSQLServer AS NVARCHAR(255)), N'NULL') + N'''';
	DECLARE @EffectedRows AS INT = 0;						-- SET during Execution
	DECLARE @ResultCode AS INT = 501;						-- SET during Execution
	DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP;
	DECLARE @Comment AS NVARCHAR (2000) = N'';				-- SET during Execution

	DECLARE @products_cursor CURSOR;
	DECLARE @cursorState INT = 0;

	-- STEP 0.1 - NULL Protection
	IF @Username IS NULL SET @Username = ''
	IF @OutputForSQLServer IS NULL SET @OutputForSQLServer = 0
	
	BEGIN TRY
--		BEGIN TRANSACTION ONE;

	-- STEP 0.2 - Protect input parameters
		IF @LocalPath IS NULL
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Empty input parameters', 16, 10);
		END;
		 
		IF PATINDEX(N'%--%', @LocalPath) > 0
			OR PATINDEX(N'%/*%', @LocalPath) > 0
			OR PATINDEX(N'%*\%', @LocalPath) > 0
			OR PATINDEX(N'%''%', @LocalPath) > 0
		BEGIN
			SET @ResultCode = 404;
			RAISERROR('Invalid input parameters', 16, 10);
		END;

		SET @Username = [dbo].[sx_pf_pProtectString] (@Username);

		 -- STEP 1.1 - Determine transaction user
		SELECT @TransactUsername = [dbo].[sx_pf_Determine_TransactionUsername] (@Username);

		IF @TransactUsername  = N'403' 
		BEGIN
			SET @ResultCode = 403;
			RAISERROR('Transaction user don`t exists', 16, 10);
		END;

		-- STEP 3.1 Prepare products list and filepath
		IF RIGHT(@LocalPath, 1) <> N'\\'
		BEGIN
			SET @LocalPath = @LocalPath + N'\\';
		END;
		
		DECLARE @products AS TABLE (
			FactoryID NVARCHAR(255) NULL
			, ProductLineID NVARCHAR(255) NULL
			, ProductID NVARCHAR(255) NULL
			, [Filename] NVARCHAR(255) NULL
		);

		DECLARE @values AS TABLE (
		  Result NVARCHAR(max) NULL
		);

		IF OBJECT_ID('tempdb..##tmp_ExportAllProducts_Result') IS NULL
		BEGIN
			--DROP TABLE ##tmp_ExportAllProducts_Result;

			CREATE TABLE ##tmp_ExportAllProducts_Result (
				ID UNIQUEIDENTIFIER	NOT NULL
				, Result NVARCHAR(max) NULL
			);
		END;	

		INSERT INTO @products (FactoryID, ProductLineID, ProductID, [Filename])
		SELECT dP.FactoryID
			, dP.ProductLineID
			, dP.ProductID
			, @LocalPath + dP.FactoryID + N'_' + dP.ProductlineID + N'_' + dP.ProductID + N'_' + dP.NameShort + N'.sql'
		FROM [dbo].[sx_pf_dProducts] dP	INNER JOIN [dbo].[sx_pf_vUserRights] vUR
		  	ON dP.FactoryID = vUR.FactoryID 
				AND dP.ProductLineID = vUR.ProductLineID
				AND vUR.UserName = @TransactUsername
				AND vUR.[Right] IN (N'Read', N'Write');
		
		-- STEP 3.2 Export

		DECLARE @sql NVARCHAR(MAX)
		DECLARE @id NVARCHAR(MAX) = NEWID();
		DECLARE @FactoryID AS NVARCHAR(255), @ProductLineID AS NVARCHAR(255), @ProductID AS NVARCHAR(255)

		EXEC master.dbo.sp_configure 'show advanced options', 1
		RECONFIGURE
		EXEC master.dbo.sp_configure 'xp_cmdshell', 1
		RECONFIGURE 

		SET @products_cursor = CURSOR LOCAL FAST_FORWARD FOR   
		SELECT FactoryID, ProductLineID, ProductID
			, N'xp_cmdshell ''bcp "SELECT Result FROM ##tmp_ExportAllProducts_Result WHERE ID = N''''' + @id + N'''''" queryout "' + [Filename] + N'" -w -T'', NO_OUTPUT'  
		FROM @products;  
  		SET @cursorState = 1;

		OPEN @products_cursor;  
  		SET @cursorState = 2;

		FETCH NEXT FROM @products_cursor   
		INTO @FactoryID, @ProductLineID, @ProductID, @sql;  
  		
		WHILE @@FETCH_STATUS = 0  
		BEGIN  
   			INSERT INTO @values
			EXEC [dbo].[sx_pf_EXPORT_Product] @Username, @FactoryID, @ProductLineID, @ProductID, @OutputForSQLServer;			

			IF EXISTS(SELECT 1 FROM @values)
			BEGIN
				INSERT INTO ##tmp_ExportAllProducts_Result (ID, Result)
				SELECT @id, Result
				FROM @Values;

				EXEC sp_executesql @sql;

				DELETE FROM @Values; 
				DELETE FROM ##tmp_ExportAllProducts_Result
				WHERE ID = @id;
			END;
    		FETCH NEXT FROM @products_cursor   
			INTO @FactoryID, @ProductLineID, @ProductID, @sql;   
		END;
		 
		SET @ResultCode = 200;

	--	COMMIT TRANSACTION ONE;
	END TRY
	BEGIN CATCH
		DECLARE @Error_state INT = ERROR_STATE();
		SET @Comment = ERROR_MESSAGE();
	 
	--	ROLLBACK TRANSACTION ONE;		

		IF @Error_state <> 10 BEGIN
			SET @ResultCode = 500;
			PRINT 'Rollback due to not executable command' + ISNULL(': '+ @Comment, '.');
		END
		ELSE IF @ResultCode IS NULL OR @ResultCode/100 = 2
		BEGIN
			SET @ResultCode = 500;	
		END;
	END CATCH

	EXEC master.dbo.sp_configure 'show advanced options', 1
	RECONFIGURE
	EXEC master.dbo.sp_configure 'xp_cmdshell', 0
	RECONFIGURE 

	IF @cursorState > 0 
	BEGIN
		IF @cursorState > 1 CLOSE @products_cursor; 
	 
		DEALLOCATE @products_cursor;  
	END;
	
	EXEC [dbo].[sx_pf_pPOST_API_LogEntry] @Username, @TransactUsername, @ProcedureName, @ParameterString, @EffectedRows, @ResultCode, @TimestampCall, @Comment;
	RETURN @ResultCode;
END
GO

  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_Export_Product_All] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_Export_Product_All] TO pf_PlanningFactoryService;
GO



	

-- Export einer Factory für den Import in ein bestehende Werk

--Löschen der alten Funktion
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_fExportFactory]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [sx_pf_fExportFactory]
GO

CREATE FUNCTION sx_pf_fExportFactory (
	 @FactoryID AS NVARCHAR(255)
	)

RETURNS TABLE
AS
RETURN
( 
	-- HEADER für Import, vorbelegt mit bestehenden Namen
	SELECT 
		'DECLARE @FactoryID NVARCHAR(255)
		 DECLARE @FKey INTEGER
		 		
		 SET @FactoryID= ''' + @FactoryID + '''-- wird gelöscht und neu angelegt !!' AS Befehl
		

	UNION ALL

	-- Objekt löschen auf dFactories, gFactories, dProductLines, gProductLines, dProducts, gProducts, dValueSeries, fValues 
	SELECT	
		 'DELETE FROM sx_pf_dFactories WHERE FactoryID = @FactoryID'

	UNION ALL
	
	SELECT	
		 'DELETE FROM sx_pf_gFactories WHERE FactoryID = @FactoryID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_dProductLines WHERE FactoryID = @FactoryID'

	UNION ALL
	
	SELECT	
		 'DELETE FROM sx_pf_gProductLines WHERE FactoryID = @FactoryID'

	UNION ALL
	
	SELECT	
		 'DELETE FROM sx_pf_dProducts WHERE FactoryID = @FactoryID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_gProducts WHERE FactoryID = @FactoryID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_dValueSeries WHERE FactoryID = @FactoryID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_fValues WHERE FactoryID = @FactoryID'
	
	UNION ALL

	-- temporäre Key Tabelle erzeugen
	SELECT 
	'DECLARE @PFKeysTemp TABLE
	(
		 FKey	INT NOT NULL
		,PLKey	INT
		,PLID   NVARCHAR(255)
		,PKey	INT
		,VSKey	INT
	)'

	UNION ALL

	SELECT 'DECLARE @Keys AS TABLE ([Key] INT);'

	UNION ALL
	-- DATEN EINFÜGEN -------------------------------------------------------------------------------------
	-- Einfügen in dFactories
	SELECT	
		 'INSERT INTO sx_pf_dFactories OUTPUT INSERTED.FactoryKey INTO @Keys([Key]) VALUES (
			  @FactoryID
			   ,''' + NameShort + '''
			   ,''' + NameLong + '''
			   ,''' + CommentUser + '''
			   ,''' + CommentDev + '''
			   ,''' + ResponsiblePerson + '''
			   ,''' + ImageName + ''')'
		  FROM sx_pf_dFactories WHERE FactoryID = @FactoryID 
	UNION ALL
	
	-- FKey catchen
	SELECT 'SELECT TOP 1 @FKey = [Key] FROM @Keys'

	UNION ALL

	-- Einfügen in gFactories
	SELECT	
		 'INSERT INTO sx_pf_gFactories VALUES (
			  @FKey,@FactoryID
			  ,''' + PropertyID + '''
			  ,''' + PropertyName + '''
			  ,''' + CommentUser + '''
			  ,''' + CommentDev + '''
			  ,''' + Unit + '''
			  ,''' + ValueText + '''
			   ,' + CAST(ValueInt AS NVARCHAR) + '
			  ,' + CAST(Scale AS NVARCHAR) + '
			  ,' + CAST(IsROSystemProperty AS NVARCHAR) + '
			  ,''' + FormatID + ''')' 
		  FROM sx_pf_gFactories  WHERE FactoryID = @FactoryID 

UNION ALL

	-- Einfügen in dProductLines
	SELECT	
		 'INSERT INTO sx_pf_dProductLines VALUES (
		   @FKey,''' + ProductLineID + ''',@FactoryID
		  ,''' + NameShort + '''
		  ,''' + NameLong + '''
		  ,''' + CommentUser + '''
		  ,''' + CommentDev + '''
		  ,''' + ResponsiblePerson + '''
		  ,''' + ImageName + '''
		  ,''' + DefaultTemplate + '''
		  ,''' + GlobalAttributeSource1 + ''',''' + GlobalAttributeAlias1 + ''',''' + GlobalAttributeSource2 + ''',''' + GlobalAttributeAlias2 + ''',''' + GlobalAttributeSource3 + ''',''' + GlobalAttributeAlias3 + '''
		  ,''' + GlobalAttributeSource4 + ''',''' + GlobalAttributeAlias4 + ''',''' + GlobalAttributeSource5 + ''',''' + GlobalAttributeAlias5 + ''',''' + GlobalAttributeSource6 + ''',''' + GlobalAttributeAlias6 + '''
		  ,''' + GlobalAttributeSource7 + ''',''' + GlobalAttributeAlias7 + ''',''' + GlobalAttributeSource8 + ''',''' + GlobalAttributeAlias8 + ''',''' + GlobalAttributeSource9 + ''',''' + GlobalAttributeAlias9 + '''
		  ,''' + GlobalAttributeSource10 + ''',''' + GlobalAttributeAlias10 + ''',''' + GlobalAttributeSource11 + ''',''' + GlobalAttributeAlias11 + ''',''' + GlobalAttributeSource12 + ''',''' + GlobalAttributeAlias12 + '''
		  ,''' + GlobalAttributeSource13 + ''',''' + GlobalAttributeAlias13 + ''',''' + GlobalAttributeSource14 + ''',''' + GlobalAttributeAlias14 + ''',''' + GlobalAttributeSource15 + ''',''' + GlobalAttributeAlias15 + '''
		  ,''' + GlobalAttributeSource16 + ''',''' + GlobalAttributeAlias16 + ''',''' + GlobalAttributeSource17 + ''',''' + GlobalAttributeAlias17 + ''',''' + GlobalAttributeSource18 + ''',''' + GlobalAttributeAlias18 + '''
		  ,''' + GlobalAttributeSource19 + ''',''' + GlobalAttributeAlias19 + ''',''' + GlobalAttributeSource20 + ''',''' + GlobalAttributeAlias20 + ''',''' + GlobalAttributeSource21 + ''',''' + GlobalAttributeAlias21 + '''
		  ,''' + GlobalAttributeSource22 + ''',''' + GlobalAttributeAlias22 + ''',''' + GlobalAttributeSource23 + ''',''' + GlobalAttributeAlias23 + ''',''' + GlobalAttributeSource24 + ''',''' + GlobalAttributeAlias24 + '''
		  ,''' + GlobalAttributeSource25 + '''
		  ,''' + GlobalAttributeAlias25 + ''')'
	  FROM sx_pf_dProductLines  WHERE FactoryID = @FactoryID 

UNION ALL

-- PLKeys Catchen

SELECT 
	'INSERT INTO @PFKeysTemp 
		SELECT
			 @FKey
			,ProductLineKey
			,ProductLineID
			,0
			,0
		FROM sx_pf_dProductLines WHERE FactoryKey = @FKey'

UNION ALL

-- Einfügen in gProductLines
	SELECT	
		 'INSERT INTO sx_pf_gProductLines VALUES (
			   0,@FKey,''' + ProductLineID + ''',@FactoryID
			  ,''' + PropertyID + '''
			  ,''' + PropertyName + '''
			  ,''' + CommentUser + '''
			  ,''' + CommentDev + '''
			  ,''' + Unit + '''
			  ,''' + ValueText + '''
			   ,' + CAST(ValueInt AS NVARCHAR) + '
			  ,' + CAST(Scale AS NVARCHAR) + '
			  ,' + CAST(IsROSystemProperty AS NVARCHAR) + '
			  ,''' + FormatID + ''')'  
		 FROM sx_pf_gProductLines WHERE FactoryID = @FactoryID

--/////Update für Keys**************************************************************************************************************************
UNION ALL

SELECT 'UPDATE gPL SET gPL.ProductLineKey = t.PLKey  FROM sx_pf_gProductLines AS gPL, @PFKeysTemp AS t
							
														   WHERE	gPL.FactoryKey=@FKey AND 
																	gPL.FactoryKey = t.FKey AND
																	gPL.ProductLineID = t.PLID'

	UNION ALL
	-- Einfügen in dProducts
	SELECT	
		 'INSERT INTO sx_pf_dProducts VALUES (
		   0,@FKey,''' + ProductID + ''',''' + ProductLineID + ''',@FactoryID
		  ,''' + TimeType + '''
		  ,''' + NameShort + '''
		  ,''' + LEFT(NameLong,245) + '''
		  ,''' + CommentUser + '''
		  ,''' + CommentDev + '''
		  ,''' + ResponsiblePerson + '''
		  ,''' + ImageName + '''
		  ,''' + [Status] + '''
		  ,''' + Template + '''
		  ,''' + TemplateVersion + '''
		  ,''' + GlobalAttribute1 + ''',''' + GlobalAttribute2 + ''',''' + GlobalAttribute3 + ''',''' + GlobalAttribute4 + ''',''' + GlobalAttribute5 + '''
		  ,''' + GlobalAttribute6 + ''',''' + GlobalAttribute7 + ''',''' + GlobalAttribute8 + ''',''' + GlobalAttribute9 + ''',''' + GlobalAttribute10 + '''
		  ,''' + GlobalAttribute11 + ''',''' + GlobalAttribute12 + ''',''' + GlobalAttribute13 + ''',''' + GlobalAttribute14 + ''',''' + GlobalAttribute15 + '''
		  ,''' + GlobalAttribute16 + ''',''' + GlobalAttribute17 + ''',''' + GlobalAttribute18 + ''',''' + GlobalAttribute19 + ''',''' + GlobalAttribute20 + '''
		  ,''' + GlobalAttribute21 + ''',''' + GlobalAttribute22 + ''',''' + GlobalAttribute23 + ''',''' + GlobalAttribute24 + '''
		  ,''' + GlobalAttribute25 + ''')'
		FROM sx_pf_dProducts  WHERE FactoryID = @FactoryID 
--/////Update für Keys**************************************************************************************************************************

UNION ALL
SELECT 'UPDATE dP SET dP.ProductLineKey = t.PLKey  FROM sx_pf_dProducts AS dP, @PFKeysTemp AS t
															   WHERE 
																	dP.FactoryKey = @FKey AND
																	dP.FactoryKey = t.FKey AND
																	dP.ProductLineID = t.PLID'
	
	UNION ALL
	-- Einfügen in gProducts

	SELECT 
		'INSERT INTO sx_pf_gProducts VALUES (
			0,0,@FKey,''' + ProductID +''',''' + ProductLineID + ''',@FactoryID
			,''' + PropertyID + '''
			,''' + PropertyName + '''
			,''' + CommentUser + '''
			,''' + CommentDev + '''
			,''' + Unit + '''
			,''' + ValueText + '''
			 ,' + CAST(ValueInt AS NVARCHAR) + '
			 ,' + CAST(Scale AS NVARCHAR) + ')'
		FROM sx_pf_gProducts  WHERE FactoryID = @FactoryID

--/////Update für Keys**************************************************************************************************************************

UNION ALL
SELECT 'UPDATE gP SET gP.ProductLineKey = t.PLKey  FROM sx_pf_gProducts AS gP, @PFKeysTemp AS t
															   WHERE 
																		gP.FactoryKey=@FKey AND
																		gP.FactoryKey=t.FKey AND
																		gP.ProductLineID = t.PLID'

UNION ALL
SELECT 'UPDATE gP SET gP.ProductKey = dP.ProductKey  FROM sx_pf_gProducts AS gP, sx_pf_dProducts AS dP
															   WHERE	
																		gP.FactoryKey=@FKey AND
																		gP.ProductLineID = dP.ProductLineID AND
																		gP.ProductID = dP.ProductID'
	UNION ALL

	-- einfügen in dValueSeries
	SELECT	
		 'INSERT INTO sx_pf_dValueSeries VALUES (
			   0,0,@FKey,''' + ProductID +''',''' + ProductLineID + ''',@FactoryID
			  ,''' + ValueSeriesID +'''
			  ,' + CAST(ValueSeriesNo AS NVARCHAR) + '
			  ,''' + NameShort +'''
			  ,''' + LEFT(NameLong,245) +'''
			  ,''' + CommentUser +'''
			  ,''' + CommentDev +'''
			  ,''' + ImageName +'''
			  ,' + CAST([IsNumeric] AS NVARCHAR) + '
			  ,' + CAST(VisibilityLevel AS NVARCHAR) + '
			  ,''' + ValueSource +'''
			  ,''' + ValueListID +'''
			  ,''' + ValueFormatID +'''
			  ,''' + Unit +'''
			   ,' + CAST(Scale AS NVARCHAR) + '
			  ,''' + Effect +'''
			  ,''' + EffectParameter +''')'
		  FROM sx_pf_dValueSeries  WHERE FactoryID = @FactoryID
 
 --/////Update für Keys**************************************************************************************************************************
UNION ALL

SELECT 'UPDATE dVS SET dVS.ProductLineKey = t.PLKey  FROM sx_pf_dValueSeries AS dVS, @PFKeysTemp AS t
															   WHERE 
																		dVS.FactoryKey=@FKey AND
																		dVS.FactoryKey=t.FKey AND
																		dVS.ProductLineID = t.PLID'
UNION ALL
SELECT 'UPDATE dVS SET dVS.ProductKey = dP.ProductKey  FROM sx_pf_dValueSeries AS dVS, sx_pf_dProducts AS dP

															   WHERE	dVS.FactoryKey=@FKey AND
																		dVS.FactoryID = dP.FactoryID AND
																		dVS.ProductLineID = dP.ProductLineID AND
																		dVS.ProductID = dP.ProductID'
	
	UNION ALL
	
	-- einfügen in fValues
	SELECT	
		 'INSERT INTO sx_pf_fValues VALUES (
			   0,0,0,@FKey,''' + ProductID +''',''' + ProductLineID + ''',@FactoryID
			  ,''' + ValueSeriesID +'''
			   ,' + CAST(TimeID AS NVARCHAR) + '
			  ,''' + ValueFormula +'''
			   ,' + CAST(ValueInt AS NVARCHAR) + '
			  ,''' + ValueText +'''
			  ,''' + ValueComment +''')'
		  FROM sx_pf_fValues WHERE FactoryID = @FactoryID

--/////Update für Keys**************************************************************************************************************************
UNION ALL

SELECT 'UPDATE fV SET fV.ProductLineKey = t.PLKey  FROM sx_pf_fValues AS fV,  @PFKeysTemp AS t
															   WHERE 
																		fV.FactoryKey=@FKey AND
																		fV.FactoryKey = t.FKey AND
																		fV.ProductLineID = t.PLID'
UNION ALL
SELECT 'UPDATE fV SET fV.ProductKey = dP.ProductKey  FROM sx_pf_fValues AS fV, sx_pf_dProducts AS dP
															   WHERE 
																		fV.FactoryKey=@FKey AND
																		fV.FactoryID = dP.FactoryID AND
																		fV.ProductLineID = dP.ProductLineID AND
																		fV.ProductID = dP.ProductID'
UNION ALL
SELECT 'UPDATE fV SET fV.ValueSeriesKey = dVS.ValueSeriesKey  FROM sx_pf_fValues AS fV, sx_pf_dValueSeries AS dVS
															   WHERE	
																		fV.FactoryKey=@FKey AND
																		fV.FactoryID = dVS.FactoryID AND
																		fV.ProductLineID = dVS.ProductLineID AND
																		fV.ProductID = dVS.ProductID  AND
																		fV.ValueSeriesID = dVS.ValueSeriesID'													 
UNION ALL
SELECT 'EXEC sx_pf_materialize_vUserRights'
UNION ALL
	SELECT 'GO'
UNION ALL
	SELECT ''
)
GO

--Test call

--SELECT * FROM sx_pf_fExportFactory ('ZT')


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_fExportFormat]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[sx_pf_fExportFormat]
GO


CREATE FUNCTION [dbo].[sx_pf_fExportFormat] (
	 @FormatID AS NVARCHAR(255)
	)

RETURNS TABLE
AS
RETURN
( 
	-- HEADER für Import, vorbelegt mit bestehenden Namen
	SELECT '' AS Befehl
UNION ALL		
	SELECT 
		'DECLARE @FormatID NVARCHAR(255)	
		 SET @FormatID= ''' + @FormatID + '''' 
UNION ALL
	SELECT	
		 'DELETE FROM sx_pf_hFormats WHERE FormatID = @FormatID'
UNION ALL
	-- DATEN EINFÜGEN -------------------------------------------------------------------------------------
	SELECT	
		 'INSERT INTO sx_pf_hFormats (FormatID,BackgroundColor,FontColor,ValueFormat) VALUES (
			  @FormatID
			   ,''' + BackgroundColor + '''
			   ,''' + FontColor + '''
			   ,''' + ValueFormat + ''')'
		  FROM sx_pf_hFormats WHERE FormatID = @FormatID 

UNION ALL
	SELECT 'GO'
UNION ALL
	SELECT ''

)

GO

--TestCall

--SELECT * FROM sx_pf_fExportFormat ('suFullBlack')



-- Export einer Liste für den Import in ein bestehendes Werk

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_fExportList]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [sx_pf_fExportList]
GO

CREATE FUNCTION sx_pf_fExportList (
	 @ListID AS NVARCHAR(255)
	)

RETURNS TABLE
AS
RETURN
( 
	-- HEADER für Import, vorbelegt mit bestehenden Namen
	SELECT '' AS Befehl
UNION ALL		
	SELECT 
		'DECLARE @ListID NVARCHAR(255)	
		 SET @ListID= ''' + @ListID + '''' 
UNION ALL
	SELECT	
		 'DELETE FROM sx_pf_hLists WHERE ListID = @ListID'
UNION ALL
	SELECT	
		 'DELETE FROM sx_pf_hListValues WHERE ListID = @ListID'
UNION ALL
	-- DATEN EINFÜGEN -------------------------------------------------------------------------------------
	-- Einfügen in hLists
	SELECT	
		 'INSERT INTO sx_pf_hLists (ListID,NameShort,NameLong,CommentUser,CommentDev,Datentyp,Source,SourceFormula,FormatID) VALUES (
			  @ListID
			   ,''' + NameShort + '''
			   ,''' + NameLong + '''
			   ,''' + CommentUser + '''
			   ,''' + CommentDev + '''
			   ,''' + Datentyp + '''
			   ,''' + Source + '''
			   ,''' + SourceFormula + '''
			   ,''' + FormatID + ''')'
		  FROM sx_pf_hLists WHERE ListID = @ListID 
UNION ALL
	-- Einfügen in hListValues
	SELECT	
		 'INSERT INTO sx_pf_hListValues (ListID,ValueInt,Scale,ValueText,ValueComment,FormatID) VALUES (
		  @ListID
		  ,' + CAST(ValueInt AS NVARCHAR) + '
		  ,' + CAST(Scale AS NVARCHAR) +'
		  ,''' + ValueText + '''
		  ,''' + ValueComment + '''
		  ,''' + FormatID + ''')'
	  FROM sx_pf_hListValues  WHERE ListID = @ListID 
UNION ALL
	SELECT 'GO'
UNION ALL
	SELECT ''

)
GO

-- Export of a product by generating an import script
-- Gerd Tautenhahn for saxess-software gmbh 2015/09
-- PlanningFactory 4.0

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_fExportProduct]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [sx_pf_fExportProduct]
GO

CREATE FUNCTION sx_pf_fExportProduct (
	 @FactoryID AS NVARCHAR(255)
	,@ProductLineID AS NVARCHAR(255)
	,@ProductID AS NVARCHAR(255)
	)

RETURNS TABLE
AS
RETURN
( 
	-- HEADER for Target Definition
	SELECT 
		'DECLARE @FactoryID NVARCHAR(255)
		 DECLARE @ProductLineID NVARCHAR (255)
		 DECLARE @ProductID NVARCHAR(255)

		 DECLARE @FactoryKey INTEGER
		 DECLARE @ProductLineKey INTEGER
		 DECLARE @ProductKey INTEGER
		
		 SET @FactoryID= ''' + @FactoryID+ ''' 
		 SET @ProductLineID = '''+ @ProductLineID +''' 
		 SET @ProductID = ''' + @ProductID + '''' AS Befehl 

	-- Factory und ProductlineKey ermitteln
	UNION ALL
	SELECT
		'SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID'

	UNION ALL
	SELECT	
		'SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductlineID'

	UNION ALL

	-- Objekt löschen auf dProducts, gProducts, dValueSeries, fValues 
	SELECT	
		 'DELETE FROM sx_pf_dProducts WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_gProducts WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_dValueSeries WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_fValues WHERE FactoryKey = @FactoryKey AND ProductLineKey = @ProductLineKey AND ProductID = @ProductID'

	UNION ALL

	-- DATEN EINFÜGEN -------------------------------------------------------------------------------------
	SELECT 'DECLARE @Keys AS TABLE ([Key] INT);'
	UNION ALL
	-- Einfügen in dProducts
	SELECT	
		 'INSERT INTO sx_pf_dProducts OUTPUT Inserted.ProductKey INTO @Keys([Key]) VALUES (
		   @ProductLineKey,@FactoryKey,@ProductID,@ProductLineID,@FactoryID
		  ,''' + TimeType + ''',''' + NameShort + ''',''' + LEFT(NameLong,245) + ''',''' + CommentUser + ''',''' + CommentDev + ''',''' + ResponsiblePerson + '''
		  ,''' + ImageName + ''',''' + [Status] + ''',''' + Template + ''',''' + TemplateVersion + '''
		  ,''' + GlobalAttribute1 + ''',''' + GlobalAttribute2 + ''',''' + GlobalAttribute3 + ''',''' + GlobalAttribute4 + ''',''' + GlobalAttribute5 + '''
		  ,''' + GlobalAttribute6 + ''',''' + GlobalAttribute7 + ''',''' + GlobalAttribute8 + ''',''' + GlobalAttribute9 + ''',''' + GlobalAttribute10 + '''
		  ,''' + GlobalAttribute11 + ''',''' + GlobalAttribute12 + ''',''' + GlobalAttribute13 + ''',''' + GlobalAttribute14 + ''',''' + GlobalAttribute15 + '''
		  ,''' + GlobalAttribute16 + ''',''' + GlobalAttribute17 + ''',''' + GlobalAttribute18 + ''',''' + GlobalAttribute19 + ''',''' + GlobalAttribute20 + '''
		  ,''' + GlobalAttribute21 + ''',''' + GlobalAttribute22 + ''',''' + GlobalAttribute23 + ''',''' + GlobalAttribute24 + ''',''' + GlobalAttribute25 + ''')'
		FROM sx_pf_dProducts  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID

	UNION ALL
	SELECT
		'SELECT TOP 1 @ProductKey = [Key] FROM @Keys'
	
	UNION ALL
	-- Einfügen in gProducts

	SELECT 
		'INSERT INTO sx_pf_gProducts VALUES (
			@ProductKey,@ProductLineKey,@FactoryKey,@ProductID,@ProductLineID,@FactoryID
			,''' + PropertyID + '''
			,''' + PropertyName + '''
			,''' + CommentUser + '''
			,''' + CommentDev + '''
			,''' + Unit + '''
			,''' + ValueText + '''
			 ,' + CAST(ValueInt AS NVARCHAR) + '
			 ,' + CAST(Scale AS NVARCHAR) + ')'
		FROM sx_pf_gProducts  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID

	UNION ALL

	-- einfügen in dValueSeries
	SELECT	
		 'INSERT INTO sx_pf_dValueSeries VALUES (
			   @ProductKey,@ProductLineKey,@FactoryKey,@ProductID,@ProductLineID,@FactoryID
			  ,''' + ValueSeriesID +'''
			  ,' + CAST(ValueSeriesNo AS NVARCHAR) + '
			  ,''' + NameShort +'''
			  ,''' + LEFT(NameLong,245) +'''
			  ,''' + CommentUser +'''
			  ,''' + CommentDev +'''
			  ,''' + ImageName +'''
			  ,' + CAST([IsNumeric] AS NVARCHAR) + '
			  ,' + CAST(VisibilityLevel AS NVARCHAR) + '
			  ,''' + ValueSource +'''
			  ,''' + ValueListID +'''
			  ,''' + ValueFormatID +'''
			  ,''' + Unit +'''
			   ,' + CAST(Scale AS NVARCHAR) + '
			  ,''' + Effect +'''
			  ,''' + EffectParameter +''')'
		  FROM sx_pf_dValueSeries  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID
	
	UNION ALL
	
	-- einfügen in fValues
	SELECT	
		 'INSERT INTO sx_pf_fValues VALUES (
			   0,@ProductKey,@ProductLineKey,@FactoryKey,@ProductID,@ProductLineID,@FactoryID
			  ,''' + ValueSeriesID +''',' + CAST(TimeID AS NVARCHAR) + ',''' + ValueFormula +''',' + CAST(ValueInt AS NVARCHAR) + ',''' + ValueText +''',''' + ValueComment +''')'
		  FROM sx_pf_fValues WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND ProductID = @ProductID

--/////Update für ValueSeriesKeys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE fV SET fV.ValueSeriesKey = dVS.ValueSeriesKey  FROM sx_pf_fValues AS fV, sx_pf_dValueSeries AS dVS
															   WHERE fV.ValueSeriesID = dVS.ValueSeriesID AND fV.ProductKey = dVS.ProductKey'
UNION ALL
	SELECT 'GO'
UNION ALL
	SELECT ''
)
GO

-- Export einer ProductLinie für den Import in eine bestehende Factory

--Löschen der alten Funktion
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[sx_pf_fExportProductLine]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [sx_pf_fExportProductLine]
GO

CREATE FUNCTION sx_pf_fExportProductLine (
	 @FactoryID AS NVARCHAR(255)
	,@ProductLineID AS NVARCHAR(255)
	)

RETURNS TABLE
AS
RETURN
( 
	-- HEADER für Import, vorbelegt mit bestehenden Namen
	SELECT 
		'DECLARE @FactoryID NVARCHAR(255)
		 DECLARE @ProductLineID NVARCHAR (255)
		
		 SET @FactoryID= ''' + @FactoryID+ '''-- MUSS vorhanden sein !!  
		 SET @ProductLineID = '''+ @ProductLineID +'''-- wird gelöscht und neu angelegt !! ' AS Befehl 

	UNION ALL

	-- Objekt löschen auf dProductLines, gProductLines, dProducts, gProducts, dValueSeries, fValues 
	SELECT	
		 'DELETE FROM sx_pf_dProductLines WHERE FactoryID = @FactoryID AND ProductLineID =  @ProductLineID'

	UNION ALL
	
	SELECT	
		 'DELETE FROM sx_pf_gProductLines WHERE FactoryID = @FactoryID AND ProductLineID =  @ProductLineID'

	UNION ALL
	
	SELECT	
		 'DELETE FROM sx_pf_dProducts WHERE FactoryID = @FactoryID AND ProductLineID =  @ProductLineID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_gProducts WHERE FactoryID = @FactoryID AND ProductLineID =  @ProductLineID'

	UNION ALL

	SELECT	
		 'DELETE FROM sx_pf_dValueSeries WHERE FactoryID = @FactoryID AND ProductLineID =  @ProductLineID'

	UNION ALL
	
	SELECT	
		 'DELETE FROM sx_pf_fValues WHERE FactoryID = @FactoryID AND ProductLineID =  @ProductLineID'
	
	UNION ALL

	-- DATEN EINFÜGEN -------------------------------------------------------------------------------------
	-- Einfügen in dProductLines
	SELECT	
		 'INSERT INTO sx_pf_dProductLines VALUES (
		   0,@ProductLineID,@FactoryID
		  ,''' + NameShort + ''',''' + NameLong + ''',''' + CommentUser + ''',''' + CommentDev + ''',''' + ResponsiblePerson + ''',''' + ImageName + ''',''' + DefaultTemplate + '''
		  ,''' + GlobalAttributeSource1 + ''',''' + GlobalAttributeAlias1 + ''',''' + GlobalAttributeSource2 + ''',''' + GlobalAttributeAlias2 + ''',''' + GlobalAttributeSource3 + ''',''' + GlobalAttributeAlias3 + '''
		  ,''' + GlobalAttributeSource4 + ''',''' + GlobalAttributeAlias4 + ''',''' + GlobalAttributeSource5 + ''',''' + GlobalAttributeAlias5 + ''',''' + GlobalAttributeSource6 + ''',''' + GlobalAttributeAlias6 + '''
		  ,''' + GlobalAttributeSource7 + ''',''' + GlobalAttributeAlias7 + ''',''' + GlobalAttributeSource8 + ''',''' + GlobalAttributeAlias8 + ''',''' + GlobalAttributeSource9 + ''',''' + GlobalAttributeAlias9 + '''
		  ,''' + GlobalAttributeSource10 + ''',''' + GlobalAttributeAlias10 + ''',''' + GlobalAttributeSource11 + ''',''' + GlobalAttributeAlias11 + ''',''' + GlobalAttributeSource12 + ''',''' + GlobalAttributeAlias12 + '''
		  ,''' + GlobalAttributeSource13 + ''',''' + GlobalAttributeAlias13 + ''',''' + GlobalAttributeSource14 + ''',''' + GlobalAttributeAlias14 + ''',''' + GlobalAttributeSource15 + ''',''' + GlobalAttributeAlias15 + '''
		  ,''' + GlobalAttributeSource16 + ''',''' + GlobalAttributeAlias16 + ''',''' + GlobalAttributeSource17 + ''',''' + GlobalAttributeAlias17 + ''',''' + GlobalAttributeSource18 + ''',''' + GlobalAttributeAlias18 + '''
		  ,''' + GlobalAttributeSource19 + ''',''' + GlobalAttributeAlias19 + ''',''' + GlobalAttributeSource20 + ''',''' + GlobalAttributeAlias20 + ''',''' + GlobalAttributeSource21 + ''',''' + GlobalAttributeAlias21 + '''
		  ,''' + GlobalAttributeSource22 + ''',''' + GlobalAttributeAlias22 + ''',''' + GlobalAttributeSource23 + ''',''' + GlobalAttributeAlias23 + ''',''' + GlobalAttributeSource24 + ''',''' + GlobalAttributeAlias24 + '''
		  ,''' + GlobalAttributeSource25 + '''
		  ,''' + GlobalAttributeAlias25 + ''')'
	  FROM sx_pf_dProductLines  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID
--/////Update für Keys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE dPL SET dPL.FactoryKey = dF.FactoryKey  FROM sx_pf_dProductLines AS dPL, sx_pf_dFactories AS dF
													  WHERE dPL.FactoryID = dF.FactoryID'
	UNION ALL

-- Einfügen in gProductLines
	SELECT	
		 'INSERT INTO sx_pf_gProductLines VALUES (
			   0,0,@ProductLineID,@FactoryID
			  ,''' + PropertyID + '''
			  ,''' + PropertyName + '''
			  ,''' + CommentUser + '''
			  ,''' + CommentDev + '''
			  ,''' + Unit + '''
			  ,''' + ValueText + '''
			  ,' + CAST(ValueInt AS NVARCHAR) + '
			  ,' + CAST(Scale AS NVARCHAR) + '
			  ,' + CAST(IsROSystemProperty AS NVARCHAR) + '
			  ,''' + FormatID + ''')'  
		 FROM sx_pf_gProductLines WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID
--/////Update für Keys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE gPL SET gPL.FactoryKey = dF.FactoryKey  FROM sx_pf_gProductLines AS gPL, sx_pf_dFactories AS dF
													  WHERE gPL.FactoryID = dF.FactoryID'
UNION ALL
SELECT 'UPDATE gPL SET gPL.ProductLineKey = dPL.ProductLineKey  FROM sx_pf_gProductLines AS gPL, sx_pf_dProductLines AS dPL
															   WHERE gPL.ProductLineID = dPL.ProductLineID AND gPL.FactoryID=dPL.FactoryID'
	UNION ALL
	-- Einfügen in dProducts
	SELECT	
		 'INSERT INTO sx_pf_dProducts VALUES (
		   0,0,''' + ProductID + ''',@ProductLineID,@FactoryID
		  ,''' + TimeType + ''',''' + NameShort + ''',''' + LEFT(NameLong,245) + ''',''' + CommentUser + ''',''' + CommentDev + ''',''' + ResponsiblePerson + ''',''' + ImageName + '''
		  ,''' + [Status] + ''',''' + Template + ''',''' + TemplateVersion + '''
		  ,''' + GlobalAttribute1 + ''',''' + GlobalAttribute2 + ''',''' + GlobalAttribute3 + ''',''' + GlobalAttribute4 + ''',''' + GlobalAttribute5 + '''
		  ,''' + GlobalAttribute6 + ''',''' + GlobalAttribute7 + ''',''' + GlobalAttribute8 + ''',''' + GlobalAttribute9 + ''',''' + GlobalAttribute10 + '''
		  ,''' + GlobalAttribute11 + ''',''' + GlobalAttribute12 + ''',''' + GlobalAttribute13 + ''',''' + GlobalAttribute14 + ''',''' + GlobalAttribute15 + '''
		  ,''' + GlobalAttribute16 + ''',''' + GlobalAttribute17 + ''',''' + GlobalAttribute18 + ''',''' + GlobalAttribute19 + ''',''' + GlobalAttribute20 + '''
		  ,''' + GlobalAttribute21 + ''',''' + GlobalAttribute22 + ''',''' + GlobalAttribute23 + ''',''' + GlobalAttribute24 + '''
		  ,''' + GlobalAttribute25 + ''')'
		FROM sx_pf_dProducts  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID
--/////Update für Keys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE dP SET dP.FactoryKey = dF.FactoryKey  FROM sx_pf_dProducts AS dP, sx_pf_dFactories AS dF
													  WHERE dP.FactoryID = dF.FactoryID'
UNION ALL
SELECT 'UPDATE dP SET dP.ProductLineKey = dPL.ProductLineKey  FROM sx_pf_dProducts AS dP, sx_pf_dProductLines AS dPL
															   WHERE dP.ProductLineID = dPL.ProductLineID AND dP.FactoryID = dPL.FactoryID'
	
	UNION ALL
	-- Einfügen in gProducts

	SELECT 
		'INSERT INTO sx_pf_gProducts VALUES (
			0,0,0,''' + ProductID +''',@ProductLineID,@FactoryID
			,''' + PropertyID + '''
			,''' + PropertyName + '''
			,''' + CommentUser + '''
			,''' + CommentDev + '''
			,''' + Unit + '''
			,''' + ValueText + '''
			 ,' + CAST(ValueInt AS NVARCHAR) + '
			 ,' + CAST(Scale AS NVARCHAR) + ')'
		FROM sx_pf_gProducts  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID

--/////Update für Keys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE gP SET gP.FactoryKey = dF.FactoryKey  FROM sx_pf_gProducts AS gP, sx_pf_dFactories AS dF
													  WHERE gP.FactoryID = dF.FactoryID'
UNION ALL
SELECT 'UPDATE gP SET gP.ProductLineKey = dPL.ProductLineKey  FROM sx_pf_gProducts AS gP, sx_pf_dProductLines AS dPL
															   WHERE gP.ProductLineID = dPL.ProductLineID AND gP.FactoryID=dPL.FactoryID'
UNION ALL
SELECT 'UPDATE gP SET gP.ProductKey = dP.ProductKey  FROM sx_pf_gProducts AS gP, sx_pf_dProducts AS dP
															   WHERE gP.ProductID = dP.ProductID AND gP.ProductLineID = dP.ProductLineID AND gP.FactoryID=dP.FactoryID'
	UNION ALL

	-- einfügen in dValueSeries
	SELECT	
		 'INSERT INTO sx_pf_dValueSeries VALUES (
			   0,0,0,''' + ProductID +''',@ProductLineID,@FactoryID
			  ,''' + ValueSeriesID +'''
			   ,' + CAST(ValueSeriesNo AS NVARCHAR) + '
			  ,''' + NameShort +'''
			  ,''' + LEFT(NameLong,245) +'''
			  ,''' + CommentUser +'''
			  ,''' + CommentDev +'''
			  ,''' + ImageName +'''
			  ,' + CAST([IsNumeric] AS NVARCHAR) + '
			  ,' + CAST(VisibilityLevel AS NVARCHAR) + '
			  ,''' + ValueSource +'''
			  ,''' + ValueListID +'''
			  ,''' + ValueFormatID +'''
			  ,''' + Unit +'''
			   ,' + CAST(Scale AS NVARCHAR) + '
			  ,''' + Effect +'''
			  ,''' + EffectParameter +''')'
		  FROM sx_pf_dValueSeries  WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID
 
 --/////Update für Keys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE dVS SET dVS.FactoryKey = dF.FactoryKey  FROM sx_pf_dValueSeries AS dVS, sx_pf_dFactories AS dF
													  WHERE dVS.FactoryID = dF.FactoryID'
UNION ALL
SELECT 'UPDATE dVS SET dVS.ProductLineKey = dPL.ProductLineKey  FROM sx_pf_dValueSeries AS dVS, sx_pf_dProductLines AS dPL
															   WHERE dVS.ProductLineID = dPL.ProductLineID AND dVS.FactoryID=dPL.FactoryID'
UNION ALL
SELECT 'UPDATE dVS SET dVS.ProductKey = dP.ProductKey  FROM sx_pf_dValueSeries AS dVS, sx_pf_dProducts AS dP
															   WHERE dVS.ProductID = dP.ProductID AND dVS.ProductLineID = dP.ProductLineID AND dVS.FactoryID=dP.FactoryID'
	
	UNION ALL
	
	-- einfügen in fValues
	SELECT	
		 'INSERT INTO sx_pf_fValues VALUES (
			   0,0,0,0,''' + ProductID +''',@ProductLineID,@FactoryID
			  ,''' + ValueSeriesID +'''
			   ,' + CAST(TimeID AS NVARCHAR) + '
			  ,''' + ValueFormula +'''
			   ,' + CAST(ValueInt AS NVARCHAR) + '
			  ,''' + ValueText +'''
			  ,''' + ValueComment +''')'
		  FROM sx_pf_fValues WHERE FactoryID = @FactoryID AND ProductLineID = @ProductLineID 

--/////Update für Keys**************************************************************************************************************************
UNION ALL
SELECT 'UPDATE fV SET fV.FactoryKey = dF.FactoryKey  FROM sx_pf_fValues AS fV, sx_pf_dFactories AS dF
													  WHERE fV.FactoryID = dF.FactoryID'
UNION ALL
SELECT 'UPDATE fV SET fV.ProductLineKey = dPL.ProductLineKey  FROM sx_pf_fValues AS fV, sx_pf_dProductLines AS dPL
															   WHERE fV.ProductLineID = dPL.ProductLineID AND fV.FactoryID=dPL.FactoryID'
UNION ALL
SELECT 'UPDATE fV SET fV.ProductKey = dP.ProductKey  FROM sx_pf_fValues AS fV, sx_pf_dProducts AS dP
															   WHERE fV.ProductID = dP.ProductID  AND fV.ProductLineID = dP.ProductLineID AND fV.FactoryID=dP.FactoryID'
UNION ALL
SELECT 'UPDATE fV SET fV.ValueSeriesKey = dVS.ValueSeriesKey  FROM sx_pf_fValues AS fV, sx_pf_dValueSeries AS dVS
															   WHERE fV.ValueSeriesID = dVS.ValueSeriesID AND fV.ProductID = dVS.ProductID  AND
																	 fV.ProductLineID = dVS.ProductLineID AND fV.FactoryID=dVS.FactoryID'
UNION ALL
SELECT 'EXEC sx_pf_materialize_vUserRights'
UNION ALL
	SELECT 'GO'
UNION ALL
	SELECT ''
)
GO

--Test call

--SELECT * FROM sx_pf_fExportProductLine ('ZT', 'U')


/*
Trigger um Userrechte zu materialisieren
Werden ausgelöst, sobald in sx_pf_rRights oder sx_pf_rUser Update, Insert oder Delete Operationen erfolgen
Gerd Tautenhahn für saxess-software gmbh
PlanningFactory Version 3.0.7
06/2015
*/

-- für sx_pf_rRights Aktionen
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[mqt_vUserRights_from_rRights]'))
DROP TRIGGER [mqt_vUserRights_from_rRights]
GO

CREATE TRIGGER mqt_vUserRights_from_rRights

ON sx_pf_rRights 

AFTER INSERT, UPDATE, DELETE 

AS 

BEGIN
	EXEC sx_pf_materialize_vUserRights
END
GO



-- für sx_pf_rUser Aktionen
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[mqt_vUserRights_from_rUser]'))
DROP TRIGGER [mqt_vUserRights_from_rUser]
GO

CREATE TRIGGER mqt_vUserRights_from_rUser

ON sx_pf_rUser

AFTER INSERT, UPDATE, DELETE 

AS 
BEGIN
	EXEC sx_pf_materialize_vUserRights
END

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODELCLOUD_dFactories]'))
DROP VIEW [dbo].[sx_pf_DATAMODELCLOUD_dFactories]
GO

CREATE VIEW sx_pf_DATAMODELCLOUD_dFactories

AS

	SELECT 
			 FactoryKey
			,dF.FactoryID
			,NameShort		AS FactoryNameShort
			,dF.FactoryID + ' ' + NameShort AS FactoryIDName
			,NameLong		AS FactoryNameLong
			,CommentUser	AS FactoryCommentUser
			,CommentDev	AS FactoryCommentDev
			,ResponsiblePerson AS FactoryResponsiblePerson
			,ImageName			AS FactoryImageName

	FROM   sx_pf_dFactories dF

			INNER JOIN 
				(SELECT FactoryID FROM sx_pf_vUserRights WHERE Username = HOST_NAME() AND [Right] IN ('Write','Read') GROUP BY FactoryID) vUR
				ON dF.FactoryID = vUR.FactoryID
				

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODELCLOUD_dProductLines]'))
DROP VIEW [dbo].[sx_pf_DATAMODELCLOUD_dProductLines]
GO

CREATE VIEW sx_pf_DATAMODELCLOUD_dProductLines 

AS

	SELECT 
			 ProductLineKey
			,dPL.ProductLineID
			,dPL.FactoryID
			,NameShort	AS ProductLineNameShort
			,dPL.ProductLineID + ' ' + NameShort AS ProductLineIDName
			,NameLong	AS ProductLineNameLong
			,CommentUser AS ProductLineCommentUser
			,CommentDev			AS ProductLineCommentDev
			,ResponsiblePerson	AS ProductLineResponsiblePerson
			,ImageName			AS ProductLineImageName
			,DefaultTemplate
			,GlobalAttributeAlias1
			,GlobalAttributeAlias2
			,GlobalAttributeAlias3
			,GlobalAttributeAlias4
			,GlobalAttributeAlias5
			,GlobalAttributeAlias6
			,GlobalAttributeAlias7
			,GlobalAttributeAlias8
			,GlobalAttributeAlias9
			,GlobalAttributeAlias10
			,GlobalAttributeAlias11
			,GlobalAttributeAlias12
			,GlobalAttributeAlias13
			,GlobalAttributeAlias14
			,GlobalAttributeAlias15
			,GlobalAttributeAlias16
			,GlobalAttributeAlias17
			,GlobalAttributeAlias18
			,GlobalAttributeAlias19
			,GlobalAttributeAlias20
			,GlobalAttributeAlias21
			,GlobalAttributeAlias22
			,GlobalAttributeAlias23
			,GlobalAttributeAlias24
			,GlobalAttributeAlias25
	FROM   sx_pf_dProductLines dPL

			INNER JOIN 
				(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = HOST_NAME () AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
				ON
					dPL.FactoryID = vUR.FactoryID AND
					dPL.ProductLineID = vUR.ProductLineID

GO
				

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODELCLOUD_dProducts]'))
DROP VIEW [dbo].[sx_pf_DATAMODELCLOUD_dProducts]
GO

CREATE VIEW sx_pf_DATAMODELCLOUD_dProducts

AS

	SELECT 
			 ProductKey
			,ProductID
			,dP.ProductLineID
			,dP.FactoryID
			,TimeType
			,NameShort	AS ProductNameShort
			,ProductID + ' ' + NameShort AS ProductIDName
			,NameLong	AS ProductNameLong
			,CommentUser	AS ProductCommentUser
			,CommentDev	AS ProductCommentDev
			,ResponsiblePerson	AS ProductResponsiblePerson
			,ImageName			AS ProductImageName
			,[Status]
			,Template
			,TemplateVersion
			,GlobalAttribute1
			,GlobalAttribute2
			,GlobalAttribute3
			,GlobalAttribute4
			,GlobalAttribute5
			,GlobalAttribute6
			,GlobalAttribute7
			,GlobalAttribute8
			,GlobalAttribute9
			,GlobalAttribute10
			,GlobalAttribute11
			,GlobalAttribute12
			,GlobalAttribute13
			,GlobalAttribute14
			,GlobalAttribute15
			,GlobalAttribute16
			,GlobalAttribute17
			,GlobalAttribute18
			,GlobalAttribute19
			,GlobalAttribute20
			,GlobalAttribute21
			,GlobalAttribute22
			,GlobalAttribute23
			,GlobalAttribute24
			,GlobalAttribute25
	FROM   sx_pf_dProducts dP

			INNER JOIN 
				(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = HOST_NAME () AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
				ON
					dP.FactoryID = vUR.FactoryID AND
					dP.ProductLineID = vUR.ProductLineID

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODELCLOUD_dValueSeries]'))
DROP VIEW [dbo].[sx_pf_DATAMODELCLOUD_dValueSeries]
GO

CREATE VIEW sx_pf_DATAMODELCLOUD_dValueSeries 

AS

		SELECT 
			 ValueSeriesKey
			,ProductID
			,dVS.ProductLineID
			,dVS.FactoryID
			,ValueSeriesID
			,ValueSeriesNo
			,NameShort AS ValueSeriesNameShort
			,ValueSeriesID + ' ' + NameShort AS ValueSeriesIDName
			,NameLong AS ValueSeriesNameLong
			,CommentUser AS ValueSeriesCommentUser
			,CommentDev AS ValueSeriesCommentDev
			,ImageName AS ValueSeriesImageName
			,[IsNumeric]
			,VisibilityLevel
			,ValueSource
			,ValueListID
			,ValueFormatID
			,Unit
			,Scale
			,Effect
			,EffectParameter
		FROM   sx_pf_dValueSeries dVS 

				INNER JOIN 
					(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = HOST_NAME () AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
					ON
						dVS.FactoryID = vUR.FactoryID AND
						dVS.ProductLineID = vUR.ProductLineID

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODELCLOUD_fValues]'))
DROP VIEW [dbo].[sx_pf_DATAMODELCLOUD_fValues]
GO

CREATE VIEW sx_pf_DATAMODELCLOUD_fValues

AS

	SELECT 
			 fV.ProductKey
			,fV.ProductLineKey
			,fV.FactoryKey
			,fV.ValueSeriesKey
			,fV.ProductID
			,fV.ProductLineID
			,fV.FactoryID
			,fV.ValueSeriesID
			,TimeID
			,CAST(LEFT(TimeID,4) AS int) AS [Year]
			,CAST(Right(LEFT(TimeID,6),2) AS int) AS [Month]
			,TRY_CONVERT(Date,CAST(TimeID AS nvarchar),102) AS [Date]
			,TRY_CONVERT(Datetime,CAST(TimeID AS nvarchar),102) AS [Datetime]
			,ValueFormula
			,CAST(ValueInt AS Money) / Coalesce(dVS.Scale,1) AS Value
			,ValueText
			,ValueComment
					
	FROM   sx_pf_fValues fV 

			LEFT JOIN sx_pf_dValueSeries dVS 
				ON fV.ValueSeriesKey = dVS.ValueSeriesKey

			INNER JOIN 
				(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = HOST_NAME () AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
				ON
					fV.FactoryID = vUR.FactoryID AND
					fV.ProductLineID = vUR.ProductLineID

			WHERE ValueInt != 0 OR ( ValueText != ''  AND ValueText != '-')
GO
			

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODEL_dFactories]'))
DROP VIEW [dbo].[sx_pf_DATAMODEL_dFactories]
GO

CREATE VIEW sx_pf_DATAMODEL_dFactories

AS

	SELECT 
			 FactoryKey
			,dF.FactoryID
			,NameShort		AS FactoryNameShort
			,dF.FactoryID + ' ' + NameShort AS FactoryIDName
			,NameLong		AS FactoryNameLong
			,CommentUser	AS FactoryCommentUser
			,CommentDev	AS FactoryCommentDev
			,ResponsiblePerson AS FactoryResponsiblePerson
			,ImageName			AS FactoryImageName

	FROM   sx_pf_dFactories dF

			INNER JOIN 
				(SELECT FactoryID FROM sx_pf_vUserRights WHERE Username = SYSTEM_USER AND [Right] IN ('Write','Read') GROUP BY FactoryID) vUR
				ON dF.FactoryID = vUR.FactoryID
				

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODEL_dProductLines]'))
DROP VIEW [dbo].[sx_pf_DATAMODEL_dProductLines]
GO

CREATE VIEW sx_pf_DATAMODEL_dProductLines 

AS

	SELECT 
			 ProductLineKey
			,dPL.ProductLineID
			,dPL.FactoryID
			,NameShort	AS ProductLineNameShort
			,dPL.ProductLineID + ' ' + NameShort AS ProductLineIDName
			,NameLong	AS ProductLineNameLong
			,CommentUser AS ProductLineCommentUser
			,CommentDev			AS ProductLineCommentDev
			,ResponsiblePerson	AS ProductLineResponsiblePerson
			,ImageName			AS ProductLineImageName
			,DefaultTemplate
			,GlobalAttributeAlias1
			,GlobalAttributeAlias2
			,GlobalAttributeAlias3
			,GlobalAttributeAlias4
			,GlobalAttributeAlias5
			,GlobalAttributeAlias6
			,GlobalAttributeAlias7
			,GlobalAttributeAlias8
			,GlobalAttributeAlias9
			,GlobalAttributeAlias10
			,GlobalAttributeAlias11
			,GlobalAttributeAlias12
			,GlobalAttributeAlias13
			,GlobalAttributeAlias14
			,GlobalAttributeAlias15
			,GlobalAttributeAlias16
			,GlobalAttributeAlias17
			,GlobalAttributeAlias18
			,GlobalAttributeAlias19
			,GlobalAttributeAlias20
			,GlobalAttributeAlias21
			,GlobalAttributeAlias22
			,GlobalAttributeAlias23
			,GlobalAttributeAlias24
			,GlobalAttributeAlias25
	FROM   sx_pf_dProductLines dPL

			INNER JOIN 
				(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = SYSTEM_USER AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
				ON
					dPL.FactoryID = vUR.FactoryID AND
					dPL.ProductLineID = vUR.ProductLineID

GO
				

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODEL_dProducts]'))
DROP VIEW [dbo].[sx_pf_DATAMODEL_dProducts]
GO

CREATE VIEW sx_pf_DATAMODEL_dProducts

AS

	SELECT 
			 ProductKey
			,ProductID
			,dP.ProductLineID
			,dP.FactoryID
			,TimeType
			,NameShort	AS ProductNameShort
			,ProductID + ' ' + NameShort AS ProductIDName
			,NameLong	AS ProductNameLong
			,CommentUser	AS ProductCommentUser
			,CommentDev	AS ProductCommentDev
			,ResponsiblePerson	AS ProductResponsiblePerson
			,ImageName			AS ProductImageName
			,[Status]
			,Template
			,TemplateVersion
			,GlobalAttribute1
			,GlobalAttribute2
			,GlobalAttribute3
			,GlobalAttribute4
			,GlobalAttribute5
			,GlobalAttribute6
			,GlobalAttribute7
			,GlobalAttribute8
			,GlobalAttribute9
			,GlobalAttribute10
			,GlobalAttribute11
			,GlobalAttribute12
			,GlobalAttribute13
			,GlobalAttribute14
			,GlobalAttribute15
			,GlobalAttribute16
			,GlobalAttribute17
			,GlobalAttribute18
			,GlobalAttribute19
			,GlobalAttribute20
			,GlobalAttribute21
			,GlobalAttribute22
			,GlobalAttribute23
			,GlobalAttribute24
			,GlobalAttribute25
	FROM   sx_pf_dProducts dP

			INNER JOIN 
				(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = SYSTEM_USER AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
				ON
					dP.FactoryID = vUR.FactoryID AND
					dP.ProductLineID = vUR.ProductLineID

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODEL_dValueSeries]'))
DROP VIEW [dbo].[sx_pf_DATAMODEL_dValueSeries]
GO

CREATE VIEW sx_pf_DATAMODEL_dValueSeries 

AS

		SELECT 
			 ValueSeriesKey
			,ProductID
			,dVS.ProductLineID
			,dVS.FactoryID
			,ValueSeriesID
			,ValueSeriesNo
			,NameShort AS ValueSeriesNameShort
			,ValueSeriesID + ' ' + NameShort AS ValueSeriesIDName
			,NameLong AS ValueSeriesNameLong
			,CommentUser AS ValueSeriesCommentUser
			,CommentDev AS ValueSeriesCommentDev
			,ImageName AS ValueSeriesImageName
			,[IsNumeric]
			,VisibilityLevel
			,ValueSource
			,ValueListID
			,ValueFormatID
			,Unit
			,Scale
			,Effect
			,EffectParameter
		FROM   sx_pf_dValueSeries dVS 

				INNER JOIN 
					(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = SYSTEM_USER AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
					ON
						dVS.FactoryID = vUR.FactoryID AND
						dVS.ProductLineID = vUR.ProductLineID

GO

/*
View to deliver dimensional data to the enduser with direct database access
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAMODEL_fValues]'))
DROP VIEW [dbo].[sx_pf_DATAMODEL_fValues]
GO

CREATE VIEW sx_pf_DATAMODEL_fValues

AS

	SELECT 
			 fV.ProductKey
			,fV.ProductLineKey
			,fV.FactoryKey
			,fV.ValueSeriesKey
			,fV.ProductID
			,fV.ProductLineID
			,fV.FactoryID
			,fV.ValueSeriesID
			,TimeID
			,CAST(LEFT(TimeID,4) AS int) AS [Year]
			,CAST(Right(LEFT(TimeID,6),2) AS int) AS [Month]
			,TRY_CONVERT(Date,CAST(TimeID AS nvarchar),102) AS [Date]
			,TRY_CONVERT(Datetime,CAST(TimeID AS nvarchar),102) AS [Datetime]
			,ValueFormula
			,CAST(ValueInt AS Money) / Coalesce(dVS.Scale,1) AS Value
			,ValueText
			,ValueComment
					
	FROM   sx_pf_fValues fV 

			LEFT JOIN sx_pf_dValueSeries dVS 
				ON fV.ValueSeriesKey = dVS.ValueSeriesKey

			INNER JOIN 
				(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = SYSTEM_USER AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
				ON
					fV.FactoryID = vUR.FactoryID AND
					fV.ProductLineID = vUR.ProductLineID


			WHERE ValueInt != 0 OR ( ValueText != ''  AND ValueText != '-')
GO
			

/*
View for analysing the LogEntrys of PlanningFactory API

11/2015 for PlanningFactory 4.0
Gerd Tautenhahn for saxess-software gmbh
*/


IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[sx_pf_vLogEntrys]'))
DROP VIEW sx_pf_vLogEntrys
GO

CREATE VIEW sx_pf_vLogEntrys AS 

SELECT 
	 @@Servername AS Servername
	,DB_NAME()  AS ClusterName
	,SQLSystemUser
	,tL.Username AS ServiceUsername
	,IIF(tL.Username = 'SQL','Active',rU2.Status) AS ServiceUserStatus
	,TransactUsername
	,rU1.Status AS TransactUserStatus
	,ProcedureName
	,ParameterString
	,EffectedRows
	,ReturnCode
	,TimestampCall
	,TimestampReturn
	,CASE
		WHEN DATEDIFF(SECOND,TimestampCall,TimestampReturn) < 10 THEN
			DATEDIFF(MILLISECOND,TimestampCall,TimestampReturn)
		ELSE
			10000
	END AS DurationInMilliseconds
	
	--,DATEDIFF(MILLISECOND,TimestampCall,TimestampReturn) AS DurationInMilliseconds
	,DATEDIFF(SECOND,TimestampCall,TimestampReturn) AS DurationInSeconds
	,Comment
	,ProcessCode

FROM 
	sx_pf_API_Log tL 
		LEFT JOIN sx_pf_rUser rU1 ON tL.TransactUsername = rU1.Username
		LEFT JOIN sx_pf_rUser rU2 ON tL.UserName = rU2.UserName

GO

-- Fill sx_pf_gCluster with initial data ##########################################################################################################################################

-- REFRESH RuntimeValues on every API Update
DELETE FROM sx_pf_gCluster WHERE PropertyID IN ('DB01','DB02','DB03','DB04')

INSERT INTO sx_pf_gCluster
           (PropertyID
           ,PropertyName
           ,CommentUser
           ,CommentDev
           ,Unit
           ,ValueText
           ,ValueInt
           ,Scale
		   ,IsROSystemproperty
		   ,FormatID)
     VALUES
		   -- Database Properties ---------------------------------------------------------
		   (
		    'DB01'
           ,'DatabaseServer'
           ,'Name of the DatabaseServer, hosting this Cluster.'
           ,'SystemValue of last Refresh, not necessary Runtime Value.'
           ,'Text'
           ,@@SERVERNAME
           ,0
           ,0
		   ,1
		   ,'')
		   ,
		   (
			 'DB02'
			,'DatabaseInstance'
			,'Name of the DatabaseInstance, hosting this Cluster.'
			,'SystemValue of last Refresh, not necessary Runtime Value.'
			,'Text'
			,@@SERVICENAME
			,0
			,0
			,1
			,'none'),
		   (
		    'DB03'
           ,'DatabaseVersion'
           ,'DatabaseVersion, hosting this Cluster.'
           ,'SystemValue of last Refresh, not necessary Runtime Value.'
           ,'Text'
           ,@@VERSION
           ,0
           ,0
		   ,1
		   ,'')
		   ,
		   (
		    'DB04'
           ,'DatabaseName'
           ,'DatabaseName, hosting this Cluster.'
           ,'SystemValue of last Refresh, not necessary Runtime Value.'
           ,'Text'
           ,DB_NAME()
           ,0
           ,0
		   ,1
		   ,'')


-- Keep UserValues *****************************************************
DECLARE @ExistFlag INT = 0

-- AutoUpdate
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('DB05') AND PropertyName = 'AutoUpdate T_SQL_API'
IF @ExistFlag = 0 
		BEGIN
			DELETE FROM sx_pf_gCluster WHERE PropertyID = 'DB05'
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('DB05','AutoUpdate T_SQL_API','Flag to update the T_SQL_API always to the latest version','','Boolean','',1,1,0,'')
		END

-- Clustername
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('C01')
IF @ExistFlag = 0 
	
		BEGIN
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('C01','ClusterName','Name of this Cluster','Set on GUI','Text','<give me a name>',0,0,0,'')
		END

-- BaseCurrency
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('C02')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('C02','ClusterBaseCurrency','BaseCurrency of this Cluster','will be set by UNIKUM','Text','',0,0,0,'')
		END


-- BaseLanguage
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('C03')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('C03','ClusterBaseLanguage','BaseLanguage of this Cluster','will be set by UNIKUM','Text','',0,0,0,'')
		END

-- API Version
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('C04')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('C04','T_SQL_API_Version','version of T_SQL_API','will be set by API Script','Text','',0,0,0,'')
		END


-- IsInMainantenceMode
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('C05')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('C05','IsInMaintanceMode','Cluster is in Maintenance Mode Flag to keep users out','will be set by Update / Maintanence Script ','Text','FALSE',0,0,0,'')
		END

-- PreferencesAreUserDependendFlag
SELECT @ExistFlag = Count(*) FROM sx_pf_gCluster WHERE PropertyID IN ('C06')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gCluster (PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('C06','PreferencesAreUserDependendFlag','Preferences are saved per User','will be set by ClusterAdmin ','Flag','',1,1,0,'')
		END

--- gFactories ##########################################################################################################################################


-- PreferencesAreUserDependendFlag
SELECT @ExistFlag = Count(*) FROM sx_pf_gFactories WHERE PropertyID IN ('F06')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gFactories(PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('F06','PreferencesAreUserDependendFlag','Preferences are saved per User','will be set by ClusterAdmin','Flag','',1,1,0,'')
		END

--- gProductlines ##########################################################################################################################################

-- PreferencesAreUserDependendFlag
SELECT @ExistFlag = Count(*) FROM sx_pf_gFactories WHERE PropertyID IN ('P06')
IF @ExistFlag = 0 
		BEGIN
			INSERT INTO sx_pf_gFactories(PropertyID,PropertyName,CommentUser,CommentDev,Unit,ValueText,ValueInt,Scale,IsROSystemproperty,FormatID)
			VALUES ('P06','PreferencesAreUserDependendFlag','Preferences are saved per User','will be set by ClusterAdmin','Flag','',1,1,0,'')
		END

GO

/*
Procedure to deliver analytic data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
12/2015
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_Balance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_Balance]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_Balance (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS

-- OPEN: Check Security etc.
-- OPEN: Logger

DECLARE @TransactUsername AS NVARCHAR (255)
DECLARE @Resultcode AS INT

-- Transaktionsuser ermitteln
SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
IF @TransactUsername  = '403'	BEGIN
									SET @ResultCode = 403
									--ROLLBACK TRANSACTION ONE
									--EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
									RETURN @ResultCode
								END

IF @FactoryID = '' AND @ProductLineID = '' 
	SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.BalanceEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.BalanceEffect <> 0

IF @FactoryID <> '' AND @ProductLineID = ''
		SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.BalanceEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.BalanceEffect <> 0 AND
		fV.FactoryID = @FactoryID

IF @FactoryID = '' AND @ProductLineID <> ''
		SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.BalanceEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.BalanceEffect <> 0 AND
		fV.ProductLineID = @ProductLineID

IF @FactoryID <> '' AND @ProductLineID <> ''
		SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.BalanceEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.BalanceEffect <> 0 AND
		fV.FactoryID = @FactoryID AND
		fV.ProductLineID = @ProductLineID

SET @Resultcode = 200 

RETURN @Resultcode
		
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_Balance] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_Balance] TO pf_PlanningFactoryService;
GO

/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_Balance] 
   @Username
  ,@FactoryID
  ,@ProductLineID
Print @RC
GO


*/

/*
Procedure to deliver analytic data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
12/2015
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_CashValues]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_CashValues]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_CashValues (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS

-- OPEN: Check Security etc.
-- OPEN: Logger

DECLARE @TransactUsername AS NVARCHAR (255)
DECLARE @Resultcode AS INT

-- Transaktionsuser ermitteln
SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
IF @TransactUsername  = '403'	BEGIN
									SET @ResultCode = 403
									--ROLLBACK TRANSACTION ONE
									--EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
									RETURN @ResultCode
								END

IF @FactoryID = '' AND @ProductLineID = '' 
	SELECT 
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.CashEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.CashEffect <> 0

IF @FactoryID <> '' AND @ProductLineID = ''
		SELECT 
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.CashEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.CashEffect <> 0 AND
		fV.FactoryID = @FactoryID

IF @FactoryID = '' AND @ProductLineID <> ''
		SELECT 
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.CashEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.CashEffect <> 0 AND
		fV.ProductLineID = @ProductLineID

IF @FactoryID <> '' AND @ProductLineID <> ''
		SELECT 
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.CashEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.CashEffect <> 0 AND
		fV.FactoryID = @FactoryID AND
		fV.ProductLineID = @ProductLineID

SET @Resultcode = 200 

RETURN @Resultcode
		
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_CashValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_CashValues] TO pf_PlanningFactoryService;
GO



/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_CashValues] 
   @Username
  ,@FactoryID
  ,@ProductLineID

Print @RC
GO


*/

/*
Procedure to deliver dimensional data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_dFactories]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_dFactories]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_dFactories (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS
BEGIN
	 BEGIN TRY
		BEGIN TRANSACTION ONE

		DECLARE @TransactUsername AS NVARCHAR (255)
		DECLARE @FactoryKey AS BIGINT
		DECLARE @ProductLineKey AS BIGINT
		DECLARE @RightFlag AS INT

		--<fix log block>
		DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID)
		DECLARE @ParameterString AS NVARCHAR (MAX) = ''				-- SET HERE (all Parameters)
		DECLARE @EffectedRows AS INTEGER = 0						-- SET during Execution
		DECLARE @ResultCode AS INTEGER = 501						-- SET during Execution
		DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP
		DECLARE @Comment AS NVARCHAR (2000) = ''					-- SET during Execution

		SET @ParameterString = '''' + @Username + ''',''' +  @FactoryID +''','''+ @ProductLineID +''
		--<fix log block/>

		-- clean IDs
		SET @Username = dbo.sx_pf_pProtectString(@Username)
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID)
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID)

		-- determine Transaction User
		SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
		IF @TransactUsername  = '403'	BEGIN
											SET @ResultCode = 403
											ROLLBACK TRANSACTION ONE
											EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
											RETURN @ResultCode
										END
		



		-- CASE 1 - Called for the whole cluster - deliver whatever the user gets with his rights
		IF @FactoryID = '' AND @ProductLineID = '' 
			BEGIN
				SELECT 
					  FactoryKey
					 ,dF.FactoryID
					 ,NameShort		AS FactoryNameShort
					 ,dF.FactoryID + ' ' + NameShort AS FactoryIDName
					 ,NameLong		AS FactoryNameLong
					 ,CommentUser	AS FactoryCommentUser
					 ,CommentDev	AS FactoryCommentDev
					 ,ResponsiblePerson AS FactoryResponsiblePerson
					 ,ImageName			AS FactoryImageName

				FROM   sx_pf_dFactories dF

					 INNER JOIN 
							(SELECT FactoryID FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') GROUP BY FactoryID) vUR
							ON dF.FactoryID = vUR.FactoryID
				SET @ResultCode = 200
			END
								
		-- CASE 2 - Called for one Factory - delivier only this if Rights fit
		IF (@FactoryID <> '' AND @ProductLineID = '') OR (@FactoryID <> '' AND @ProductLineID <> '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				IF @FactoryKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(FactoryID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						-- SELECT Values
						SELECT 
							  FactoryKey
							 ,dF.FactoryID
							 ,NameShort		AS FactoryNameShort
							 ,dF.FactoryID + ' ' + NameShort AS FactoryIDName
							 ,NameLong		AS FactoryNameLong
							 ,CommentUser	AS FactoryCommentUser
							 ,CommentDev	AS FactoryCommentDev
							 ,ResponsiblePerson AS FactoryResponsiblePerson
							 ,ImageName			AS FactoryImageName

						FROM   sx_pf_dFactories dF
						WHERE FactoryKey = @FactoryKey
						SET @ResultCode = 200
					END
				ELSE
					SET @ResultCode = 401
			END
		ELSE

		-- CASE 3 - Called for one ProductLine
			-- doesnt matter, always Case 2 as no Productline in dFactories

		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		COMMIT TRANSACTION ONE
		RETURN @ResultCode

	END TRY

	BEGIN CATCH
		PRINT 'Rollback due to not executable command.'	
		ROLLBACK TRANSACTION ONE
		SET @EffectedRows = 0
		SET @ResultCode = 500
		SET @Comment = ERROR_MESSAGE()
		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		RETURN @ResultCode
	END CATCH
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dFactories] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dFactories] TO pf_PlanningFactoryService;
GO


/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = ''
DECLARE @ProductLineID nvarchar(255) = ''

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_dFactories] 
   @Username
  ,@FactoryID
  ,@ProductLineID

PRINT @RC

TestCases:
	- With empty Factory/PL ID
	- With FactoryID
	- With ProductlineID
	- With unknown User
	- With User without Rights

*/

/*
Procedure to deliver dimensional data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_dProductLines]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_dProductLines]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_dProductLines (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS
BEGIN
	 BEGIN TRY
		BEGIN TRANSACTION ONE

		DECLARE @TransactUsername AS NVARCHAR (255)
		DECLARE @FactoryKey AS BIGINT
		DECLARE @ProductLineKey AS BIGINT
		DECLARE @RightFlag AS INT

		--<fix log block>
		DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID)
		DECLARE @ParameterString AS NVARCHAR (MAX) = ''				-- SET HERE (all Parameters)
		DECLARE @EffectedRows AS INTEGER = 0						-- SET during Execution
		DECLARE @ResultCode AS INTEGER = 501						-- SET during Execution
		DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP
		DECLARE @Comment AS NVARCHAR (2000) = ''					-- SET during Execution

		SET @ParameterString = '''' + @Username + ''',''' +  @FactoryID +''','''+ @ProductLineID +''
		--<fix log block/>

		-- clean IDs
		SET @Username = dbo.sx_pf_pProtectString(@Username)
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID)
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID)

		-- determine Transaction User
		SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
		IF @TransactUsername  = '403'	BEGIN
											SET @ResultCode = 403
											ROLLBACK TRANSACTION ONE
											EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
											RETURN @ResultCode
										END
		
		-- CASE 1 - Called for the whole cluster - deliver whatever the user gets with his rights
		IF @FactoryID = '' AND @ProductLineID = '' 
			BEGIN
				SELECT 
					    ProductLineKey
					   ,dPL.ProductLineID
					   ,dPL.FactoryID
					   ,NameShort	AS ProductLineNameShort
					   ,dPL.ProductLineID + ' ' + NameShort AS ProductLineIDName
					   ,NameLong	AS ProductLineNameLong
					   ,CommentUser AS ProductLineCommentUser
					   ,CommentDev			AS ProductLineCommentDev
					   ,ResponsiblePerson	AS ProductLineResponsiblePerson
					   ,ImageName			AS ProductLineImageName
					   ,DefaultTemplate
					   ,GlobalAttributeAlias1
					   ,GlobalAttributeAlias2
					   ,GlobalAttributeAlias3
					   ,GlobalAttributeAlias4
					   ,GlobalAttributeAlias5
					   ,GlobalAttributeAlias6
					   ,GlobalAttributeAlias7
					   ,GlobalAttributeAlias8
					   ,GlobalAttributeAlias9
					   ,GlobalAttributeAlias10
					   ,GlobalAttributeAlias11
					   ,GlobalAttributeAlias12
					   ,GlobalAttributeAlias13
					   ,GlobalAttributeAlias14
					   ,GlobalAttributeAlias15
					   ,GlobalAttributeAlias16
					   ,GlobalAttributeAlias17
					   ,GlobalAttributeAlias18
					   ,GlobalAttributeAlias19
					   ,GlobalAttributeAlias20
					   ,GlobalAttributeAlias21
					   ,GlobalAttributeAlias22
					   ,GlobalAttributeAlias23
					   ,GlobalAttributeAlias24
					   ,GlobalAttributeAlias25
				FROM   sx_pf_dProductLines dPL

						INNER JOIN 
							(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
							ON
								dPL.FactoryID = vUR.FactoryID AND
								dPL.ProductLineID = vUR.ProductLineID

				SET @ResultCode = 200
			END
								
		-- CASE 2 - Called for one Factory - delivier only this if Rights fit
		IF (@FactoryID <> '' AND @ProductLineID = '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				IF @FactoryKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(FactoryID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						
						SELECT 
					    ProductLineKey
					   ,ProductLineID
					   ,FactoryID
					   ,NameShort	AS ProductLineNameShort
					   ,ProductLineID + ' ' + NameShort AS ProductLineIDName
					   ,NameLong	AS ProductLineNameLong
					   ,CommentUser AS ProductLineCommentUser
					   ,CommentDev			AS ProductLineCommentDev
					   ,ResponsiblePerson	AS ProductLineResponsiblePerson
					   ,ImageName			AS ProductLineImageName
					   ,DefaultTemplate
					   ,GlobalAttributeAlias1
					   ,GlobalAttributeAlias2
					   ,GlobalAttributeAlias3
					   ,GlobalAttributeAlias4
					   ,GlobalAttributeAlias5
					   ,GlobalAttributeAlias6
					   ,GlobalAttributeAlias7
					   ,GlobalAttributeAlias8
					   ,GlobalAttributeAlias9
					   ,GlobalAttributeAlias10
					   ,GlobalAttributeAlias11
					   ,GlobalAttributeAlias12
					   ,GlobalAttributeAlias13
					   ,GlobalAttributeAlias14
					   ,GlobalAttributeAlias15
					   ,GlobalAttributeAlias16
					   ,GlobalAttributeAlias17
					   ,GlobalAttributeAlias18
					   ,GlobalAttributeAlias19
					   ,GlobalAttributeAlias20
					   ,GlobalAttributeAlias21
					   ,GlobalAttributeAlias22
					   ,GlobalAttributeAlias23
					   ,GlobalAttributeAlias24
					   ,GlobalAttributeAlias25
						FROM   sx_pf_dProductLines

						WHERE FactoryKey = @FactoryKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		-- CASE 3 - Called for one ProductLine
		IF (@FactoryID <> '' AND @ProductLineID <> '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID
				IF @FactoryKey IS NULL OR @ProductLineKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(ProductLineID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						SELECT 
					    ProductLineKey
					   ,ProductLineID
					   ,FactoryID
					   ,NameShort	AS ProductLineNameShort
					   ,ProductLineID + ' ' + NameShort AS ProductLineIDName
					   ,NameLong	AS ProductLineNameLong
					   ,CommentUser AS ProductLineCommentUser
					   ,CommentDev			AS ProductLineCommentDev
					   ,ResponsiblePerson	AS ProductLineResponsiblePerson
					   ,ImageName			AS ProductLineImageName
					   ,DefaultTemplate
					   ,GlobalAttributeAlias1
					   ,GlobalAttributeAlias2
					   ,GlobalAttributeAlias3
					   ,GlobalAttributeAlias4
					   ,GlobalAttributeAlias5
					   ,GlobalAttributeAlias6
					   ,GlobalAttributeAlias7
					   ,GlobalAttributeAlias8
					   ,GlobalAttributeAlias9
					   ,GlobalAttributeAlias10
					   ,GlobalAttributeAlias11
					   ,GlobalAttributeAlias12
					   ,GlobalAttributeAlias13
					   ,GlobalAttributeAlias14
					   ,GlobalAttributeAlias15
					   ,GlobalAttributeAlias16
					   ,GlobalAttributeAlias17
					   ,GlobalAttributeAlias18
					   ,GlobalAttributeAlias19
					   ,GlobalAttributeAlias20
					   ,GlobalAttributeAlias21
					   ,GlobalAttributeAlias22
					   ,GlobalAttributeAlias23
					   ,GlobalAttributeAlias24
					   ,GlobalAttributeAlias25
						FROM   sx_pf_dProductLines

						WHERE ProductLineKey = @ProductLineKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		COMMIT TRANSACTION ONE
		RETURN @ResultCode

	END TRY

	BEGIN CATCH
		PRINT 'Rollback due to not executable command.'	
		ROLLBACK TRANSACTION ONE
		SET @EffectedRows = 0
		SET @ResultCode = 500
		SET @Comment = ERROR_MESSAGE()
		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		RETURN @ResultCode
	END CATCH
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dProductLines] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dProductLines] TO pf_PlanningFactoryService;
GO

/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = ''
DECLARE @ProductLineID nvarchar(255) = ''

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_dProductLines] 
   @Username
  ,@FactoryID
  ,@ProductLineID

PRINT @RC

TestCases:
	- With empty Factory/PL ID
	- With FactoryID
	- With ProductlineID
	- With unknown User
	- With User without Rights

*/

/*
Procedure to deliver dimensional data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_dProducts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_dProducts]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_dProducts (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS
BEGIN
	 BEGIN TRY
		BEGIN TRANSACTION ONE

		DECLARE @TransactUsername AS NVARCHAR (255)
		DECLARE @FactoryKey AS BIGINT
		DECLARE @ProductLineKey AS BIGINT
		DECLARE @RightFlag AS INT

		--<fix log block>
		DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID)
		DECLARE @ParameterString AS NVARCHAR (MAX) = ''				-- SET HERE (all Parameters)
		DECLARE @EffectedRows AS INTEGER = 0						-- SET during Execution
		DECLARE @ResultCode AS INTEGER = 501						-- SET during Execution
		DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP
		DECLARE @Comment AS NVARCHAR (2000) = ''					-- SET during Execution

		SET @ParameterString = '''' + @Username + ''',''' +  @FactoryID +''','''+ @ProductLineID +''
		--<fix log block/>

		-- clean IDs
		SET @Username = dbo.sx_pf_pProtectString(@Username)
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID)
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID)

		-- determine Transaction User
		SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
		IF @TransactUsername  = '403'	BEGIN
											SET @ResultCode = 403
											ROLLBACK TRANSACTION ONE
											EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
											RETURN @ResultCode
										END
		
		-- CASE 1 - Called for the whole cluster - deliver whatever the user gets with his rights
		IF @FactoryID = '' AND @ProductLineID = '' 
			BEGIN
				SELECT 
					    ProductKey
					   ,ProductID
					   ,dP.ProductLineID
					   ,dP.FactoryID
					   ,TimeType
					   ,NameShort	AS ProductNameShort
					   ,ProductID + ' ' + NameShort AS ProductIDName
					   ,NameLong	AS ProductNameLong
					   ,CommentUser	AS ProductCommentUser
					   ,CommentDev	AS ProductCommentDev
					   ,ResponsiblePerson	AS ProductResponsiblePerson
					   ,ImageName			AS ProductImageName
					   ,[Status]
					   ,Template
					   ,TemplateVersion
					   ,GlobalAttribute1
					   ,GlobalAttribute2
					   ,GlobalAttribute3
					   ,GlobalAttribute4
					   ,GlobalAttribute5
					   ,GlobalAttribute6
					   ,GlobalAttribute7
					   ,GlobalAttribute8
					   ,GlobalAttribute9
					   ,GlobalAttribute10
					   ,GlobalAttribute11
					   ,GlobalAttribute12
					   ,GlobalAttribute13
					   ,GlobalAttribute14
					   ,GlobalAttribute15
					   ,GlobalAttribute16
					   ,GlobalAttribute17
					   ,GlobalAttribute18
					   ,GlobalAttribute19
					   ,GlobalAttribute20
					   ,GlobalAttribute21
					   ,GlobalAttribute22
					   ,GlobalAttribute23
					   ,GlobalAttribute24
					   ,GlobalAttribute25
				FROM   sx_pf_dProducts dP

						INNER JOIN 
							(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
							ON
								dP.FactoryID = vUR.FactoryID AND
								dP.ProductLineID = vUR.ProductLineID

				SET @ResultCode = 200
			END
								
		-- CASE 2 - Called for one Factory - delivier only this if Rights fit
		IF (@FactoryID <> '' AND @ProductLineID = '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				IF @FactoryKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(FactoryID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						
						SELECT 
							ProductKey
						   ,ProductID
						   ,ProductLineID
						   ,FactoryID
						   ,TimeType
						   ,NameShort	AS ProductNameShort
						   ,ProductID + ' ' + NameShort AS ProductIDName
						   ,NameLong	AS ProductNameLong
						   ,CommentUser	AS ProductCommentUser
						   ,CommentDev	AS ProductCommentDev
						   ,ResponsiblePerson	AS ProductResponsiblePerson
						   ,ImageName			AS ProductImageName
						   ,[Status]
						   ,Template
						   ,TemplateVersion
						   ,GlobalAttribute1
						   ,GlobalAttribute2
						   ,GlobalAttribute3
						   ,GlobalAttribute4
						   ,GlobalAttribute5
						   ,GlobalAttribute6
						   ,GlobalAttribute7
						   ,GlobalAttribute8
						   ,GlobalAttribute9
						   ,GlobalAttribute10
						   ,GlobalAttribute11
						   ,GlobalAttribute12
						   ,GlobalAttribute13
						   ,GlobalAttribute14
						   ,GlobalAttribute15
						   ,GlobalAttribute16
						   ,GlobalAttribute17
						   ,GlobalAttribute18
						   ,GlobalAttribute19
						   ,GlobalAttribute20
						   ,GlobalAttribute21
						   ,GlobalAttribute22
						   ,GlobalAttribute23
						   ,GlobalAttribute24
						   ,GlobalAttribute25
						FROM   sx_pf_dProducts

						WHERE FactoryKey = @FactoryKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		-- CASE 3 - Called for one ProductLine
		IF (@FactoryID <> '' AND @ProductLineID <> '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID
				IF @FactoryKey IS NULL OR @ProductLineKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(ProductLineID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						SELECT 
						    ProductKey
						   ,ProductID
						   ,ProductLineID
						   ,FactoryID
						   ,TimeType
						   ,NameShort	AS ProductNameShort
						   ,ProductID + ' ' + NameShort AS ProductIDName
						   ,NameLong	AS ProductNameLong
						   ,CommentUser	AS ProductCommentUser
						   ,CommentDev	AS ProductCommentDev
						   ,ResponsiblePerson	AS ProductResponsiblePerson
						   ,ImageName			AS ProductImageName
						   ,[Status]
						   ,Template
						   ,TemplateVersion
						   ,GlobalAttribute1
						   ,GlobalAttribute2
						   ,GlobalAttribute3
						   ,GlobalAttribute4
						   ,GlobalAttribute5
						   ,GlobalAttribute6
						   ,GlobalAttribute7
						   ,GlobalAttribute8
						   ,GlobalAttribute9
						   ,GlobalAttribute10
						   ,GlobalAttribute11
						   ,GlobalAttribute12
						   ,GlobalAttribute13
						   ,GlobalAttribute14
						   ,GlobalAttribute15
						   ,GlobalAttribute16
						   ,GlobalAttribute17
						   ,GlobalAttribute18
						   ,GlobalAttribute19
						   ,GlobalAttribute20
						   ,GlobalAttribute21
						   ,GlobalAttribute22
						   ,GlobalAttribute23
						   ,GlobalAttribute24
						   ,GlobalAttribute25
						FROM   sx_pf_dProducts

						WHERE ProductLineKey = @ProductLineKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		COMMIT TRANSACTION ONE
		RETURN @ResultCode

	END TRY

	BEGIN CATCH
		PRINT 'Rollback due to not executable command.'	
		ROLLBACK TRANSACTION ONE
		SET @EffectedRows = 0
		SET @ResultCode = 500
		SET @Comment = ERROR_MESSAGE()
		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		RETURN @ResultCode
	END CATCH
END

GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dProducts] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dProducts] TO pf_PlanningFactoryService;
GO

/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_dProducts] 
   @Username
  ,@FactoryID
  ,@ProductLineID

PRINT @RC

TestCases:
	- With empty Factory/PL ID
	- With FactoryID
	- With ProductlineID
	- With unknown User
	- With User without Rights

*/

/*
Procedure to deliver dimensional data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_dValueSeries]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_dValueSeries]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_dValueSeries (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS
BEGIN
	 BEGIN TRY
		BEGIN TRANSACTION ONE

		DECLARE @TransactUsername AS NVARCHAR (255)
		DECLARE @FactoryKey AS BIGINT
		DECLARE @ProductLineKey AS BIGINT
		DECLARE @RightFlag AS INT

		--<fix log block>
		DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID)
		DECLARE @ParameterString AS NVARCHAR (MAX) = ''				-- SET HERE (all Parameters)
		DECLARE @EffectedRows AS INTEGER = 0						-- SET during Execution
		DECLARE @ResultCode AS INTEGER = 501						-- SET during Execution
		DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP
		DECLARE @Comment AS NVARCHAR (2000) = ''					-- SET during Execution

		SET @ParameterString = '''' + @Username + ''',''' +  @FactoryID +''','''+ @ProductLineID +''
		--<fix log block/>

		-- clean IDs
		SET @Username = dbo.sx_pf_pProtectString(@Username)
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID)
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID)

		-- determine Transaction User
		SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
		IF @TransactUsername  = '403'	BEGIN
											SET @ResultCode = 403
											ROLLBACK TRANSACTION ONE
											EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
											RETURN @ResultCode
										END
		
		-- CASE 1 - Called for the whole cluster - deliver whatever the user gets with his rights
		IF @FactoryID = '' AND @ProductLineID = '' 
			BEGIN
				SELECT 
					 ValueSeriesKey
					,ProductID
					,dVS.ProductLineID
					,dVS.FactoryID
					,ValueSeriesID
					,ValueSeriesNo
					,NameShort AS ValueSeriesNameShort
					,ValueSeriesID + ' ' + NameShort AS ValueSeriesIDName
					,NameLong AS ValueSeriesNameLong
					,CommentUser AS ValueSeriesCommentUser
					,CommentDev AS ValueSeriesCommentDev
					,ImageName AS ValueSeriesImageName
					,[IsNumeric]
					,VisibilityLevel
					,ValueSource
					,ValueListID
					,ValueFormatID
					,Unit
					,Scale
					,Effect
					,EffectParameter
				FROM   sx_pf_dValueSeries dVS 

						INNER JOIN 
							(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
							ON
								dVS.FactoryID = vUR.FactoryID AND
								dVS.ProductLineID = vUR.ProductLineID

				SET @ResultCode = 200
			END
								
		-- CASE 2 - Called for one Factory - delivier only this if Rights fit
		IF (@FactoryID <> '' AND @ProductLineID = '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				IF @FactoryKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(FactoryID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						
						SELECT
							 ValueSeriesKey
							,ProductID
							,ProductLineID
							,FactoryID
							,ValueSeriesID
							,ValueSeriesNo
							,NameShort AS ValueSeriesNameShort
							,ValueSeriesID + ' ' + NameShort AS ValueSeriesIDName
							,NameLong AS ValueSeriesNameLong
							,CommentUser AS ValueSeriesCommentUser
							,CommentDev AS ValueSeriesCommentDev
							,ImageName AS ValueSeriesImageName
							,[IsNumeric]
							,VisibilityLevel
							,ValueSource
							,ValueListID
							,ValueFormatID
							,Unit
							,Scale
							,Effect
							,EffectParameter
						FROM   sx_pf_dValueSeries

						WHERE FactoryKey = @FactoryKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		-- CASE 3 - Called for one ProductLine
		IF (@FactoryID <> '' AND @ProductLineID <> '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID
				IF @FactoryKey IS NULL OR @ProductLineKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(ProductLineID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						SELECT 
							 ValueSeriesKey
							,ProductID
							,ProductLineID
							,FactoryID
							,ValueSeriesID
							,ValueSeriesNo
							,NameShort AS ValueSeriesNameShort
							,ValueSeriesID + ' ' + NameShort AS ValueSeriesIDName
							,NameLong AS ValueSeriesNameLong
							,CommentUser AS ValueSeriesCommentUser
							,CommentDev AS ValueSeriesCommentDev
							,ImageName AS ValueSeriesImageName
							,[IsNumeric]
							,VisibilityLevel
							,ValueSource
							,ValueListID
							,ValueFormatID
							,Unit
							,Scale
							,Effect
							,EffectParameter
						FROM   sx_pf_dValueSeries

						WHERE ProductLineKey = @ProductLineKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		COMMIT TRANSACTION ONE
		RETURN @ResultCode

	END TRY

	BEGIN CATCH
		PRINT 'Rollback due to not executable command.'	
		ROLLBACK TRANSACTION ONE
		SET @EffectedRows = 0
		SET @ResultCode = 500
		SET @Comment = ERROR_MESSAGE()
		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		RETURN @ResultCode
	END CATCH
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dValueSeries] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_dValueSeries] TO pf_PlanningFactoryService;
GO

/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_dValueSeries] 
   @Username
  ,@FactoryID
  ,@ProductLineID

PRINT @RC

TestCases:
	- With empty Factory/PL ID
	- With FactoryID
	- With ProductlineID
	- With unknown User
	- With User without Rights

*/

/*
Procedure to deliver analytic data as factory summary
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2015
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_FactorySummary]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_FactorySummary]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_FactorySummary (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='')

AS

-- OPEN: Check Security etc.
-- OPEN: Logger

DECLARE @TransactUsername AS NVARCHAR (255)
DECLARE @Resultcode AS INT

-- Transaktionsuser ermitteln
SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
IF @TransactUsername  = '403'	BEGIN
									SET @ResultCode = 403
									--ROLLBACK TRANSACTION ONE
									--EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
									RETURN @ResultCode
								END
	SELECT 

		  TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month

         ,Sum(TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.CashEffect) AS Cash
		 ,Sum(TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.ProfitLossEffect) AS Profit
		 ,Sum(TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.BalanceEffect) AS Balance
		 ,Sum(TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.QuantityEffect) AS Quantity
		 ,Sum(TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1)) AS Value

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName


  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		dF.FactoryID = @FactoryID

  GROUP BY

  		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100																

		 ,fV.ProductLineID + ' ' + dPL.NameShort	
         ,dPL.NameShort												

		 ,fV.ProductID + ' ' + dP.NameShort			
         ,dP.NameShort												
	

SET @Resultcode = 200 

RETURN @Resultcode
		
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_FactorySummary] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_FactorySummary] TO pf_PlanningFactoryService;
GO



/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = 'PE'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_FactorySummary] 
   @Username
  ,@FactoryID

Print @RC
GO


*/

/*
Procedure to deliver dimensional data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_fValues]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_fValues]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_fValues (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS
BEGIN
	 BEGIN TRY
		BEGIN TRANSACTION ONE

		DECLARE @TransactUsername AS NVARCHAR (255)
		DECLARE @FactoryKey AS BIGINT
		DECLARE @ProductLineKey AS BIGINT
		DECLARE @RightFlag AS INT

		--<fix log block>
		DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID)
		DECLARE @ParameterString AS NVARCHAR (MAX) = ''				-- SET HERE (all Parameters)
		DECLARE @EffectedRows AS INTEGER = 0						-- SET during Execution
		DECLARE @ResultCode AS INTEGER = 501						-- SET during Execution
		DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP
		DECLARE @Comment AS NVARCHAR (2000) = ''					-- SET during Execution

		SET @ParameterString = '''' + @Username + ''',''' +  @FactoryID +''','''+ @ProductLineID +''
		--<fix log block/>

		-- clean IDs
		SET @Username = dbo.sx_pf_pProtectString(@Username)
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID)
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID)

		-- determine Transaction User
		SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
		IF @TransactUsername  = '403'	BEGIN
											SET @ResultCode = 403
											ROLLBACK TRANSACTION ONE
											EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
											RETURN @ResultCode
										END
		
		-- CASE 1 - Called for the whole cluster - deliver whatever the user gets with his rights
		IF @FactoryID = '' AND @ProductLineID = '' 
			BEGIN
				SELECT
					  fV.ProductKey
					 ,fV.ProductLineKey
					 ,fV.FactoryKey
					 ,fV.ValueSeriesKey
					 ,fV.ProductID
					 ,fV.ProductLineID
					 ,fV.FactoryID
					 ,fV.ValueSeriesID
					 ,TimeID
					 ,CAST(LEFT(TimeID,4) AS int) AS [Year]
					 ,CAST(Right(LEFT(TimeID,6),2) AS int) AS [Monath]
					 ,TRY_CONVERT(Date,CAST(TimeID AS nvarchar),102) AS [Date]
					 ,TRY_CONVERT(Datetime,CAST(TimeID AS nvarchar),102) AS [Datetime]
					 ,ValueFormula
					 ,CAST(ValueInt AS Money) / COALESCE(dVS.Scale,1) AS Value
					 ,ValueText
					 ,ValueComment
					
				FROM   sx_pf_fValues fV

						LEFT JOIN
							sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey

						INNER JOIN 
							(SELECT FactoryID,ProductLineID FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') GROUP BY FactoryID,ProductLineID) vUR
							ON
								fV.FactoryID = vUR.FactoryID AND
								fV.ProductLineID = vUR.ProductLineID

				SET @ResultCode = 200
			END
								
		-- CASE 2 - Called for one Factory - delivier only this if Rights fit
		IF (@FactoryID <> '' AND @ProductLineID = '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				IF @FactoryKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(FactoryID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						
						SELECT 
						  fV.ProductKey
						 ,fV.ProductLineKey
						 ,fV.FactoryKey
						 ,fV.ValueSeriesKey
						 ,fV.ProductID
						 ,fV.ProductLineID
						 ,fV.FactoryID
						 ,fV.ValueSeriesID
						 ,TimeID
						 ,CAST(LEFT(TimeID,4) AS int) AS [Year]
						 ,CAST(Right(LEFT(TimeID,6),2) AS int) AS [Monath]
						 ,TRY_CONVERT(Date,CAST(TimeID AS nvarchar),102) AS [Date]
						 ,TRY_CONVERT(Datetime,CAST(TimeID AS nvarchar),102) AS [Datetime]
						 ,ValueFormula
						 ,CAST(ValueInt AS Money) / COALESCE(dVS.Scale,1) AS Value
						 ,ValueText
						 ,ValueComment
					
						FROM   sx_pf_fValues fV 

						LEFT JOIN
							sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey

						WHERE fV.FactoryKey = @FactoryKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		-- CASE 3 - Called for one ProductLine
		IF (@FactoryID <> '' AND @ProductLineID <> '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID
				IF @FactoryKey IS NULL OR @ProductLineKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(ProductLineID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						SELECT
							  fV.ProductKey
							 ,fV.ProductLineKey
							 ,fV.FactoryKey
							 ,fV.ValueSeriesKey
							 ,fV.ProductID
							 ,fV.ProductLineID
							 ,fV.FactoryID
							 ,fV.ValueSeriesID
							 ,TimeID
							 ,CAST(LEFT(TimeID,4) AS int) AS [Year]
							 ,CAST(Right(LEFT(TimeID,6),2) AS int) AS [Monath]
							 ,TRY_CONVERT(Date,CAST(TimeID AS nvarchar),102) AS [Date]
							 ,TRY_CONVERT(Datetime,CAST(TimeID AS nvarchar),102) AS [Datetime]
							 ,ValueFormula
							 ,CAST(ValueInt AS Money) / COALESCE(dVS.Scale,1) AS Value
							 ,ValueText
							 ,ValueComment
					
						FROM   sx_pf_fValues fV
						 
							LEFT JOIN
								sx_pf_dValueSeries dVS ON fV.ValueSeriesKey = dVS.ValueSeriesKey


						WHERE fV.ProductLineKey = @ProductLineKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		COMMIT TRANSACTION ONE
		RETURN @ResultCode

	END TRY

	BEGIN CATCH
		PRINT 'Rollback due to not executable command.'	
		ROLLBACK TRANSACTION ONE
		SET @EffectedRows = 0
		SET @ResultCode = 500
		SET @Comment = ERROR_MESSAGE()
		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		RETURN @ResultCode
	END CATCH
END

GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_fValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_fValues] TO pf_PlanningFactoryService;
GO

/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '2'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_fValues] 
   @Username
  ,@FactoryID
  ,@ProductLineID

PRINT @RC

TestCases:
	- With empty Factory/PL ID
	- With FactoryID
	- With ProductlineID
	- With unknown User
	- With User without Rights

*/

/*
Procedure to deliver analytic data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
12/2015
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_NumericValues]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_NumericValues]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_NumericValues (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS

-- OPEN: Check Security etc.
-- OPEN: Logger

DECLARE @TransactUsername AS NVARCHAR (255)
DECLARE @Resultcode AS INT

-- Transaktionsuser ermitteln
SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
IF @TransactUsername  = '403'	BEGIN
									SET @ResultCode = 403
									--ROLLBACK TRANSACTION ONE
									--EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
									RETURN @ResultCode
								END

IF @FactoryID = '' AND @ProductLineID = '' 
	 
	 SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]


         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 

IF @FactoryID <> '' AND @ProductLineID = ''
		 SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]


         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND fV.FactoryID = @FactoryID

IF @FactoryID = '' AND @ProductLineID <> ''
		 SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]


         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND fV.ProductLineID = @ProductLineID

IF @FactoryID <> '' AND @ProductLineID <> ''
		 SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]


         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort		AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort		AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort         AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND fV.FactoryID = @FactoryID AND fV.ProductLineID = @ProductLineID


SET @Resultcode = 200 

RETURN @Resultcode
		
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_NumericValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_NumericValues] TO pf_PlanningFactoryService;
GO



/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = ''

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_NumericValues] 
   @Username
  ,@FactoryID
  ,@ProductLineID
GO


*/

/*
Procedure to deliver analytic data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
12/2015
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_Profit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_Profit]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_Profit (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS

-- OPEN: Check Security etc.
-- OPEN: Logger

DECLARE @TransactUsername AS NVARCHAR (255)
DECLARE @Resultcode AS INT

-- Transaktionsuser ermitteln
SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
IF @TransactUsername  = '403'	BEGIN
									SET @ResultCode = 403
									--ROLLBACK TRANSACTION ONE
									--EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
									RETURN @ResultCode
								END

IF @FactoryID = '' AND @ProductLineID = '' 
	SELECT 
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.ProfitLossEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.ProfitLossEffect <> 0

IF @FactoryID <> '' AND @ProductLineID = ''
			
	SELECT  
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.ProfitLossEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.ProfitLossEffect <> 0 AND fV.FactoryID = @FactoryID

IF @FactoryID = '' AND @ProductLineID <> ''
		SELECT  
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.ProfitLossEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.ProfitLossEffect <> 0 AND fV.ProductLineID = @ProductLineID

IF @FactoryID <> '' AND @ProductLineID <> ''
		SELECT  
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)) as Week
		 ,TRY_CAST(TRY_CAST(fV.TimeID AS Integer) / 10000 AS nvarchar) +'-'+ FORMAT(dbo.Week_of_Year_DE (TRY_CAST(TRY_CAST(fV.TimeID AS nvarchar) AS Datetime)),'00') as YearWeek
		 ,TRY_CAST(right(fV.TimeID,2) AS Integer) as Day
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) * gVE.ProfitLossEffect AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_gValueEffects gVE
				ON dVS.Effect = gVE.EffectID
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND
		dVS.[IsNumeric] = 1 AND
		fV.TimeID > 20000000 AND
		fV.TimeID < 21000000 AND
		gVE.ProfitLossEffect <> 0 AND fV.FactoryID = @FactoryID AND fV.ProductLineID = @ProductLineID

SET @Resultcode = 200 

RETURN @Resultcode
		
GO
  
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_Profit] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_Profit] TO pf_PlanningFactoryService;
GO

/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_Profit] 
   @Username
  ,@FactoryID
  ,@ProductLineID
GO


*/

/*
Procedure to deliver analytic data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
12/2015
*/


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_TextValues]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_TextValues]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_TextValues (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255)='', @ProductLineID AS NVARCHAR(255)='')

AS

-- OPEN: Check Security etc.
-- OPEN: Logger

DECLARE @TransactUsername AS NVARCHAR (255)
DECLARE @Resultcode AS INT

-- Transaktionsuser ermitteln
SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
IF @TransactUsername  = '403'	BEGIN
									SET @ResultCode = 403
									--ROLLBACK TRANSACTION ONE
									--EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
									RETURN @ResultCode
								END

IF @FactoryID = '' AND @ProductLineID = '' 
	SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,fV.ValueText AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueText <> '' AND fV.ValueText <> '-' AND
		dVS.[IsNumeric] = 0


IF @FactoryID <> '' AND @ProductLineID = ''
		SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,fV.ValueText AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueText <> '' AND fV.ValueText <> '-' AND
		dVS.[IsNumeric] = 0 AND fV.FactoryID = @FactoryID

IF @FactoryID = '' AND @ProductLineID <> ''
		SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,fV.ValueText AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueText <> '' AND fV.ValueText <> '-' AND
		dVS.[IsNumeric] = 0 AND fV.ProductLineID = @ProductLineID

IF @FactoryID <> '' AND @ProductLineID <> ''
		SELECT
		  fV.FactoryID
         ,fV.ProductLineID
         ,fV.ProductID
         ,fV.ValueSeriesID

		 ,TRY_CAST(fV.TimeID AS Integer) / 10000					AS Year
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100				AS Month
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime)		AS [Date]

         ,fV.ValueText AS Value

		 ,fV.FactoryID + ' ' + dF.NameShort			AS FactoryIDName 
         ,dF.NameShort								AS FactoryName
         ,dF.ResponsiblePerson						AS FResponsiblePerson

		 ,fV.ProductLineID + ' ' + dPL.NameShort	AS ProductLineIDName
         ,dPL.NameShort								AS ProductLineName
         ,dPL.ResponsiblePerson						AS PLResponsiblePerson

		 ,fV.ProductID + ' ' + dP.NameShort			AS ProductIDName
         ,dP.NameShort								AS ProductName
		 ,dP.ResponsiblePerson						AS PResponsiblePerson

		 ,fV.ValueSeriesID + ' ' + dVS.NameShort	AS ValueSeriesIDName
		 ,dVS.NameShort								AS ValueSeriesName
		 ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
		 ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

         ,dP.[Status]
         ,dP.GlobalAttribute1
         ,dP.GlobalAttribute2
         ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dP.GlobalAttribute11
         ,dP.GlobalAttribute12
         ,dP.GlobalAttribute13
         ,dP.GlobalAttribute14
         ,dP.GlobalAttribute15
         ,dP.GlobalAttribute16
         ,dP.GlobalAttribute17
         ,dP.GlobalAttribute18
         ,dP.GlobalAttribute19
         ,dP.GlobalAttribute20
         ,dP.GlobalAttribute21
         ,dP.GlobalAttribute22
         ,dP.GlobalAttribute23
         ,dP.GlobalAttribute24
         ,dP.GlobalAttribute25

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 INNER JOIN 
				(SELECT * FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND [Right] IN ('Write','Read') AND FactoryID <> '' AND ProductLineID <> '') vUR
				ON fV.FactoryID = vUR.FactoryID AND 
				   fV.ProductLineID = vUR.ProductLineID			

  WHERE fV.ValueText <> '' AND fV.ValueText <> '-' AND
		dVS.[IsNumeric] = 0 AND fV.FactoryID = @FactoryID AND fV.ProductLineID = @ProductLineID 

SET @Resultcode = 200 

RETURN @Resultcode
		
GO
   
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_TextValues] TO pf_PlanningFactoryUser;
GRANT EXECUTE ON OBJECT ::[dbo].[sx_pf_DATAOUTPUT_TextValues] TO pf_PlanningFactoryService;
GO


/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = '1'
DECLARE @ProductLineID nvarchar(255) = '1'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_TextValues] 
   @Username
  ,@FactoryID
  ,@ProductLineID

Print @RC
GO


*/

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_CPImport]'))
DROP VIEW [dbo].[sx_pf_CPImport]
GO

CREATE VIEW sx_pf_CPImport

AS

  SELECT fV.ValueSeriesID							-- A
		,dVS.NameShort         AS ValueSeriesName	-- B
		,fV.ProductID								-- C
		,dP.NameShort          AS ProductName		-- D
		,fV.ProductLineID							-- E
		,dPL.NameShort         AS ProductLineName	-- F
		,fV.FactoryID								-- G
		,dF.NameShort          AS FactoryName		-- H
         
		 ,fV.TimeID															-- I
		 ,TRY_CAST(fV.TimeID AS Integer) / 10000 as Year					-- J
		 ,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100 as Month			-- K
		 ,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime) as [Date]	--L

         ,dF.ResponsiblePerson  AS FResponsiblePerson	-- M
         ,dPL.ResponsiblePerson AS PLResponsiblePerson	-- N
         
         ,dP.ResponsiblePerson		-- O
         ,dP.[Status]				-- P
         ,dP.GlobalAttribute1		-- Q
         ,dP.GlobalAttribute2		-- R

		 ,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value -- S

		 ,dP.GlobalAttribute3
         ,dP.GlobalAttribute4
         ,dP.GlobalAttribute5
         ,dP.GlobalAttribute6
         ,dP.GlobalAttribute7
         ,dP.GlobalAttribute8
         ,dP.GlobalAttribute9
         ,dP.GlobalAttribute10
         ,dVS.ValueSeriesNo
		 ,dVS.VisibilityLevel
         ,dVS.ValueSource
         ,dVS.Unit
         ,dVS.Effect
         ,dVS.EffectParameter

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_vUserRights vR
				ON fV.FactoryID = vR.FactoryID AND 
				   fV.ProductLineID = vR.ProductLineID			

  WHERE fV.ValueInt <> 0 AND dVS.[IsNumeric] = 1 
		AND vR.[Right] IN ('Write','Read') AND vR.Username = SYSTEM_USER
		
		
GO
-- includes dynamic TimeCalculation from ValueSeries

IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_CPImport_Dynamic]'))
DROP VIEW [dbo].[sx_pf_CPImport_Dynamic]
GO

CREATE VIEW sx_pf_CPImport_Dynamic

AS

  SELECT 
		 fV.ValueSeriesID							-- A
		,dVS.NameShort         AS ValueSeriesName	-- B
		,fV.ProductID								-- C
		,dP.NameShort          AS ProductName		-- D
		,fV.ProductLineID							-- E
		,dPL.NameShort         AS ProductLineName	-- F
		,fV.FactoryID								-- G
		,dF.NameShort          AS FactoryName		-- H
         
		,COALESCE(dTD.Y, fV.TimeID/10000)			AS [Year]	-- I
		,COALESCE(dTD.M,(fV.TimeID/100)%100)		AS [Month]	-- J
		,COALESCE(dTD.D,fV.TimeID%100)				AS [Day]	-- K
		,TRY_CAST(CAST(fV.TimeID AS NVARCHAR(255)) AS DATETIME) AS [Date] -- L
		,TRY_CAST(TRY_CAST(COALESCE(dTD.Y, fV.TimeID/10000) *10000+ COALESCE(dTD.M,(fV.TimeID/100)%100)*100 + COALESCE(dTD.D,fV.TimeID%100) AS NVARCHAR(255))AS DATETIME) AS Date_Dynamic --M
		,Saison.Saison --N
        ,dF.ResponsiblePerson  AS FResponsiblePerson	-- O
        ,dPL.ResponsiblePerson AS PLResponsiblePerson	-- P
         
        ,dP.ResponsiblePerson		-- Q
        ,dP.[Status]				-- R

		,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value -- S
		
		,dP.GlobalAttribute1		
        ,dP.GlobalAttribute2		
		,dP.GlobalAttribute3
        ,dP.GlobalAttribute4
        ,dP.GlobalAttribute5
        ,dP.GlobalAttribute6
        ,dP.GlobalAttribute7
        ,dP.GlobalAttribute8
        ,dP.GlobalAttribute9
        ,dP.GlobalAttribute10
        ,dVS.ValueSeriesNo
		,dVS.VisibilityLevel
        ,dVS.ValueSource
        ,dVS.Unit
        ,dVS.Effect
        ,dVS.EffectParameter

  FROM   sx_pf_fValues fV
         LEFT JOIN sx_pf_dValueSeries dVS
                ON fV.ValueSeriesKey = dVS.ValueSeriesKey
         LEFT JOIN sx_pf_dProducts dP
                ON fV.ProductKey = dP.ProductKey
         LEFT JOIN sx_pf_dProductLines dPL
                ON fV.ProductLineKey = dPL.ProductLineKey
         LEFT JOIN sx_pf_dFactories dF
                ON fV.FactoryKey = dF.FactoryKey
		 LEFT JOIN sx_pf_vUserRights vR
				ON fV.FactoryID = vR.FactoryID AND 
				   fV.ProductLineID = vR.ProductLineID
		
		-- dynamic Time from Template Columns
		LEFT JOIN (
					SELECT
						 ProductKey
						,TimeID
						,[Y] 
						,[M] 
						,[D] 
					FROM
						(
						SELECT 
							 ProductKey
							,ValueSeriesID
							,TimeID
							,ValueInt

						FROM sx_pf_fValues

						WHERE 
							ValueSeriesID IN ('Y','M','D') AND
							ValueInt > 0
						) AS Source

					PIVOT(MAX(ValueInt) FOR ValueSeriesID IN ([Y],[M],[D])

						) AS Pivottable

					) AS dTD 
				ON  fV.ProductKey = dTD.ProductKey AND 
					fV.TimeID = dTD.TimeID	
		-- Saison
		LEFT JOIN
			(
			SELECT TimeID, ValueText AS Saison FROM sx_pf_fValues WHERE FactoryID = 'ZT' AND ProductlineID = 'FB' AND ProductID = 'P1' AND ValueSeriesID = 'S' 
			) AS Saison ON fV.TimeID/100 = Saison.TimeID/100

  WHERE 
	fV.ValueInt <> 0 AND
    fV.ValueSeriesID NOT IN ('Y','M','D','S') AND
    dF.FactoryID != 'ZT' AND -- Filter the Templates
	vR.[Right] IN ('Write','Read') AND vR.Username = SYSTEM_USER
		
GO

/*
Procedure to deliver dimensional data to the enduser
PlanningFactory 4.0
Gerd Tautenhahn, saxess-software gmbh
03/2016
*/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sx_pf_DATAOUTPUT_CPImport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sx_pf_DATAOUTPUT_CPImport]
GO

CREATE PROCEDURE sx_pf_DATAOUTPUT_CPImport (@Username AS NVARCHAR(255), @FactoryID AS NVARCHAR(255), @ProductLineID AS NVARCHAR(255))

AS
BEGIN
	 BEGIN TRY
		BEGIN TRANSACTION ONE

		DECLARE @TransactUsername AS NVARCHAR (255)
		DECLARE @FactoryKey AS BIGINT
		DECLARE @ProductLineKey AS BIGINT
		DECLARE @RightFlag AS INT

		--<fix log block>
		DECLARE @ProcedureName AS NVARCHAR (255) = OBJECT_NAME(@@PROCID)
		DECLARE @ParameterString AS NVARCHAR (MAX) = ''				-- SET HERE (all Parameters)
		DECLARE @EffectedRows AS INTEGER = 0						-- SET during Execution
		DECLARE @ResultCode AS INTEGER = 501						-- SET during Execution
		DECLARE @TimestampCall AS DATETIME = CURRENT_TIMESTAMP
		DECLARE @Comment AS NVARCHAR (2000) = ''					-- SET during Execution

		SET @ParameterString = '''' + @Username + ''',''' +  @FactoryID +''','''+ @ProductLineID +''
		--<fix log block/>

		-- clean IDs
		SET @Username = dbo.sx_pf_pProtectString(@Username)
		SET @FactoryID = dbo.sx_pf_pProtectID(@FactoryID)
		SET @ProductLineID = dbo.sx_pf_pProtectID(@ProductLineID)

		-- determine Transaction User
		SELECT @TransactUsername = dbo.sx_pf_Determine_TransactionUsername (@Username)
		IF @TransactUsername  = '403'	BEGIN
											SET @ResultCode = 403
											ROLLBACK TRANSACTION ONE
											EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
											RETURN @ResultCode
										END
		

		-- CASE 1 - Called for the whole cluster - deliver whatever the user gets with his rights
		IF @FactoryID = '' AND @ProductLineID = '' 
			BEGIN
				SELECT fV.ValueSeriesID							-- A
					,dVS.NameShort         AS ValueSeriesName	-- B
					,fV.ProductID								-- C
					,dP.NameShort          AS ProductName		-- D
					,fV.ProductLineID							-- E
					,dPL.NameShort         AS ProductLineName	-- F
					,fV.FactoryID								-- G
					,dF.NameShort          AS FactoryName		-- H
         
					,fV.TimeID															-- I
					,TRY_CAST(fV.TimeID AS Integer) / 10000 as Year					-- J
					,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100 as Month			-- K
					,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime) as [Date]	--L

					,dF.ResponsiblePerson  AS FResponsiblePerson	-- M
					,dPL.ResponsiblePerson AS PLResponsiblePerson	-- N
         
					,dP.ResponsiblePerson		-- O
					,dP.[Status]				-- P
					,dP.GlobalAttribute1		-- Q
					,dP.GlobalAttribute2		-- R

					,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value -- S

					,dP.GlobalAttribute3
					,dP.GlobalAttribute4
					,dP.GlobalAttribute5
					,dP.GlobalAttribute6
					,dP.GlobalAttribute7
					,dP.GlobalAttribute8
					,dP.GlobalAttribute9
					,dP.GlobalAttribute10
					,dVS.ValueSeriesNo
					,dVS.VisibilityLevel
					,dVS.ValueSource
					,dVS.Unit
					,dVS.Effect
					,dVS.EffectParameter

				FROM   sx_pf_fValues fV
						LEFT JOIN sx_pf_dValueSeries dVS
							ON fV.ValueSeriesKey = dVS.ValueSeriesKey
						LEFT JOIN sx_pf_dProducts dP
							ON fV.ProductKey = dP.ProductKey
						LEFT JOIN sx_pf_dProductLines dPL
							ON fV.ProductLineKey = dPL.ProductLineKey
						LEFT JOIN sx_pf_dFactories dF
							ON fV.FactoryKey = dF.FactoryKey
						LEFT JOIN sx_pf_vUserRights vR
							ON fV.FactoryID = vR.FactoryID AND 
								fV.ProductLineID = vR.ProductLineID			

				WHERE fV.ValueInt <> 0 AND dVS.[IsNumeric] = 1 
					AND vR.[Right] IN ('Write','Read') AND vR.Username = @TransactUsername


				SET @ResultCode = 200
			END
								
		-- CASE 2 - Called for one Factory - delivier only this if Rights fit
		IF (@FactoryID <> '' AND @ProductLineID = '') 
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				IF @FactoryKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(FactoryID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						-- SELECT Values
						SELECT
							 fV.ValueSeriesID							-- A
							,dVS.NameShort         AS ValueSeriesName	-- B
							,fV.ProductID								-- C
							,dP.NameShort          AS ProductName		-- D
							,fV.ProductLineID							-- E
							,dPL.NameShort         AS ProductLineName	-- F
							,fV.FactoryID								-- G
							,dF.NameShort          AS FactoryName		-- H
         
							,fV.TimeID															-- I
							,TRY_CAST(fV.TimeID AS Integer) / 10000 as Year					-- J
							,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100 as Month			-- K
							,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime) as [Date]	--L

							,dF.ResponsiblePerson  AS FResponsiblePerson	-- M
							,dPL.ResponsiblePerson AS PLResponsiblePerson	-- N
         
							,dP.ResponsiblePerson		-- O
							,dP.[Status]				-- P
							,dP.GlobalAttribute1		-- Q
							,dP.GlobalAttribute2		-- R

							,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value -- S

							,dP.GlobalAttribute3
							,dP.GlobalAttribute4
							,dP.GlobalAttribute5
							,dP.GlobalAttribute6
							,dP.GlobalAttribute7
							,dP.GlobalAttribute8
							,dP.GlobalAttribute9
							,dP.GlobalAttribute10
							,dVS.ValueSeriesNo
							,dVS.VisibilityLevel
							,dVS.ValueSource
							,dVS.Unit
							,dVS.Effect
							,dVS.EffectParameter

						FROM   sx_pf_fValues fV
								LEFT JOIN sx_pf_dValueSeries dVS
									ON fV.ValueSeriesKey = dVS.ValueSeriesKey
								LEFT JOIN sx_pf_dProducts dP
									ON fV.ProductKey = dP.ProductKey
								LEFT JOIN sx_pf_dProductLines dPL
									ON fV.ProductLineKey = dPL.ProductLineKey
								LEFT JOIN sx_pf_dFactories dF
									ON fV.FactoryKey = dF.FactoryKey	

						WHERE fV.ValueInt <> 0 AND dVS.[IsNumeric] = 1  AND fV.FactoryKey = @FactoryKey

						SET @ResultCode = 200
					END
				ELSE
					SET @ResultCode = 401
			END

		-- CASE 3 - Called for one ProductLine

		IF (@FactoryID <> '' AND @ProductLineID <> '')
			BEGIN
				-- 3. If Factory not exists break
				SELECT @FactoryKey = FactoryKey FROM sx_pf_dFactories WHERE FactoryID = @FactoryID
				SELECT @ProductLineKey = ProductLineKey FROM sx_pf_dProductLines WHERE FactoryKey = @FactoryKey AND ProductLineID = @ProductLineID
				IF @FactoryKey IS NULL OR @ProductLineKey IS NULL
									BEGIN
										SET @ResultCode = 404
										ROLLBACK TRANSACTION ONE
										EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
										RETURN @ResultCode
									END
				-- Check Rights
				SELECT @RightFlag = Count(ProductLineID) FROM sx_pf_vUserRights WHERE Username = @TransactUsername AND FactoryID = @FactoryID AND ProductLineID = @ProductLineID AND [Right] IN ('Write','Read')
				IF @RightFlag > 0
					BEGIN
						SELECT
							 fV.ValueSeriesID							-- A
							,dVS.NameShort         AS ValueSeriesName	-- B
							,fV.ProductID								-- C
							,dP.NameShort          AS ProductName		-- D
							,fV.ProductLineID							-- E
							,dPL.NameShort         AS ProductLineName	-- F
							,fV.FactoryID								-- G
							,dF.NameShort          AS FactoryName		-- H
         
							,fV.TimeID															-- I
							,TRY_CAST(fV.TimeID AS Integer) / 10000 as Year					-- J
							,(TRY_CAST(fV.TimeID AS Integer) % 10000) /100 as Month			-- K
							,TRY_CAST(TRY_CAST(fV.TimeID as nvarchar) AS Datetime) as [Date]	--L

							,dF.ResponsiblePerson  AS FResponsiblePerson	-- M
							,dPL.ResponsiblePerson AS PLResponsiblePerson	-- N
         
							,dP.ResponsiblePerson		-- O
							,dP.[Status]				-- P
							,dP.GlobalAttribute1		-- Q
							,dP.GlobalAttribute2		-- R

							,TRY_CAST(fV.ValueInt as Money) / isnull(dVS.Scale,1) AS Value -- S

							,dP.GlobalAttribute3
							,dP.GlobalAttribute4
							,dP.GlobalAttribute5
							,dP.GlobalAttribute6
							,dP.GlobalAttribute7
							,dP.GlobalAttribute8
							,dP.GlobalAttribute9
							,dP.GlobalAttribute10
							,dVS.ValueSeriesNo
							,dVS.VisibilityLevel
							,dVS.ValueSource
							,dVS.Unit
							,dVS.Effect
							,dVS.EffectParameter

						FROM   sx_pf_fValues fV
								LEFT JOIN sx_pf_dValueSeries dVS
									ON fV.ValueSeriesKey = dVS.ValueSeriesKey
								LEFT JOIN sx_pf_dProducts dP
									ON fV.ProductKey = dP.ProductKey
								LEFT JOIN sx_pf_dProductLines dPL
									ON fV.ProductLineKey = dPL.ProductLineKey
								LEFT JOIN sx_pf_dFactories dF
									ON fV.FactoryKey = dF.FactoryKey	

						WHERE fV.ValueInt <> 0 AND dVS.[IsNumeric] = 1  AND fV.ProductLineKey = @ProductLineKey

						SET @ResultCode = 200
					END
				ELSE 
					SET @ResultCode = 401 -- Rechte waren nicht da
			END

		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		COMMIT TRANSACTION ONE
		RETURN @ResultCode

	END TRY

	BEGIN CATCH
		PRINT 'Rollback due to not executable command.'	
		ROLLBACK TRANSACTION ONE
		SET @EffectedRows = 0
		SET @ResultCode = 500
		SET @Comment = ERROR_MESSAGE()
		EXEC sx_pf_pPOST_API_LogEntry @Username,@TransactUsername,@ProcedureName,@ParameterString,@EffectedRows,@ResultCode,@TimestampCall,@Comment
		RETURN @ResultCode
	END CATCH
END

GO


/*Testcall

DECLARE @RC int
DECLARE @Username nvarchar(255) = 'SQL'
DECLARE @FactoryID nvarchar(255) = 'ZT'
DECLARE @ProductLineID nvarchar(255) = 'U'

EXECUTE @RC = [dbo].[sx_pf_DATAOUTPUT_CPImport] 
   @Username
  ,@FactoryID
  ,@ProductLineID

PRINT @RC

TestCases:
	- With empty Factory/PL ID
	- With FactoryID
	- With ProductlineID
	- With unknown User
	- With User without Rights

*/

-- initial materialization of Userrights
EXEC sx_pf_materialize_vUserRights

GO

-- Set the T_SQL_API Version for the Cluster
-- The Version String has 3 Parts
		-- The first for the PlanningFactoryGeneration
		-- The Second for external API Definition
		-- The Third for the internal API Definition

-- Any Client must check, that he fits to the second Level

UPDATE sx_pf_gCluster SET ValueText = '4.0.64' WHERE PropertyID = 'C04' --Must be numeric in last section !!
GO
